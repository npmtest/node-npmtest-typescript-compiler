{"/home/travis/build/npmtest/node-npmtest-typescript-compiler/test.js":"/* istanbul instrument in package npmtest_typescript_compiler */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-typescript-compiler/lib.npmtest_typescript_compiler.js":"/* istanbul instrument in package npmtest_typescript_compiler */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_typescript_compiler = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_typescript_compiler = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-typescript-compiler/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-typescript-compiler && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_typescript_compiler */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_typescript_compiler\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_typescript_compiler.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_typescript_compiler.rollup.js'] =\n            local.assetsDict['/assets.npmtest_typescript_compiler.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_typescript_compiler.__dirname + '/lib.npmtest_typescript_compiler.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-typescript-compiler/node_modules/typescript-compiler/index.js":"/// <reference path=\"types.ts\"/>\nvar ts;\n(function (ts) {\n    function forEach(array, callback) {\n        if (array) {\n            for (var i = 0, len = array.length; i < len; i++) {\n                var result = callback(array[i]);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return undefined;\n    }\n    ts.forEach = forEach;\n    function contains(array, value) {\n        if (array) {\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    ts.contains = contains;\n    function indexOf(array, value) {\n        if (array) {\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    ts.indexOf = indexOf;\n    function countWhere(array, predicate) {\n        var count = 0;\n        if (array) {\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (predicate(array[i])) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    ts.countWhere = countWhere;\n    function filter(array, f) {\n        if (array) {\n            var result = [];\n            for (var i = 0, len = array.length; i < len; i++) {\n                var item = array[i];\n                if (f(item)) {\n                    result.push(item);\n                }\n            }\n        }\n        return result;\n    }\n    ts.filter = filter;\n    function map(array, f) {\n        if (array) {\n            var result = [];\n            for (var i = 0, len = array.length; i < len; i++) {\n                result.push(f(array[i]));\n            }\n        }\n        return result;\n    }\n    ts.map = map;\n    function concatenate(array1, array2) {\n        if (!array2 || !array2.length)\n            return array1;\n        if (!array1 || !array1.length)\n            return array2;\n        return array1.concat(array2);\n    }\n    ts.concatenate = concatenate;\n    function deduplicate(array) {\n        if (array) {\n            var result = [];\n            for (var i = 0, len = array.length; i < len; i++) {\n                var item = array[i];\n                if (!contains(result, item))\n                    result.push(item);\n            }\n        }\n        return result;\n    }\n    ts.deduplicate = deduplicate;\n    function sum(array, prop) {\n        var result = 0;\n        for (var i = 0; i < array.length; i++) {\n            result += array[i][prop];\n        }\n        return result;\n    }\n    ts.sum = sum;\n    /**\n     * Returns the last element of an array if non-empty, undefined otherwise.\n     */\n    function lastOrUndefined(array) {\n        if (array.length === 0) {\n            return undefined;\n        }\n        return array[array.length - 1];\n    }\n    ts.lastOrUndefined = lastOrUndefined;\n    function binarySearch(array, value) {\n        var low = 0;\n        var high = array.length - 1;\n        while (low <= high) {\n            var middle = low + ((high - low) >> 1);\n            var midValue = array[middle];\n            if (midValue === value) {\n                return middle;\n            }\n            else if (midValue > value) {\n                high = middle - 1;\n            }\n            else {\n                low = middle + 1;\n            }\n        }\n        return ~low;\n    }\n    ts.binarySearch = binarySearch;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    function hasProperty(map, key) {\n        return hasOwnProperty.call(map, key);\n    }\n    ts.hasProperty = hasProperty;\n    function getProperty(map, key) {\n        return hasOwnProperty.call(map, key) ? map[key] : undefined;\n    }\n    ts.getProperty = getProperty;\n    function isEmpty(map) {\n        for (var id in map) {\n            if (hasProperty(map, id)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    ts.isEmpty = isEmpty;\n    function clone(object) {\n        var result = {};\n        for (var id in object) {\n            result[id] = object[id];\n        }\n        return result;\n    }\n    ts.clone = clone;\n    function forEachValue(map, callback) {\n        var result;\n        for (var id in map) {\n            if (result = callback(map[id]))\n                break;\n        }\n        return result;\n    }\n    ts.forEachValue = forEachValue;\n    function forEachKey(map, callback) {\n        var result;\n        for (var id in map) {\n            if (result = callback(id))\n                break;\n        }\n        return result;\n    }\n    ts.forEachKey = forEachKey;\n    function lookUp(map, key) {\n        return hasProperty(map, key) ? map[key] : undefined;\n    }\n    ts.lookUp = lookUp;\n    function mapToArray(map) {\n        var result = [];\n        for (var id in map) {\n            result.push(map[id]);\n        }\n        return result;\n    }\n    ts.mapToArray = mapToArray;\n    /**\n     * Creates a map from the elements of an array.\n     *\n     * @param array the array of input elements.\n     * @param makeKey a function that produces a key for a given element.\n     *\n     * This function makes no effort to avoid collisions; if any two elements produce\n     * the same key with the given 'makeKey' function, then the element with the higher\n     * index in the array will be the one associated with the produced key.\n     */\n    function arrayToMap(array, makeKey) {\n        var result = {};\n        forEach(array, function (value) {\n            result[makeKey(value)] = value;\n        });\n        return result;\n    }\n    ts.arrayToMap = arrayToMap;\n    function formatStringFromArgs(text, args, baseIndex) {\n        baseIndex = baseIndex || 0;\n        return text.replace(/{(\\d+)}/g, function (match, index) { return args[+index + baseIndex]; });\n    }\n    ts.localizedDiagnosticMessages = undefined;\n    function getLocaleSpecificMessage(message) {\n        return ts.localizedDiagnosticMessages && ts.localizedDiagnosticMessages[message] ? ts.localizedDiagnosticMessages[message] : message;\n    }\n    ts.getLocaleSpecificMessage = getLocaleSpecificMessage;\n    function createFileDiagnostic(file, start, length, message) {\n        Debug.assert(start >= 0, \"start must be non-negative, is \" + start);\n        Debug.assert(length >= 0, \"length must be non-negative, is \" + length);\n        var text = getLocaleSpecificMessage(message.key);\n        if (arguments.length > 4) {\n            text = formatStringFromArgs(text, arguments, 4);\n        }\n        return {\n            file: file,\n            start: start,\n            length: length,\n            messageText: text,\n            category: message.category,\n            code: message.code,\n            isEarly: message.isEarly\n        };\n    }\n    ts.createFileDiagnostic = createFileDiagnostic;\n    function createCompilerDiagnostic(message) {\n        var text = getLocaleSpecificMessage(message.key);\n        if (arguments.length > 1) {\n            text = formatStringFromArgs(text, arguments, 1);\n        }\n        return {\n            file: undefined,\n            start: undefined,\n            length: undefined,\n            messageText: text,\n            category: message.category,\n            code: message.code,\n            isEarly: message.isEarly\n        };\n    }\n    ts.createCompilerDiagnostic = createCompilerDiagnostic;\n    function chainDiagnosticMessages(details, message) {\n        var text = getLocaleSpecificMessage(message.key);\n        if (arguments.length > 2) {\n            text = formatStringFromArgs(text, arguments, 2);\n        }\n        return {\n            messageText: text,\n            category: message.category,\n            code: message.code,\n            next: details\n        };\n    }\n    ts.chainDiagnosticMessages = chainDiagnosticMessages;\n    function concatenateDiagnosticMessageChains(headChain, tailChain) {\n        Debug.assert(!headChain.next);\n        headChain.next = tailChain;\n        return headChain;\n    }\n    ts.concatenateDiagnosticMessageChains = concatenateDiagnosticMessageChains;\n    function flattenDiagnosticChain(file, start, length, diagnosticChain, newLine) {\n        Debug.assert(start >= 0, \"start must be non-negative, is \" + start);\n        Debug.assert(length >= 0, \"length must be non-negative, is \" + length);\n        var code = diagnosticChain.code;\n        var category = diagnosticChain.category;\n        var messageText = \"\";\n        var indent = 0;\n        while (diagnosticChain) {\n            if (indent) {\n                messageText += newLine;\n                for (var i = 0; i < indent; i++) {\n                    messageText += \"  \";\n                }\n            }\n            messageText += diagnosticChain.messageText;\n            indent++;\n            diagnosticChain = diagnosticChain.next;\n        }\n        return {\n            file: file,\n            start: start,\n            length: length,\n            code: code,\n            category: category,\n            messageText: messageText\n        };\n    }\n    ts.flattenDiagnosticChain = flattenDiagnosticChain;\n    function compareValues(a, b) {\n        if (a === b)\n            return 0 /* EqualTo */;\n        if (a === undefined)\n            return -1 /* LessThan */;\n        if (b === undefined)\n            return 1 /* GreaterThan */;\n        return a < b ? -1 /* LessThan */ : 1 /* GreaterThan */;\n    }\n    ts.compareValues = compareValues;\n    function getDiagnosticFilename(diagnostic) {\n        return diagnostic.file ? diagnostic.file.filename : undefined;\n    }\n    function compareDiagnostics(d1, d2) {\n        return compareValues(getDiagnosticFilename(d1), getDiagnosticFilename(d2)) || compareValues(d1.start, d2.start) || compareValues(d1.length, d2.length) || compareValues(d1.code, d2.code) || compareValues(d1.messageText, d2.messageText) || 0;\n    }\n    ts.compareDiagnostics = compareDiagnostics;\n    function deduplicateSortedDiagnostics(diagnostics) {\n        if (diagnostics.length < 2) {\n            return diagnostics;\n        }\n        var newDiagnostics = [diagnostics[0]];\n        var previousDiagnostic = diagnostics[0];\n        for (var i = 1; i < diagnostics.length; i++) {\n            var currentDiagnostic = diagnostics[i];\n            var isDupe = compareDiagnostics(currentDiagnostic, previousDiagnostic) === 0 /* EqualTo */;\n            if (!isDupe) {\n                newDiagnostics.push(currentDiagnostic);\n                previousDiagnostic = currentDiagnostic;\n            }\n        }\n        return newDiagnostics;\n    }\n    ts.deduplicateSortedDiagnostics = deduplicateSortedDiagnostics;\n    function normalizeSlashes(path) {\n        return path.replace(/\\\\/g, \"/\");\n    }\n    ts.normalizeSlashes = normalizeSlashes;\n    // Returns length of path root (i.e. length of \"/\", \"x:/\", \"//server/share/\")\n    function getRootLength(path) {\n        if (path.charCodeAt(0) === 47 /* slash */) {\n            if (path.charCodeAt(1) !== 47 /* slash */)\n                return 1;\n            var p1 = path.indexOf(\"/\", 2);\n            if (p1 < 0)\n                return 2;\n            var p2 = path.indexOf(\"/\", p1 + 1);\n            if (p2 < 0)\n                return p1 + 1;\n            return p2 + 1;\n        }\n        if (path.charCodeAt(1) === 58 /* colon */) {\n            if (path.charCodeAt(2) === 47 /* slash */)\n                return 3;\n            return 2;\n        }\n        return 0;\n    }\n    ts.getRootLength = getRootLength;\n    ts.directorySeparator = \"/\";\n    function getNormalizedParts(normalizedSlashedPath, rootLength) {\n        var parts = normalizedSlashedPath.substr(rootLength).split(ts.directorySeparator);\n        var normalized = [];\n        for (var i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            if (part !== \".\") {\n                if (part === \"..\" && normalized.length > 0 && normalized[normalized.length - 1] !== \"..\") {\n                    normalized.pop();\n                }\n                else {\n                    normalized.push(part);\n                }\n            }\n        }\n        return normalized;\n    }\n    function normalizePath(path) {\n        var path = normalizeSlashes(path);\n        var rootLength = getRootLength(path);\n        var normalized = getNormalizedParts(path, rootLength);\n        return path.substr(0, rootLength) + normalized.join(ts.directorySeparator);\n    }\n    ts.normalizePath = normalizePath;\n    function getDirectoryPath(path) {\n        return path.substr(0, Math.max(getRootLength(path), path.lastIndexOf(ts.directorySeparator)));\n    }\n    ts.getDirectoryPath = getDirectoryPath;\n    function isUrl(path) {\n        return path && !isRootedDiskPath(path) && path.indexOf(\"://\") !== -1;\n    }\n    ts.isUrl = isUrl;\n    function isRootedDiskPath(path) {\n        return getRootLength(path) !== 0;\n    }\n    ts.isRootedDiskPath = isRootedDiskPath;\n    function normalizedPathComponents(path, rootLength) {\n        var normalizedParts = getNormalizedParts(path, rootLength);\n        return [path.substr(0, rootLength)].concat(normalizedParts);\n    }\n    function getNormalizedPathComponents(path, currentDirectory) {\n        var path = normalizeSlashes(path);\n        var rootLength = getRootLength(path);\n        if (rootLength == 0) {\n            // If the path is not rooted it is relative to current directory\n            path = combinePaths(normalizeSlashes(currentDirectory), path);\n            rootLength = getRootLength(path);\n        }\n        return normalizedPathComponents(path, rootLength);\n    }\n    ts.getNormalizedPathComponents = getNormalizedPathComponents;\n    function getNormalizedAbsolutePath(filename, currentDirectory) {\n        return getNormalizedPathFromPathComponents(getNormalizedPathComponents(filename, currentDirectory));\n    }\n    ts.getNormalizedAbsolutePath = getNormalizedAbsolutePath;\n    function getNormalizedPathFromPathComponents(pathComponents) {\n        if (pathComponents && pathComponents.length) {\n            return pathComponents[0] + pathComponents.slice(1).join(ts.directorySeparator);\n        }\n    }\n    ts.getNormalizedPathFromPathComponents = getNormalizedPathFromPathComponents;\n    function getNormalizedPathComponentsOfUrl(url) {\n        // Get root length of http://www.website.com/folder1/foler2/\n        // In this example the root is:  http://www.website.com/ \n        // normalized path components should be [\"http://www.website.com/\", \"folder1\", \"folder2\"]\n        var urlLength = url.length;\n        // Initial root length is http:// part\n        var rootLength = url.indexOf(\"://\") + \"://\".length;\n        while (rootLength < urlLength) {\n            // Consume all immediate slashes in the protocol \n            // eg.initial rootlength is just file:// but it needs to consume another \"/\" in file:///\n            if (url.charCodeAt(rootLength) === 47 /* slash */) {\n                rootLength++;\n            }\n            else {\n                break;\n            }\n        }\n        // there are no parts after http:// just return current string as the pathComponent\n        if (rootLength === urlLength) {\n            return [url];\n        }\n        // Find the index of \"/\" after website.com so the root can be http://www.website.com/ (from existing http://)\n        var indexOfNextSlash = url.indexOf(ts.directorySeparator, rootLength);\n        if (indexOfNextSlash !== -1) {\n            // Found the \"/\" after the website.com so the root is length of http://www.website.com/ \n            // and get components afetr the root normally like any other folder components\n            rootLength = indexOfNextSlash + 1;\n            return normalizedPathComponents(url, rootLength);\n        }\n        else {\n            // Can't find the host assume the rest of the string as component \n            // but make sure we append \"/\"  to it as root is not joined using \"/\"\n            // eg. if url passed in was http://website.com we want to use root as [http://website.com/] \n            // so that other path manipulations will be correct and it can be merged with relative paths correctly\n            return [url + ts.directorySeparator];\n        }\n    }\n    function getNormalizedPathOrUrlComponents(pathOrUrl, currentDirectory) {\n        if (isUrl(pathOrUrl)) {\n            return getNormalizedPathComponentsOfUrl(pathOrUrl);\n        }\n        else {\n            return getNormalizedPathComponents(pathOrUrl, currentDirectory);\n        }\n    }\n    function getRelativePathToDirectoryOrUrl(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, getCanonicalFileName, isAbsolutePathAnUrl) {\n        var pathComponents = getNormalizedPathOrUrlComponents(relativeOrAbsolutePath, currentDirectory);\n        var directoryComponents = getNormalizedPathOrUrlComponents(directoryPathOrUrl, currentDirectory);\n        if (directoryComponents.length > 1 && directoryComponents[directoryComponents.length - 1] === \"\") {\n            // If the directory path given was of type test/cases/ then we really need components of directory to be only till its name\n            // that is  [\"test\", \"cases\", \"\"] needs to be actually [\"test\", \"cases\"]\n            directoryComponents.length--;\n        }\n        for (var joinStartIndex = 0; joinStartIndex < pathComponents.length && joinStartIndex < directoryComponents.length; joinStartIndex++) {\n            if (getCanonicalFileName(directoryComponents[joinStartIndex]) !== getCanonicalFileName(pathComponents[joinStartIndex])) {\n                break;\n            }\n        }\n        // Get the relative path\n        if (joinStartIndex) {\n            var relativePath = \"\";\n            var relativePathComponents = pathComponents.slice(joinStartIndex, pathComponents.length);\n            for (; joinStartIndex < directoryComponents.length; joinStartIndex++) {\n                if (directoryComponents[joinStartIndex] !== \"\") {\n                    relativePath = relativePath + \"..\" + ts.directorySeparator;\n                }\n            }\n            return relativePath + relativePathComponents.join(ts.directorySeparator);\n        }\n        // Cant find the relative path, get the absolute path\n        var absolutePath = getNormalizedPathFromPathComponents(pathComponents);\n        if (isAbsolutePathAnUrl && isRootedDiskPath(absolutePath)) {\n            absolutePath = \"file:///\" + absolutePath;\n        }\n        return absolutePath;\n    }\n    ts.getRelativePathToDirectoryOrUrl = getRelativePathToDirectoryOrUrl;\n    function getBaseFilename(path) {\n        var i = path.lastIndexOf(ts.directorySeparator);\n        return i < 0 ? path : path.substring(i + 1);\n    }\n    ts.getBaseFilename = getBaseFilename;\n    function combinePaths(path1, path2) {\n        if (!(path1 && path1.length))\n            return path2;\n        if (!(path2 && path2.length))\n            return path1;\n        if (path2.charAt(0) === ts.directorySeparator)\n            return path2;\n        if (path1.charAt(path1.length - 1) === ts.directorySeparator)\n            return path1 + path2;\n        return path1 + ts.directorySeparator + path2;\n    }\n    ts.combinePaths = combinePaths;\n    function fileExtensionIs(path, extension) {\n        var pathLen = path.length;\n        var extLen = extension.length;\n        return pathLen > extLen && path.substr(pathLen - extLen, extLen) === extension;\n    }\n    ts.fileExtensionIs = fileExtensionIs;\n    var supportedExtensions = [\".d.ts\", \".ts\", \".js\"];\n    function removeFileExtension(path) {\n        for (var i = 0; i < supportedExtensions.length; i++) {\n            var ext = supportedExtensions[i];\n            if (fileExtensionIs(path, ext)) {\n                return path.substr(0, path.length - ext.length);\n            }\n        }\n        return path;\n    }\n    ts.removeFileExtension = removeFileExtension;\n    var escapedCharsRegExp = /[\\t\\v\\f\\b\\0\\r\\n\\\"\\\\\\u2028\\u2029\\u0085]/g;\n    var escapedCharsMap = {\n        \"\\t\": \"\\\\t\",\n        \"\\v\": \"\\\\v\",\n        \"\\f\": \"\\\\f\",\n        \"\\b\": \"\\\\b\",\n        \"\\0\": \"\\\\0\",\n        \"\\r\": \"\\\\r\",\n        \"\\n\": \"\\\\n\",\n        \"\\\"\": \"\\\\\\\"\",\n        \"\\u2028\": \"\\\\u2028\",\n        \"\\u2029\": \"\\\\u2029\",\n        \"\\u0085\": \"\\\\u0085\" // nextLine\n    };\n    /** NOTE: This *does not* support the full escape characters, it only supports the subset that can be used in file names\n      * or string literals. If the information encoded in the map changes, this needs to be revisited. */\n    function escapeString(s) {\n        return escapedCharsRegExp.test(s) ? s.replace(escapedCharsRegExp, function (c) {\n            return escapedCharsMap[c] || c;\n        }) : s;\n    }\n    ts.escapeString = escapeString;\n    function Symbol(flags, name) {\n        this.flags = flags;\n        this.name = name;\n        this.declarations = undefined;\n    }\n    function Type(checker, flags) {\n        this.flags = flags;\n    }\n    function Signature(checker) {\n    }\n    ts.objectAllocator = {\n        getNodeConstructor: function (kind) {\n            function Node() {\n            }\n            Node.prototype = {\n                kind: kind,\n                pos: 0,\n                end: 0,\n                flags: 0,\n                parent: undefined,\n            };\n            return Node;\n        },\n        getSymbolConstructor: function () { return Symbol; },\n        getTypeConstructor: function () { return Type; },\n        getSignatureConstructor: function () { return Signature; }\n    };\n    var Debug;\n    (function (Debug) {\n        var currentAssertionLevel = 0 /* None */;\n        function shouldAssert(level) {\n            return currentAssertionLevel >= level;\n        }\n        Debug.shouldAssert = shouldAssert;\n        function assert(expression, message, verboseDebugInfo) {\n            if (!expression) {\n                var verboseDebugString = \"\";\n                if (verboseDebugInfo) {\n                    verboseDebugString = \"\\r\\nVerbose Debug Information: \" + verboseDebugInfo();\n                }\n                throw new Error(\"Debug Failure. False expression: \" + (message || \"\") + verboseDebugString);\n            }\n        }\n        Debug.assert = assert;\n        function fail(message) {\n            Debug.assert(false, message);\n        }\n        Debug.fail = fail;\n    })(Debug = ts.Debug || (ts.Debug = {}));\n})(ts || (ts = {}));\n/// <reference path=\"core.ts\"/>\nvar ts;\n(function (ts) {\n    // Return code used by getEmitOutput function to indicate status of the function\n    (function (EmitReturnStatus) {\n        EmitReturnStatus[EmitReturnStatus[\"Succeeded\"] = 0] = \"Succeeded\";\n        EmitReturnStatus[EmitReturnStatus[\"AllOutputGenerationSkipped\"] = 1] = \"AllOutputGenerationSkipped\";\n        EmitReturnStatus[EmitReturnStatus[\"JSGeneratedWithSemanticErrors\"] = 2] = \"JSGeneratedWithSemanticErrors\";\n        EmitReturnStatus[EmitReturnStatus[\"DeclarationGenerationSkipped\"] = 3] = \"DeclarationGenerationSkipped\";\n        EmitReturnStatus[EmitReturnStatus[\"EmitErrorsEncountered\"] = 4] = \"EmitErrorsEncountered\";\n        EmitReturnStatus[EmitReturnStatus[\"CompilerOptionsErrors\"] = 5] = \"CompilerOptionsErrors\";\n    })(ts.EmitReturnStatus || (ts.EmitReturnStatus = {}));\n    var EmitReturnStatus = ts.EmitReturnStatus;\n    (function (DiagnosticCategory) {\n        DiagnosticCategory[DiagnosticCategory[\"Warning\"] = 0] = \"Warning\";\n        DiagnosticCategory[DiagnosticCategory[\"Error\"] = 1] = \"Error\";\n        DiagnosticCategory[DiagnosticCategory[\"Message\"] = 2] = \"Message\";\n    })(ts.DiagnosticCategory || (ts.DiagnosticCategory = {}));\n    var DiagnosticCategory = ts.DiagnosticCategory;\n})(ts || (ts = {}));\n/// <reference path=\"typescript/src/compiler/types.ts\"/>\n/// <reference path=\"../typings/node/node.d.ts\"/>\nvar tsc;\n(function (tsc) {\n    (function (SourceType) {\n        SourceType[SourceType[\"File\"] = 0] = \"File\";\n        SourceType[SourceType[\"String\"] = 1] = \"String\";\n    })(tsc.SourceType || (tsc.SourceType = {}));\n    var SourceType = tsc.SourceType;\n    var StringSource = (function () {\n        function StringSource(contents, filename) {\n            if (filename === void 0) { filename = StringSource._nextFilename(); }\n            this.contents = contents;\n            this.filename = filename;\n            this.type = 1 /* String */;\n        }\n        StringSource._nextFilename = function () {\n            return \"input_string\" + (++StringSource._counter) + '.ts';\n        };\n        StringSource.prototype.resetCounter = function () {\n            StringSource._counter = 0;\n        };\n        StringSource._counter = 0;\n        return StringSource;\n    })();\n    tsc.StringSource = StringSource;\n    var FileSource = (function () {\n        function FileSource(filename) {\n            this.filename = filename;\n            this.type = 0 /* File */;\n        }\n        return FileSource;\n    })();\n    tsc.FileSource = FileSource;\n})(tsc || (tsc = {}));\nvar ts;\n(function (ts) {\n    ts.sys = (function () {\n        function getWScriptSystem() {\n            var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n            var fileStream = new ActiveXObject(\"ADODB.Stream\");\n            fileStream.Type = 2;\n            var binaryStream = new ActiveXObject(\"ADODB.Stream\");\n            binaryStream.Type = 1;\n            var args = [];\n            for (var i = 0; i < WScript.Arguments.length; i++) {\n                args[i] = WScript.Arguments.Item(i);\n            }\n            function readFile(fileName, encoding) {\n                if (!fso.FileExists(fileName)) {\n                    return undefined;\n                }\n                fileStream.Open();\n                try {\n                    if (encoding) {\n                        fileStream.Charset = encoding;\n                        fileStream.LoadFromFile(fileName);\n                    }\n                    else {\n                        // Load file and read the first two bytes into a string with no interpretation\n                        fileStream.Charset = \"x-ansi\";\n                        fileStream.LoadFromFile(fileName);\n                        var bom = fileStream.ReadText(2) || \"\";\n                        // Position must be at 0 before encoding can be changed\n                        fileStream.Position = 0;\n                        // [0xFF,0xFE] and [0xFE,0xFF] mean utf-16 (little or big endian), otherwise default to utf-8\n                        fileStream.Charset = bom.length >= 2 && (bom.charCodeAt(0) === 0xFF && bom.charCodeAt(1) === 0xFE || bom.charCodeAt(0) === 0xFE && bom.charCodeAt(1) === 0xFF) ? \"unicode\" : \"utf-8\";\n                    }\n                    // ReadText method always strips byte order mark from resulting string\n                    return fileStream.ReadText();\n                }\n                catch (e) {\n                    throw e;\n                }\n                finally {\n                    fileStream.Close();\n                }\n            }\n            function writeFile(fileName, data, writeByteOrderMark) {\n                fileStream.Open();\n                binaryStream.Open();\n                try {\n                    // Write characters in UTF-8 encoding\n                    fileStream.Charset = \"utf-8\";\n                    fileStream.WriteText(data);\n                    // If we don't want the BOM, then skip it by setting the starting location to 3 (size of BOM).\n                    // If not, start from position 0, as the BOM will be added automatically when charset==utf8.\n                    if (writeByteOrderMark) {\n                        fileStream.Position = 0;\n                    }\n                    else {\n                        fileStream.Position = 3;\n                    }\n                    fileStream.CopyTo(binaryStream);\n                    binaryStream.SaveToFile(fileName, 2);\n                }\n                finally {\n                    binaryStream.Close();\n                    fileStream.Close();\n                }\n            }\n            return {\n                args: args,\n                newLine: \"\\r\\n\",\n                useCaseSensitiveFileNames: false,\n                write: function (s) {\n                    WScript.StdOut.Write(s);\n                },\n                readFile: readFile,\n                writeFile: writeFile,\n                resolvePath: function (path) {\n                    return fso.GetAbsolutePathName(path);\n                },\n                fileExists: function (path) {\n                    return fso.FileExists(path);\n                },\n                directoryExists: function (path) {\n                    return fso.FolderExists(path);\n                },\n                createDirectory: function (directoryName) {\n                    if (!this.directoryExists(directoryName)) {\n                        fso.CreateFolder(directoryName);\n                    }\n                },\n                getExecutingFilePath: function () {\n                    return WScript.ScriptFullName;\n                },\n                getCurrentDirectory: function () {\n                    return new ActiveXObject(\"WScript.Shell\").CurrentDirectory;\n                },\n                exit: function (exitCode) {\n                    try {\n                        WScript.Quit(exitCode);\n                    }\n                    catch (e) {\n                    }\n                }\n            };\n        }\n        function getNodeSystem() {\n            var _fs = require(\"fs\");\n            var _path = require(\"path\");\n            var _os = require('os');\n            var platform = _os.platform();\n            // win32\\win64 are case insensitive platforms, MacOS (darwin) by default is also case insensitive\n            var useCaseSensitiveFileNames = platform !== \"win32\" && platform !== \"win64\" && platform !== \"darwin\";\n            function readFile(fileName, encoding) {\n                if (!_fs.existsSync(fileName)) {\n                    return undefined;\n                }\n                var buffer = _fs.readFileSync(fileName);\n                var len = buffer.length;\n                if (len >= 2 && buffer[0] === 0xFE && buffer[1] === 0xFF) {\n                    // Big endian UTF-16 byte order mark detected. Since big endian is not supported by node.js,\n                    // flip all byte pairs and treat as little endian.\n                    len &= ~1;\n                    for (var i = 0; i < len; i += 2) {\n                        var temp = buffer[i];\n                        buffer[i] = buffer[i + 1];\n                        buffer[i + 1] = temp;\n                    }\n                    return buffer.toString(\"utf16le\", 2);\n                }\n                if (len >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {\n                    // Little endian UTF-16 byte order mark detected\n                    return buffer.toString(\"utf16le\", 2);\n                }\n                if (len >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n                    // UTF-8 byte order mark detected\n                    return buffer.toString(\"utf8\", 3);\n                }\n                // Default is UTF-8 with no byte order mark\n                return buffer.toString(\"utf8\");\n            }\n            function writeFile(fileName, data, writeByteOrderMark) {\n                // If a BOM is required, emit one\n                if (writeByteOrderMark) {\n                    data = '\\uFEFF' + data;\n                }\n                _fs.writeFileSync(fileName, data, \"utf8\");\n            }\n            return {\n                args: process.argv.slice(2),\n                newLine: _os.EOL,\n                useCaseSensitiveFileNames: useCaseSensitiveFileNames,\n                write: function (s) {\n                    // 1 is a standard descriptor for stdout\n                    _fs.writeSync(1, s);\n                },\n                readFile: readFile,\n                writeFile: writeFile,\n                watchFile: function (fileName, callback) {\n                    // watchFile polls a file every 250ms, picking up file notifications.\n                    _fs.watchFile(fileName, { persistent: true, interval: 250 }, fileChanged);\n                    return {\n                        close: function () {\n                            _fs.unwatchFile(fileName, fileChanged);\n                        }\n                    };\n                    function fileChanged(curr, prev) {\n                        if (+curr.mtime <= +prev.mtime) {\n                            return;\n                        }\n                        callback(fileName);\n                    }\n                    ;\n                },\n                resolvePath: function (path) {\n                    return _path.resolve(path);\n                },\n                fileExists: function (path) {\n                    return _fs.existsSync(path);\n                },\n                directoryExists: function (path) {\n                    return _fs.existsSync(path) && _fs.statSync(path).isDirectory();\n                },\n                createDirectory: function (directoryName) {\n                    if (!this.directoryExists(directoryName)) {\n                        _fs.mkdirSync(directoryName);\n                    }\n                },\n                getExecutingFilePath: function () {\n                    return __filename;\n                },\n                getCurrentDirectory: function () {\n                    return process.cwd();\n                },\n                getMemoryUsage: function () {\n                    if (global.gc) {\n                        global.gc();\n                    }\n                    return process.memoryUsage().heapUsed;\n                },\n                exit: function (exitCode) {\n                    process.exit(exitCode);\n                }\n            };\n        }\n        if (typeof WScript !== \"undefined\" && typeof ActiveXObject === \"function\") {\n            return getWScriptSystem();\n        }\n        else if (typeof module !== \"undefined\" && module.exports) {\n            return getNodeSystem();\n        }\n        else {\n            return undefined; // Unsupported host\n        }\n    })();\n})(ts || (ts = {}));\n// <auto-generated />\n/// <reference path=\"types.ts\" />\nvar ts;\n(function (ts) {\n    ts.Diagnostics = {\n        Unterminated_string_literal: { code: 1002, category: 1 /* Error */, key: \"Unterminated string literal.\" },\n        Identifier_expected: { code: 1003, category: 1 /* Error */, key: \"Identifier expected.\" },\n        _0_expected: { code: 1005, category: 1 /* Error */, key: \"'{0}' expected.\" },\n        A_file_cannot_have_a_reference_to_itself: { code: 1006, category: 1 /* Error */, key: \"A file cannot have a reference to itself.\" },\n        Trailing_comma_not_allowed: { code: 1009, category: 1 /* Error */, key: \"Trailing comma not allowed.\" },\n        Asterisk_Slash_expected: { code: 1010, category: 1 /* Error */, key: \"'*/' expected.\" },\n        Unexpected_token: { code: 1012, category: 1 /* Error */, key: \"Unexpected token.\" },\n        Catch_clause_parameter_cannot_have_a_type_annotation: { code: 1013, category: 1 /* Error */, key: \"Catch clause parameter cannot have a type annotation.\" },\n        A_rest_parameter_must_be_last_in_a_parameter_list: { code: 1014, category: 1 /* Error */, key: \"A rest parameter must be last in a parameter list.\" },\n        Parameter_cannot_have_question_mark_and_initializer: { code: 1015, category: 1 /* Error */, key: \"Parameter cannot have question mark and initializer.\" },\n        A_required_parameter_cannot_follow_an_optional_parameter: { code: 1016, category: 1 /* Error */, key: \"A required parameter cannot follow an optional parameter.\" },\n        An_index_signature_cannot_have_a_rest_parameter: { code: 1017, category: 1 /* Error */, key: \"An index signature cannot have a rest parameter.\" },\n        An_index_signature_parameter_cannot_have_an_accessibility_modifier: { code: 1018, category: 1 /* Error */, key: \"An index signature parameter cannot have an accessibility modifier.\" },\n        An_index_signature_parameter_cannot_have_a_question_mark: { code: 1019, category: 1 /* Error */, key: \"An index signature parameter cannot have a question mark.\" },\n        An_index_signature_parameter_cannot_have_an_initializer: { code: 1020, category: 1 /* Error */, key: \"An index signature parameter cannot have an initializer.\" },\n        An_index_signature_must_have_a_type_annotation: { code: 1021, category: 1 /* Error */, key: \"An index signature must have a type annotation.\" },\n        An_index_signature_parameter_must_have_a_type_annotation: { code: 1022, category: 1 /* Error */, key: \"An index signature parameter must have a type annotation.\" },\n        An_index_signature_parameter_type_must_be_string_or_number: { code: 1023, category: 1 /* Error */, key: \"An index signature parameter type must be 'string' or 'number'.\" },\n        A_class_or_interface_declaration_can_only_have_one_extends_clause: { code: 1024, category: 1 /* Error */, key: \"A class or interface declaration can only have one 'extends' clause.\" },\n        An_extends_clause_must_precede_an_implements_clause: { code: 1025, category: 1 /* Error */, key: \"An 'extends' clause must precede an 'implements' clause.\" },\n        A_class_can_only_extend_a_single_class: { code: 1026, category: 1 /* Error */, key: \"A class can only extend a single class.\" },\n        A_class_declaration_can_only_have_one_implements_clause: { code: 1027, category: 1 /* Error */, key: \"A class declaration can only have one 'implements' clause.\" },\n        Accessibility_modifier_already_seen: { code: 1028, category: 1 /* Error */, key: \"Accessibility modifier already seen.\" },\n        _0_modifier_must_precede_1_modifier: { code: 1029, category: 1 /* Error */, key: \"'{0}' modifier must precede '{1}' modifier.\" },\n        _0_modifier_already_seen: { code: 1030, category: 1 /* Error */, key: \"'{0}' modifier already seen.\" },\n        _0_modifier_cannot_appear_on_a_class_element: { code: 1031, category: 1 /* Error */, key: \"'{0}' modifier cannot appear on a class element.\" },\n        An_interface_declaration_cannot_have_an_implements_clause: { code: 1032, category: 1 /* Error */, key: \"An interface declaration cannot have an 'implements' clause.\" },\n        super_must_be_followed_by_an_argument_list_or_member_access: { code: 1034, category: 1 /* Error */, key: \"'super' must be followed by an argument list or member access.\" },\n        Only_ambient_modules_can_use_quoted_names: { code: 1035, category: 1 /* Error */, key: \"Only ambient modules can use quoted names.\" },\n        Statements_are_not_allowed_in_ambient_contexts: { code: 1036, category: 1 /* Error */, key: \"Statements are not allowed in ambient contexts.\" },\n        A_function_implementation_cannot_be_declared_in_an_ambient_context: { code: 1037, category: 1 /* Error */, key: \"A function implementation cannot be declared in an ambient context.\" },\n        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: { code: 1038, category: 1 /* Error */, key: \"A 'declare' modifier cannot be used in an already ambient context.\" },\n        Initializers_are_not_allowed_in_ambient_contexts: { code: 1039, category: 1 /* Error */, key: \"Initializers are not allowed in ambient contexts.\" },\n        _0_modifier_cannot_appear_on_a_module_element: { code: 1044, category: 1 /* Error */, key: \"'{0}' modifier cannot appear on a module element.\" },\n        A_declare_modifier_cannot_be_used_with_an_interface_declaration: { code: 1045, category: 1 /* Error */, key: \"A 'declare' modifier cannot be used with an interface declaration.\" },\n        A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file: { code: 1046, category: 1 /* Error */, key: \"A 'declare' modifier is required for a top level declaration in a .d.ts file.\" },\n        A_rest_parameter_cannot_be_optional: { code: 1047, category: 1 /* Error */, key: \"A rest parameter cannot be optional.\" },\n        A_rest_parameter_cannot_have_an_initializer: { code: 1048, category: 1 /* Error */, key: \"A rest parameter cannot have an initializer.\" },\n        A_set_accessor_must_have_exactly_one_parameter: { code: 1049, category: 1 /* Error */, key: \"A 'set' accessor must have exactly one parameter.\" },\n        A_set_accessor_cannot_have_an_optional_parameter: { code: 1051, category: 1 /* Error */, key: \"A 'set' accessor cannot have an optional parameter.\" },\n        A_set_accessor_parameter_cannot_have_an_initializer: { code: 1052, category: 1 /* Error */, key: \"A 'set' accessor parameter cannot have an initializer.\" },\n        A_set_accessor_cannot_have_rest_parameter: { code: 1053, category: 1 /* Error */, key: \"A 'set' accessor cannot have rest parameter.\" },\n        A_get_accessor_cannot_have_parameters: { code: 1054, category: 1 /* Error */, key: \"A 'get' accessor cannot have parameters.\" },\n        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: { code: 1056, category: 1 /* Error */, key: \"Accessors are only available when targeting ECMAScript 5 and higher.\" },\n        Enum_member_must_have_initializer: { code: 1061, category: 1 /* Error */, key: \"Enum member must have initializer.\" },\n        An_export_assignment_cannot_be_used_in_an_internal_module: { code: 1063, category: 1 /* Error */, key: \"An export assignment cannot be used in an internal module.\" },\n        Ambient_enum_elements_can_only_have_integer_literal_initializers: { code: 1066, category: 1 /* Error */, key: \"Ambient enum elements can only have integer literal initializers.\" },\n        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: { code: 1068, category: 1 /* Error */, key: \"Unexpected token. A constructor, method, accessor, or property was expected.\" },\n        A_declare_modifier_cannot_be_used_with_an_import_declaration: { code: 1079, category: 1 /* Error */, key: \"A 'declare' modifier cannot be used with an import declaration.\" },\n        Invalid_reference_directive_syntax: { code: 1084, category: 1 /* Error */, key: \"Invalid 'reference' directive syntax.\" },\n        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher: { code: 1085, category: 1 /* Error */, key: \"Octal literals are not available when targeting ECMAScript 5 and higher.\" },\n        An_accessor_cannot_be_declared_in_an_ambient_context: { code: 1086, category: 1 /* Error */, key: \"An accessor cannot be declared in an ambient context.\" },\n        _0_modifier_cannot_appear_on_a_constructor_declaration: { code: 1089, category: 1 /* Error */, key: \"'{0}' modifier cannot appear on a constructor declaration.\" },\n        _0_modifier_cannot_appear_on_a_parameter: { code: 1090, category: 1 /* Error */, key: \"'{0}' modifier cannot appear on a parameter.\" },\n        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: { code: 1091, category: 1 /* Error */, key: \"Only a single variable declaration is allowed in a 'for...in' statement.\" },\n        Type_parameters_cannot_appear_on_a_constructor_declaration: { code: 1092, category: 1 /* Error */, key: \"Type parameters cannot appear on a constructor declaration.\" },\n        Type_annotation_cannot_appear_on_a_constructor_declaration: { code: 1093, category: 1 /* Error */, key: \"Type annotation cannot appear on a constructor declaration.\" },\n        An_accessor_cannot_have_type_parameters: { code: 1094, category: 1 /* Error */, key: \"An accessor cannot have type parameters.\" },\n        A_set_accessor_cannot_have_a_return_type_annotation: { code: 1095, category: 1 /* Error */, key: \"A 'set' accessor cannot have a return type annotation.\" },\n        An_index_signature_must_have_exactly_one_parameter: { code: 1096, category: 1 /* Error */, key: \"An index signature must have exactly one parameter.\" },\n        _0_list_cannot_be_empty: { code: 1097, category: 1 /* Error */, key: \"'{0}' list cannot be empty.\" },\n        Type_parameter_list_cannot_be_empty: { code: 1098, category: 1 /* Error */, key: \"Type parameter list cannot be empty.\" },\n        Type_argument_list_cannot_be_empty: { code: 1099, category: 1 /* Error */, key: \"Type argument list cannot be empty.\" },\n        Invalid_use_of_0_in_strict_mode: { code: 1100, category: 1 /* Error */, key: \"Invalid use of '{0}' in strict mode.\" },\n        with_statements_are_not_allowed_in_strict_mode: { code: 1101, category: 1 /* Error */, key: \"'with' statements are not allowed in strict mode.\" },\n        delete_cannot_be_called_on_an_identifier_in_strict_mode: { code: 1102, category: 1 /* Error */, key: \"'delete' cannot be called on an identifier in strict mode.\" },\n        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: { code: 1104, category: 1 /* Error */, key: \"A 'continue' statement can only be used within an enclosing iteration statement.\" },\n        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: { code: 1105, category: 1 /* Error */, key: \"A 'break' statement can only be used within an enclosing iteration or switch statement.\" },\n        Jump_target_cannot_cross_function_boundary: { code: 1107, category: 1 /* Error */, key: \"Jump target cannot cross function boundary.\" },\n        A_return_statement_can_only_be_used_within_a_function_body: { code: 1108, category: 1 /* Error */, key: \"A 'return' statement can only be used within a function body.\" },\n        Expression_expected: { code: 1109, category: 1 /* Error */, key: \"Expression expected.\" },\n        Type_expected: { code: 1110, category: 1 /* Error */, key: \"Type expected.\" },\n        A_constructor_implementation_cannot_be_declared_in_an_ambient_context: { code: 1111, category: 1 /* Error */, key: \"A constructor implementation cannot be declared in an ambient context.\" },\n        A_class_member_cannot_be_declared_optional: { code: 1112, category: 1 /* Error */, key: \"A class member cannot be declared optional.\" },\n        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: { code: 1113, category: 1 /* Error */, key: \"A 'default' clause cannot appear more than once in a 'switch' statement.\" },\n        Duplicate_label_0: { code: 1114, category: 1 /* Error */, key: \"Duplicate label '{0}'\" },\n        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: { code: 1115, category: 1 /* Error */, key: \"A 'continue' statement can only jump to a label of an enclosing iteration statement.\" },\n        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: { code: 1116, category: 1 /* Error */, key: \"A 'break' statement can only jump to a label of an enclosing statement.\" },\n        An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode: { code: 1117, category: 1 /* Error */, key: \"An object literal cannot have multiple properties with the same name in strict mode.\" },\n        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: { code: 1118, category: 1 /* Error */, key: \"An object literal cannot have multiple get/set accessors with the same name.\" },\n        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: { code: 1119, category: 1 /* Error */, key: \"An object literal cannot have property and accessor with the same name.\" },\n        An_export_assignment_cannot_have_modifiers: { code: 1120, category: 1 /* Error */, key: \"An export assignment cannot have modifiers.\" },\n        Octal_literals_are_not_allowed_in_strict_mode: { code: 1121, category: 1 /* Error */, key: \"Octal literals are not allowed in strict mode.\" },\n        A_tuple_type_element_list_cannot_be_empty: { code: 1122, category: 1 /* Error */, key: \"A tuple type element list cannot be empty.\" },\n        Variable_declaration_list_cannot_be_empty: { code: 1123, category: 1 /* Error */, key: \"Variable declaration list cannot be empty.\" },\n        Digit_expected: { code: 1124, category: 1 /* Error */, key: \"Digit expected.\" },\n        Hexadecimal_digit_expected: { code: 1125, category: 1 /* Error */, key: \"Hexadecimal digit expected.\" },\n        Unexpected_end_of_text: { code: 1126, category: 1 /* Error */, key: \"Unexpected end of text.\" },\n        Invalid_character: { code: 1127, category: 1 /* Error */, key: \"Invalid character.\" },\n        Declaration_or_statement_expected: { code: 1128, category: 1 /* Error */, key: \"Declaration or statement expected.\" },\n        Statement_expected: { code: 1129, category: 1 /* Error */, key: \"Statement expected.\" },\n        case_or_default_expected: { code: 1130, category: 1 /* Error */, key: \"'case' or 'default' expected.\" },\n        Property_or_signature_expected: { code: 1131, category: 1 /* Error */, key: \"Property or signature expected.\" },\n        Enum_member_expected: { code: 1132, category: 1 /* Error */, key: \"Enum member expected.\" },\n        Type_reference_expected: { code: 1133, category: 1 /* Error */, key: \"Type reference expected.\" },\n        Variable_declaration_expected: { code: 1134, category: 1 /* Error */, key: \"Variable declaration expected.\" },\n        Argument_expression_expected: { code: 1135, category: 1 /* Error */, key: \"Argument expression expected.\" },\n        Property_assignment_expected: { code: 1136, category: 1 /* Error */, key: \"Property assignment expected.\" },\n        Expression_or_comma_expected: { code: 1137, category: 1 /* Error */, key: \"Expression or comma expected.\" },\n        Parameter_declaration_expected: { code: 1138, category: 1 /* Error */, key: \"Parameter declaration expected.\" },\n        Type_parameter_declaration_expected: { code: 1139, category: 1 /* Error */, key: \"Type parameter declaration expected.\" },\n        Type_argument_expected: { code: 1140, category: 1 /* Error */, key: \"Type argument expected.\" },\n        String_literal_expected: { code: 1141, category: 1 /* Error */, key: \"String literal expected.\" },\n        Line_break_not_permitted_here: { code: 1142, category: 1 /* Error */, key: \"Line break not permitted here.\" },\n        or_expected: { code: 1144, category: 1 /* Error */, key: \"'{' or ';' expected.\" },\n        Modifiers_not_permitted_on_index_signature_members: { code: 1145, category: 1 /* Error */, key: \"Modifiers not permitted on index signature members.\" },\n        Declaration_expected: { code: 1146, category: 1 /* Error */, key: \"Declaration expected.\" },\n        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: { code: 1147, category: 1 /* Error */, key: \"Import declarations in an internal module cannot reference an external module.\" },\n        Cannot_compile_external_modules_unless_the_module_flag_is_provided: { code: 1148, category: 1 /* Error */, key: \"Cannot compile external modules unless the '--module' flag is provided.\" },\n        Filename_0_differs_from_already_included_filename_1_only_in_casing: { code: 1149, category: 1 /* Error */, key: \"Filename '{0}' differs from already included filename '{1}' only in casing\" },\n        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: { code: 1150, category: 1 /* Error */, key: \"'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.\" },\n        var_let_or_const_expected: { code: 1152, category: 1 /* Error */, key: \"'var', 'let' or 'const' expected.\" },\n        let_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher: { code: 1153, category: 1 /* Error */, key: \"'let' declarations are only available when targeting ECMAScript 6 and higher.\" },\n        const_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher: { code: 1154, category: 1 /* Error */, key: \"'const' declarations are only available when targeting ECMAScript 6 and higher.\" },\n        const_declarations_must_be_initialized: { code: 1155, category: 1 /* Error */, key: \"'const' declarations must be initialized\" },\n        const_declarations_can_only_be_declared_inside_a_block: { code: 1156, category: 1 /* Error */, key: \"'const' declarations can only be declared inside a block.\" },\n        let_declarations_can_only_be_declared_inside_a_block: { code: 1157, category: 1 /* Error */, key: \"'let' declarations can only be declared inside a block.\" },\n        Tagged_templates_are_only_available_when_targeting_ECMAScript_6_and_higher: { code: 1159, category: 1 /* Error */, key: \"Tagged templates are only available when targeting ECMAScript 6 and higher.\" },\n        Unterminated_template_literal: { code: 1160, category: 1 /* Error */, key: \"Unterminated template literal.\" },\n        Unterminated_regular_expression_literal: { code: 1161, category: 1 /* Error */, key: \"Unterminated regular expression literal.\" },\n        An_object_member_cannot_be_declared_optional: { code: 1162, category: 1 /* Error */, key: \"An object member cannot be declared optional.\" },\n        yield_expression_must_be_contained_within_a_generator_declaration: { code: 1163, category: 1 /* Error */, key: \"'yield' expression must be contained_within a generator declaration.\" },\n        Computed_property_names_are_not_allowed_in_enums: { code: 1164, category: 1 /* Error */, key: \"Computed property names are not allowed in enums.\" },\n        Computed_property_names_are_not_allowed_in_an_ambient_context: { code: 1165, category: 1 /* Error */, key: \"Computed property names are not allowed in an ambient context.\" },\n        Computed_property_names_are_not_allowed_in_class_property_declarations: { code: 1166, category: 1 /* Error */, key: \"Computed property names are not allowed in class property declarations.\" },\n        Computed_property_names_are_only_available_when_targeting_ECMAScript_6_and_higher: { code: 1167, category: 1 /* Error */, key: \"Computed property names are only available when targeting ECMAScript 6 and higher.\" },\n        Computed_property_names_are_not_allowed_in_method_overloads: { code: 1168, category: 1 /* Error */, key: \"Computed property names are not allowed in method overloads.\" },\n        Computed_property_names_are_not_allowed_in_interfaces: { code: 1169, category: 1 /* Error */, key: \"Computed property names are not allowed in interfaces.\" },\n        Computed_property_names_are_not_allowed_in_type_literals: { code: 1170, category: 1 /* Error */, key: \"Computed property names are not allowed in type literals.\" },\n        A_comma_expression_is_not_allowed_in_a_computed_property_name: { code: 1171, category: 1 /* Error */, key: \"A comma expression is not allowed in a computed property name.\" },\n        extends_clause_already_seen: { code: 1172, category: 1 /* Error */, key: \"'extends' clause already seen.\" },\n        extends_clause_must_precede_implements_clause: { code: 1173, category: 1 /* Error */, key: \"'extends' clause must precede 'implements' clause.\" },\n        Classes_can_only_extend_a_single_class: { code: 1174, category: 1 /* Error */, key: \"Classes can only extend a single class.\" },\n        implements_clause_already_seen: { code: 1175, category: 1 /* Error */, key: \"'implements' clause already seen.\" },\n        Interface_declaration_cannot_have_implements_clause: { code: 1176, category: 1 /* Error */, key: \"Interface declaration cannot have 'implements' clause.\" },\n        Binary_digit_expected: { code: 1177, category: 1 /* Error */, key: \"Binary digit expected.\" },\n        Octal_digit_expected: { code: 1178, category: 1 /* Error */, key: \"Octal digit expected.\" },\n        Unexpected_token_expected: { code: 1179, category: 1 /* Error */, key: \"Unexpected token. '{' expected.\" },\n        Duplicate_identifier_0: { code: 2300, category: 1 /* Error */, key: \"Duplicate identifier '{0}'.\" },\n        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: { code: 2301, category: 1 /* Error */, key: \"Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.\" },\n        Static_members_cannot_reference_class_type_parameters: { code: 2302, category: 1 /* Error */, key: \"Static members cannot reference class type parameters.\" },\n        Circular_definition_of_import_alias_0: { code: 2303, category: 1 /* Error */, key: \"Circular definition of import alias '{0}'.\" },\n        Cannot_find_name_0: { code: 2304, category: 1 /* Error */, key: \"Cannot find name '{0}'.\" },\n        Module_0_has_no_exported_member_1: { code: 2305, category: 1 /* Error */, key: \"Module '{0}' has no exported member '{1}'.\" },\n        File_0_is_not_an_external_module: { code: 2306, category: 1 /* Error */, key: \"File '{0}' is not an external module.\" },\n        Cannot_find_external_module_0: { code: 2307, category: 1 /* Error */, key: \"Cannot find external module '{0}'.\" },\n        A_module_cannot_have_more_than_one_export_assignment: { code: 2308, category: 1 /* Error */, key: \"A module cannot have more than one export assignment.\" },\n        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: { code: 2309, category: 1 /* Error */, key: \"An export assignment cannot be used in a module with other exported elements.\" },\n        Type_0_recursively_references_itself_as_a_base_type: { code: 2310, category: 1 /* Error */, key: \"Type '{0}' recursively references itself as a base type.\" },\n        A_class_may_only_extend_another_class: { code: 2311, category: 1 /* Error */, key: \"A class may only extend another class.\" },\n        An_interface_may_only_extend_a_class_or_another_interface: { code: 2312, category: 1 /* Error */, key: \"An interface may only extend a class or another interface.\" },\n        Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list: { code: 2313, category: 1 /* Error */, key: \"Constraint of a type parameter cannot reference any type parameter from the same type parameter list.\" },\n        Generic_type_0_requires_1_type_argument_s: { code: 2314, category: 1 /* Error */, key: \"Generic type '{0}' requires {1} type argument(s).\" },\n        Type_0_is_not_generic: { code: 2315, category: 1 /* Error */, key: \"Type '{0}' is not generic.\" },\n        Global_type_0_must_be_a_class_or_interface_type: { code: 2316, category: 1 /* Error */, key: \"Global type '{0}' must be a class or interface type.\" },\n        Global_type_0_must_have_1_type_parameter_s: { code: 2317, category: 1 /* Error */, key: \"Global type '{0}' must have {1} type parameter(s).\" },\n        Cannot_find_global_type_0: { code: 2318, category: 1 /* Error */, key: \"Cannot find global type '{0}'.\" },\n        Named_properties_0_of_types_1_and_2_are_not_identical: { code: 2319, category: 1 /* Error */, key: \"Named properties '{0}' of types '{1}' and '{2}' are not identical.\" },\n        Interface_0_cannot_simultaneously_extend_types_1_and_2: { code: 2320, category: 1 /* Error */, key: \"Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.\" },\n        Excessive_stack_depth_comparing_types_0_and_1: { code: 2321, category: 1 /* Error */, key: \"Excessive stack depth comparing types '{0}' and '{1}'.\" },\n        Type_0_is_not_assignable_to_type_1: { code: 2322, category: 1 /* Error */, key: \"Type '{0}' is not assignable to type '{1}'.\" },\n        Property_0_is_missing_in_type_1: { code: 2324, category: 1 /* Error */, key: \"Property '{0}' is missing in type '{1}'.\" },\n        Property_0_is_private_in_type_1_but_not_in_type_2: { code: 2325, category: 1 /* Error */, key: \"Property '{0}' is private in type '{1}' but not in type '{2}'.\" },\n        Types_of_property_0_are_incompatible: { code: 2326, category: 1 /* Error */, key: \"Types of property '{0}' are incompatible.\" },\n        Property_0_is_optional_in_type_1_but_required_in_type_2: { code: 2327, category: 1 /* Error */, key: \"Property '{0}' is optional in type '{1}' but required in type '{2}'.\" },\n        Types_of_parameters_0_and_1_are_incompatible: { code: 2328, category: 1 /* Error */, key: \"Types of parameters '{0}' and '{1}' are incompatible.\" },\n        Index_signature_is_missing_in_type_0: { code: 2329, category: 1 /* Error */, key: \"Index signature is missing in type '{0}'.\" },\n        Index_signatures_are_incompatible: { code: 2330, category: 1 /* Error */, key: \"Index signatures are incompatible.\" },\n        this_cannot_be_referenced_in_a_module_body: { code: 2331, category: 1 /* Error */, key: \"'this' cannot be referenced in a module body.\" },\n        this_cannot_be_referenced_in_current_location: { code: 2332, category: 1 /* Error */, key: \"'this' cannot be referenced in current location.\" },\n        this_cannot_be_referenced_in_constructor_arguments: { code: 2333, category: 1 /* Error */, key: \"'this' cannot be referenced in constructor arguments.\" },\n        this_cannot_be_referenced_in_a_static_property_initializer: { code: 2334, category: 1 /* Error */, key: \"'this' cannot be referenced in a static property initializer.\" },\n        super_can_only_be_referenced_in_a_derived_class: { code: 2335, category: 1 /* Error */, key: \"'super' can only be referenced in a derived class.\" },\n        super_cannot_be_referenced_in_constructor_arguments: { code: 2336, category: 1 /* Error */, key: \"'super' cannot be referenced in constructor arguments.\" },\n        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: { code: 2337, category: 1 /* Error */, key: \"Super calls are not permitted outside constructors or in nested functions inside constructors\" },\n        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: { code: 2338, category: 1 /* Error */, key: \"'super' property access is permitted only in a constructor, member function, or member accessor of a derived class\" },\n        Property_0_does_not_exist_on_type_1: { code: 2339, category: 1 /* Error */, key: \"Property '{0}' does not exist on type '{1}'.\" },\n        Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: { code: 2340, category: 1 /* Error */, key: \"Only public and protected methods of the base class are accessible via the 'super' keyword\" },\n        Property_0_is_private_and_only_accessible_within_class_1: { code: 2341, category: 1 /* Error */, key: \"Property '{0}' is private and only accessible within class '{1}'.\" },\n        An_index_expression_argument_must_be_of_type_string_number_or_any: { code: 2342, category: 1 /* Error */, key: \"An index expression argument must be of type 'string', 'number', or 'any'.\" },\n        Type_0_does_not_satisfy_the_constraint_1: { code: 2344, category: 1 /* Error */, key: \"Type '{0}' does not satisfy the constraint '{1}'.\" },\n        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: { code: 2345, category: 1 /* Error */, key: \"Argument of type '{0}' is not assignable to parameter of type '{1}'.\" },\n        Supplied_parameters_do_not_match_any_signature_of_call_target: { code: 2346, category: 1 /* Error */, key: \"Supplied parameters do not match any signature of call target.\" },\n        Untyped_function_calls_may_not_accept_type_arguments: { code: 2347, category: 1 /* Error */, key: \"Untyped function calls may not accept type arguments.\" },\n        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: { code: 2348, category: 1 /* Error */, key: \"Value of type '{0}' is not callable. Did you mean to include 'new'?\" },\n        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: { code: 2349, category: 1 /* Error */, key: \"Cannot invoke an expression whose type lacks a call signature.\" },\n        Only_a_void_function_can_be_called_with_the_new_keyword: { code: 2350, category: 1 /* Error */, key: \"Only a void function can be called with the 'new' keyword.\" },\n        Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature: { code: 2351, category: 1 /* Error */, key: \"Cannot use 'new' with an expression whose type lacks a call or construct signature.\" },\n        Neither_type_0_nor_type_1_is_assignable_to_the_other: { code: 2352, category: 1 /* Error */, key: \"Neither type '{0}' nor type '{1}' is assignable to the other.\" },\n        No_best_common_type_exists_among_return_expressions: { code: 2354, category: 1 /* Error */, key: \"No best common type exists among return expressions.\" },\n        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2355, category: 1 /* Error */, key: \"A function whose declared type is neither 'void' nor 'any' must return a value or consist of a single 'throw' statement.\" },\n        An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type: { code: 2356, category: 1 /* Error */, key: \"An arithmetic operand must be of type 'any', 'number' or an enum type.\" },\n        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: { code: 2357, category: 1 /* Error */, key: \"The operand of an increment or decrement operator must be a variable, property or indexer.\" },\n        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2358, category: 1 /* Error */, key: \"The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.\" },\n        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: { code: 2359, category: 1 /* Error */, key: \"The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.\" },\n        The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number: { code: 2360, category: 1 /* Error */, key: \"The left-hand side of an 'in' expression must be of types 'any', 'string' or 'number'.\" },\n        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2361, category: 1 /* Error */, key: \"The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter\" },\n        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2362, category: 1 /* Error */, key: \"The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\" },\n        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: { code: 2363, category: 1 /* Error */, key: \"The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\" },\n        Invalid_left_hand_side_of_assignment_expression: { code: 2364, category: 1 /* Error */, key: \"Invalid left-hand side of assignment expression.\" },\n        Operator_0_cannot_be_applied_to_types_1_and_2: { code: 2365, category: 1 /* Error */, key: \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\" },\n        Type_parameter_name_cannot_be_0: { code: 2368, category: 1 /* Error */, key: \"Type parameter name cannot be '{0}'\" },\n        A_parameter_property_is_only_allowed_in_a_constructor_implementation: { code: 2369, category: 1 /* Error */, key: \"A parameter property is only allowed in a constructor implementation.\" },\n        A_rest_parameter_must_be_of_an_array_type: { code: 2370, category: 1 /* Error */, key: \"A rest parameter must be of an array type.\" },\n        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: { code: 2371, category: 1 /* Error */, key: \"A parameter initializer is only allowed in a function or constructor implementation.\" },\n        Parameter_0_cannot_be_referenced_in_its_initializer: { code: 2372, category: 1 /* Error */, key: \"Parameter '{0}' cannot be referenced in its initializer.\" },\n        Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it: { code: 2373, category: 1 /* Error */, key: \"Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.\" },\n        Duplicate_string_index_signature: { code: 2374, category: 1 /* Error */, key: \"Duplicate string index signature.\" },\n        Duplicate_number_index_signature: { code: 2375, category: 1 /* Error */, key: \"Duplicate number index signature.\" },\n        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: { code: 2376, category: 1 /* Error */, key: \"A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.\" },\n        Constructors_for_derived_classes_must_contain_a_super_call: { code: 2377, category: 1 /* Error */, key: \"Constructors for derived classes must contain a 'super' call.\" },\n        A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement: { code: 2378, category: 1 /* Error */, key: \"A 'get' accessor must return a value or consist of a single 'throw' statement.\" },\n        Getter_and_setter_accessors_do_not_agree_in_visibility: { code: 2379, category: 1 /* Error */, key: \"Getter and setter accessors do not agree in visibility.\" },\n        get_and_set_accessor_must_have_the_same_type: { code: 2380, category: 1 /* Error */, key: \"'get' and 'set' accessor must have the same type.\" },\n        A_signature_with_an_implementation_cannot_use_a_string_literal_type: { code: 2381, category: 1 /* Error */, key: \"A signature with an implementation cannot use a string literal type.\" },\n        Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature: { code: 2382, category: 1 /* Error */, key: \"Specialized overload signature is not assignable to any non-specialized signature.\" },\n        Overload_signatures_must_all_be_exported_or_not_exported: { code: 2383, category: 1 /* Error */, key: \"Overload signatures must all be exported or not exported.\" },\n        Overload_signatures_must_all_be_ambient_or_non_ambient: { code: 2384, category: 1 /* Error */, key: \"Overload signatures must all be ambient or non-ambient.\" },\n        Overload_signatures_must_all_be_public_private_or_protected: { code: 2385, category: 1 /* Error */, key: \"Overload signatures must all be public, private or protected.\" },\n        Overload_signatures_must_all_be_optional_or_required: { code: 2386, category: 1 /* Error */, key: \"Overload signatures must all be optional or required.\" },\n        Function_overload_must_be_static: { code: 2387, category: 1 /* Error */, key: \"Function overload must be static.\" },\n        Function_overload_must_not_be_static: { code: 2388, category: 1 /* Error */, key: \"Function overload must not be static.\" },\n        Function_implementation_name_must_be_0: { code: 2389, category: 1 /* Error */, key: \"Function implementation name must be '{0}'.\" },\n        Constructor_implementation_is_missing: { code: 2390, category: 1 /* Error */, key: \"Constructor implementation is missing.\" },\n        Function_implementation_is_missing_or_not_immediately_following_the_declaration: { code: 2391, category: 1 /* Error */, key: \"Function implementation is missing or not immediately following the declaration.\" },\n        Multiple_constructor_implementations_are_not_allowed: { code: 2392, category: 1 /* Error */, key: \"Multiple constructor implementations are not allowed.\" },\n        Duplicate_function_implementation: { code: 2393, category: 1 /* Error */, key: \"Duplicate function implementation.\" },\n        Overload_signature_is_not_compatible_with_function_implementation: { code: 2394, category: 1 /* Error */, key: \"Overload signature is not compatible with function implementation.\" },\n        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: { code: 2395, category: 1 /* Error */, key: \"Individual declarations in merged declaration {0} must be all exported or all local.\" },\n        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: { code: 2396, category: 1 /* Error */, key: \"Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.\" },\n        Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter: { code: 2397, category: 1 /* Error */, key: \"Duplicate identifier '_i'. Compiler uses '_i' to initialize rest parameter.\" },\n        Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter: { code: 2398, category: 1 /* Error */, key: \"Expression resolves to variable declaration '_i' that compiler uses to initialize rest parameter.\" },\n        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: { code: 2399, category: 1 /* Error */, key: \"Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.\" },\n        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: { code: 2400, category: 1 /* Error */, key: \"Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.\" },\n        Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference: { code: 2401, category: 1 /* Error */, key: \"Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.\" },\n        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: { code: 2402, category: 1 /* Error */, key: \"Expression resolves to '_super' that compiler uses to capture base class reference.\" },\n        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: { code: 2403, category: 1 /* Error */, key: \"Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.\" },\n        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: { code: 2404, category: 1 /* Error */, key: \"The left-hand side of a 'for...in' statement cannot use a type annotation.\" },\n        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: { code: 2405, category: 1 /* Error */, key: \"The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.\" },\n        Invalid_left_hand_side_in_for_in_statement: { code: 2406, category: 1 /* Error */, key: \"Invalid left-hand side in 'for...in' statement.\" },\n        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: { code: 2407, category: 1 /* Error */, key: \"The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.\" },\n        Setters_cannot_return_a_value: { code: 2408, category: 1 /* Error */, key: \"Setters cannot return a value.\" },\n        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: { code: 2409, category: 1 /* Error */, key: \"Return type of constructor signature must be assignable to the instance type of the class\" },\n        All_symbols_within_a_with_block_will_be_resolved_to_any: { code: 2410, category: 1 /* Error */, key: \"All symbols within a 'with' block will be resolved to 'any'.\" },\n        Property_0_of_type_1_is_not_assignable_to_string_index_type_2: { code: 2411, category: 1 /* Error */, key: \"Property '{0}' of type '{1}' is not assignable to string index type '{2}'.\" },\n        Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2: { code: 2412, category: 1 /* Error */, key: \"Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.\" },\n        Numeric_index_type_0_is_not_assignable_to_string_index_type_1: { code: 2413, category: 1 /* Error */, key: \"Numeric index type '{0}' is not assignable to string index type '{1}'.\" },\n        Class_name_cannot_be_0: { code: 2414, category: 1 /* Error */, key: \"Class name cannot be '{0}'\" },\n        Class_0_incorrectly_extends_base_class_1: { code: 2415, category: 1 /* Error */, key: \"Class '{0}' incorrectly extends base class '{1}'.\" },\n        Class_static_side_0_incorrectly_extends_base_class_static_side_1: { code: 2417, category: 1 /* Error */, key: \"Class static side '{0}' incorrectly extends base class static side '{1}'.\" },\n        Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0: { code: 2419, category: 1 /* Error */, key: \"Type name '{0}' in extends clause does not reference constructor function for '{0}'.\" },\n        Class_0_incorrectly_implements_interface_1: { code: 2420, category: 1 /* Error */, key: \"Class '{0}' incorrectly implements interface '{1}'.\" },\n        A_class_may_only_implement_another_class_or_interface: { code: 2422, category: 1 /* Error */, key: \"A class may only implement another class or interface.\" },\n        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: { code: 2423, category: 1 /* Error */, key: \"Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.\" },\n        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: { code: 2424, category: 1 /* Error */, key: \"Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.\" },\n        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2425, category: 1 /* Error */, key: \"Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.\" },\n        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: { code: 2426, category: 1 /* Error */, key: \"Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.\" },\n        Interface_name_cannot_be_0: { code: 2427, category: 1 /* Error */, key: \"Interface name cannot be '{0}'\" },\n        All_declarations_of_an_interface_must_have_identical_type_parameters: { code: 2428, category: 1 /* Error */, key: \"All declarations of an interface must have identical type parameters.\" },\n        Interface_0_incorrectly_extends_interface_1: { code: 2430, category: 1 /* Error */, key: \"Interface '{0}' incorrectly extends interface '{1}'.\" },\n        Enum_name_cannot_be_0: { code: 2431, category: 1 /* Error */, key: \"Enum name cannot be '{0}'\" },\n        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: { code: 2432, category: 1 /* Error */, key: \"In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.\" },\n        A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: { code: 2433, category: 1 /* Error */, key: \"A module declaration cannot be in a different file from a class or function with which it is merged\" },\n        A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: { code: 2434, category: 1 /* Error */, key: \"A module declaration cannot be located prior to a class or function with which it is merged\" },\n        Ambient_external_modules_cannot_be_nested_in_other_modules: { code: 2435, category: 1 /* Error */, key: \"Ambient external modules cannot be nested in other modules.\" },\n        Ambient_external_module_declaration_cannot_specify_relative_module_name: { code: 2436, category: 1 /* Error */, key: \"Ambient external module declaration cannot specify relative module name.\" },\n        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: { code: 2437, category: 1 /* Error */, key: \"Module '{0}' is hidden by a local declaration with the same name\" },\n        Import_name_cannot_be_0: { code: 2438, category: 1 /* Error */, key: \"Import name cannot be '{0}'\" },\n        Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name: { code: 2439, category: 1 /* Error */, key: \"Import declaration in an ambient external module declaration cannot reference external module through relative external module name.\" },\n        Import_declaration_conflicts_with_local_declaration_of_0: { code: 2440, category: 1 /* Error */, key: \"Import declaration conflicts with local declaration of '{0}'\" },\n        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module: { code: 2441, category: 1 /* Error */, key: \"Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of an external module.\" },\n        Types_have_separate_declarations_of_a_private_property_0: { code: 2442, category: 1 /* Error */, key: \"Types have separate declarations of a private property '{0}'.\" },\n        Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: { code: 2443, category: 1 /* Error */, key: \"Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.\" },\n        Property_0_is_protected_in_type_1_but_public_in_type_2: { code: 2444, category: 1 /* Error */, key: \"Property '{0}' is protected in type '{1}' but public in type '{2}'.\" },\n        Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: { code: 2445, category: 1 /* Error */, key: \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\" },\n        Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1: { code: 2446, category: 1 /* Error */, key: \"Property '{0}' is protected and only accessible through an instance of class '{1}'.\" },\n        The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: { code: 2447, category: 1 /* Error */, key: \"The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.\" },\n        Block_scoped_variable_0_used_before_its_declaration: { code: 2448, category: 1 /* Error */, key: \"Block-scoped variable '{0}' used before its declaration.\", isEarly: true },\n        The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant: { code: 2449, category: 1 /* Error */, key: \"The operand of an increment or decrement operator cannot be a constant.\", isEarly: true },\n        Left_hand_side_of_assignment_expression_cannot_be_a_constant: { code: 2450, category: 1 /* Error */, key: \"Left-hand side of assignment expression cannot be a constant.\", isEarly: true },\n        Cannot_redeclare_block_scoped_variable_0: { code: 2451, category: 1 /* Error */, key: \"Cannot redeclare block-scoped variable '{0}'.\", isEarly: true },\n        An_enum_member_cannot_have_a_numeric_name: { code: 2452, category: 1 /* Error */, key: \"An enum member cannot have a numeric name.\" },\n        The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly: { code: 2453, category: 1 /* Error */, key: \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\" },\n        Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0: { code: 2455, category: 1 /* Error */, key: \"Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.\" },\n        Type_alias_0_circularly_references_itself: { code: 2456, category: 1 /* Error */, key: \"Type alias '{0}' circularly references itself.\" },\n        Type_alias_name_cannot_be_0: { code: 2457, category: 1 /* Error */, key: \"Type alias name cannot be '{0}'\" },\n        An_AMD_module_cannot_have_multiple_name_assignments: { code: 2458, category: 1 /* Error */, key: \"An AMD module cannot have multiple name assignments.\" },\n        Import_declaration_0_is_using_private_name_1: { code: 4000, category: 1 /* Error */, key: \"Import declaration '{0}' is using private name '{1}'.\" },\n        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: { code: 4002, category: 1 /* Error */, key: \"Type parameter '{0}' of exported class has or is using private name '{1}'.\" },\n        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4004, category: 1 /* Error */, key: \"Type parameter '{0}' of exported interface has or is using private name '{1}'.\" },\n        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4006, category: 1 /* Error */, key: \"Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.\" },\n        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4008, category: 1 /* Error */, key: \"Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.\" },\n        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4010, category: 1 /* Error */, key: \"Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.\" },\n        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4012, category: 1 /* Error */, key: \"Type parameter '{0}' of public method from exported class has or is using private name '{1}'.\" },\n        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4014, category: 1 /* Error */, key: \"Type parameter '{0}' of method from exported interface has or is using private name '{1}'.\" },\n        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4016, category: 1 /* Error */, key: \"Type parameter '{0}' of exported function has or is using private name '{1}'.\" },\n        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4019, category: 1 /* Error */, key: \"Implements clause of exported class '{0}' has or is using private name '{1}'.\" },\n        Extends_clause_of_exported_class_0_has_or_is_using_private_name_1: { code: 4020, category: 1 /* Error */, key: \"Extends clause of exported class '{0}' has or is using private name '{1}'.\" },\n        Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: { code: 4022, category: 1 /* Error */, key: \"Extends clause of exported interface '{0}' has or is using private name '{1}'.\" },\n        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4023, category: 1 /* Error */, key: \"Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.\" },\n        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: { code: 4024, category: 1 /* Error */, key: \"Exported variable '{0}' has or is using name '{1}' from private module '{2}'.\" },\n        Exported_variable_0_has_or_is_using_private_name_1: { code: 4025, category: 1 /* Error */, key: \"Exported variable '{0}' has or is using private name '{1}'.\" },\n        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4026, category: 1 /* Error */, key: \"Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\n        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4027, category: 1 /* Error */, key: \"Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.\" },\n        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4028, category: 1 /* Error */, key: \"Public static property '{0}' of exported class has or is using private name '{1}'.\" },\n        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4029, category: 1 /* Error */, key: \"Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\n        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4030, category: 1 /* Error */, key: \"Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.\" },\n        Public_property_0_of_exported_class_has_or_is_using_private_name_1: { code: 4031, category: 1 /* Error */, key: \"Public property '{0}' of exported class has or is using private name '{1}'.\" },\n        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4032, category: 1 /* Error */, key: \"Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.\" },\n        Property_0_of_exported_interface_has_or_is_using_private_name_1: { code: 4033, category: 1 /* Error */, key: \"Property '{0}' of exported interface has or is using private name '{1}'.\" },\n        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4034, category: 1 /* Error */, key: \"Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4035, category: 1 /* Error */, key: \"Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.\" },\n        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4036, category: 1 /* Error */, key: \"Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1: { code: 4037, category: 1 /* Error */, key: \"Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.\" },\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4038, category: 1 /* Error */, key: \"Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.\" },\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4039, category: 1 /* Error */, key: \"Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4040, category: 1 /* Error */, key: \"Return type of public static property getter from exported class has or is using private name '{0}'.\" },\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4041, category: 1 /* Error */, key: \"Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.\" },\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4042, category: 1 /* Error */, key: \"Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0: { code: 4043, category: 1 /* Error */, key: \"Return type of public property getter from exported class has or is using private name '{0}'.\" },\n        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4044, category: 1 /* Error */, key: \"Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4045, category: 1 /* Error */, key: \"Return type of constructor signature from exported interface has or is using private name '{0}'.\" },\n        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4046, category: 1 /* Error */, key: \"Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4047, category: 1 /* Error */, key: \"Return type of call signature from exported interface has or is using private name '{0}'.\" },\n        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4048, category: 1 /* Error */, key: \"Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: { code: 4049, category: 1 /* Error */, key: \"Return type of index signature from exported interface has or is using private name '{0}'.\" },\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4050, category: 1 /* Error */, key: \"Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.\" },\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4051, category: 1 /* Error */, key: \"Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: { code: 4052, category: 1 /* Error */, key: \"Return type of public static method from exported class has or is using private name '{0}'.\" },\n        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4053, category: 1 /* Error */, key: \"Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.\" },\n        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: { code: 4054, category: 1 /* Error */, key: \"Return type of public method from exported class has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: { code: 4055, category: 1 /* Error */, key: \"Return type of public method from exported class has or is using private name '{0}'.\" },\n        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: { code: 4056, category: 1 /* Error */, key: \"Return type of method from exported interface has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: { code: 4057, category: 1 /* Error */, key: \"Return type of method from exported interface has or is using private name '{0}'.\" },\n        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: { code: 4058, category: 1 /* Error */, key: \"Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.\" },\n        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: { code: 4059, category: 1 /* Error */, key: \"Return type of exported function has or is using name '{0}' from private module '{1}'.\" },\n        Return_type_of_exported_function_has_or_is_using_private_name_0: { code: 4060, category: 1 /* Error */, key: \"Return type of exported function has or is using private name '{0}'.\" },\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4061, category: 1 /* Error */, key: \"Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4062, category: 1 /* Error */, key: \"Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: { code: 4063, category: 1 /* Error */, key: \"Parameter '{0}' of constructor from exported class has or is using private name '{1}'.\" },\n        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4064, category: 1 /* Error */, key: \"Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4065, category: 1 /* Error */, key: \"Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.\" },\n        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4066, category: 1 /* Error */, key: \"Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: { code: 4067, category: 1 /* Error */, key: \"Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.\" },\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4068, category: 1 /* Error */, key: \"Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4069, category: 1 /* Error */, key: \"Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: { code: 4070, category: 1 /* Error */, key: \"Parameter '{0}' of public static method from exported class has or is using private name '{1}'.\" },\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4071, category: 1 /* Error */, key: \"Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.\" },\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: { code: 4072, category: 1 /* Error */, key: \"Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: { code: 4073, category: 1 /* Error */, key: \"Parameter '{0}' of public method from exported class has or is using private name '{1}'.\" },\n        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: { code: 4074, category: 1 /* Error */, key: \"Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: { code: 4075, category: 1 /* Error */, key: \"Parameter '{0}' of method from exported interface has or is using private name '{1}'.\" },\n        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: { code: 4076, category: 1 /* Error */, key: \"Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.\" },\n        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: { code: 4077, category: 1 /* Error */, key: \"Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.\" },\n        Parameter_0_of_exported_function_has_or_is_using_private_name_1: { code: 4078, category: 1 /* Error */, key: \"Parameter '{0}' of exported function has or is using private name '{1}'.\" },\n        Exported_type_alias_0_has_or_is_using_private_name_1: { code: 4081, category: 1 /* Error */, key: \"Exported type alias '{0}' has or is using private name '{1}'.\" },\n        Enum_declarations_must_all_be_const_or_non_const: { code: 4082, category: 1 /* Error */, key: \"Enum declarations must all be const or non-const.\" },\n        In_const_enum_declarations_member_initializer_must_be_constant_expression: { code: 4083, category: 1 /* Error */, key: \"In 'const' enum declarations member initializer must be constant expression.\", isEarly: true },\n        const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment: { code: 4084, category: 1 /* Error */, key: \"'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.\" },\n        Index_expression_arguments_in_const_enums_must_be_of_type_string: { code: 4085, category: 1 /* Error */, key: \"Index expression arguments in 'const' enums must be of type 'string'.\" },\n        const_enum_member_initializer_was_evaluated_to_a_non_finite_value: { code: 4086, category: 1 /* Error */, key: \"'const' enum member initializer was evaluated to a non-finite value.\" },\n        const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: { code: 4087, category: 1 /* Error */, key: \"'const' enum member initializer was evaluated to disallowed value 'NaN'.\" },\n        The_current_host_does_not_support_the_0_option: { code: 5001, category: 1 /* Error */, key: \"The current host does not support the '{0}' option.\" },\n        Cannot_find_the_common_subdirectory_path_for_the_input_files: { code: 5009, category: 1 /* Error */, key: \"Cannot find the common subdirectory path for the input files.\" },\n        Cannot_read_file_0_Colon_1: { code: 5012, category: 1 /* Error */, key: \"Cannot read file '{0}': {1}\" },\n        Unsupported_file_encoding: { code: 5013, category: 1 /* Error */, key: \"Unsupported file encoding.\" },\n        Unknown_compiler_option_0: { code: 5023, category: 1 /* Error */, key: \"Unknown compiler option '{0}'.\" },\n        Could_not_write_file_0_Colon_1: { code: 5033, category: 1 /* Error */, key: \"Could not write file '{0}': {1}\" },\n        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5038, category: 1 /* Error */, key: \"Option mapRoot cannot be specified without specifying sourcemap option.\" },\n        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: { code: 5039, category: 1 /* Error */, key: \"Option sourceRoot cannot be specified without specifying sourcemap option.\" },\n        Concatenate_and_emit_output_to_single_file: { code: 6001, category: 2 /* Message */, key: \"Concatenate and emit output to single file.\" },\n        Generates_corresponding_d_ts_file: { code: 6002, category: 2 /* Message */, key: \"Generates corresponding '.d.ts' file.\" },\n        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: { code: 6003, category: 2 /* Message */, key: \"Specifies the location where debugger should locate map files instead of generated locations.\" },\n        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: { code: 6004, category: 2 /* Message */, key: \"Specifies the location where debugger should locate TypeScript files instead of source locations.\" },\n        Watch_input_files: { code: 6005, category: 2 /* Message */, key: \"Watch input files.\" },\n        Redirect_output_structure_to_the_directory: { code: 6006, category: 2 /* Message */, key: \"Redirect output structure to the directory.\" },\n        Do_not_erase_const_enum_declarations_in_generated_code: { code: 6007, category: 2 /* Message */, key: \"Do not erase const enum declarations in generated code.\" },\n        Do_not_emit_outputs_if_any_type_checking_errors_were_reported: { code: 6008, category: 2 /* Message */, key: \"Do not emit outputs if any type checking errors were reported.\" },\n        Do_not_emit_comments_to_output: { code: 6009, category: 2 /* Message */, key: \"Do not emit comments to output.\" },\n        Specify_ECMAScript_target_version_Colon_ES3_default_ES5_or_ES6_experimental: { code: 6015, category: 2 /* Message */, key: \"Specify ECMAScript target version: 'ES3' (default), 'ES5', or 'ES6' (experimental)\" },\n        Specify_module_code_generation_Colon_commonjs_or_amd: { code: 6016, category: 2 /* Message */, key: \"Specify module code generation: 'commonjs' or 'amd'\" },\n        Print_this_message: { code: 6017, category: 2 /* Message */, key: \"Print this message.\" },\n        Print_the_compiler_s_version: { code: 6019, category: 2 /* Message */, key: \"Print the compiler's version.\" },\n        Syntax_Colon_0: { code: 6023, category: 2 /* Message */, key: \"Syntax: {0}\" },\n        options: { code: 6024, category: 2 /* Message */, key: \"options\" },\n        file: { code: 6025, category: 2 /* Message */, key: \"file\" },\n        Examples_Colon_0: { code: 6026, category: 2 /* Message */, key: \"Examples: {0}\" },\n        Options_Colon: { code: 6027, category: 2 /* Message */, key: \"Options:\" },\n        Version_0: { code: 6029, category: 2 /* Message */, key: \"Version {0}\" },\n        Insert_command_line_options_and_files_from_a_file: { code: 6030, category: 2 /* Message */, key: \"Insert command line options and files from a file.\" },\n        File_change_detected_Compiling: { code: 6032, category: 2 /* Message */, key: \"File change detected. Compiling...\" },\n        KIND: { code: 6034, category: 2 /* Message */, key: \"KIND\" },\n        FILE: { code: 6035, category: 2 /* Message */, key: \"FILE\" },\n        VERSION: { code: 6036, category: 2 /* Message */, key: \"VERSION\" },\n        LOCATION: { code: 6037, category: 2 /* Message */, key: \"LOCATION\" },\n        DIRECTORY: { code: 6038, category: 2 /* Message */, key: \"DIRECTORY\" },\n        Compilation_complete_Watching_for_file_changes: { code: 6042, category: 2 /* Message */, key: \"Compilation complete. Watching for file changes.\" },\n        Generates_corresponding_map_file: { code: 6043, category: 2 /* Message */, key: \"Generates corresponding '.map' file.\" },\n        Compiler_option_0_expects_an_argument: { code: 6044, category: 1 /* Error */, key: \"Compiler option '{0}' expects an argument.\" },\n        Unterminated_quoted_string_in_response_file_0: { code: 6045, category: 1 /* Error */, key: \"Unterminated quoted string in response file '{0}'.\" },\n        Argument_for_module_option_must_be_commonjs_or_amd: { code: 6046, category: 1 /* Error */, key: \"Argument for '--module' option must be 'commonjs' or 'amd'.\" },\n        Argument_for_target_option_must_be_es3_es5_or_es6: { code: 6047, category: 1 /* Error */, key: \"Argument for '--target' option must be 'es3', 'es5', or 'es6'.\" },\n        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: { code: 6048, category: 1 /* Error */, key: \"Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.\" },\n        Unsupported_locale_0: { code: 6049, category: 1 /* Error */, key: \"Unsupported locale '{0}'.\" },\n        Unable_to_open_file_0: { code: 6050, category: 1 /* Error */, key: \"Unable to open file '{0}'.\" },\n        Corrupted_locale_file_0: { code: 6051, category: 1 /* Error */, key: \"Corrupted locale file {0}.\" },\n        Warn_on_expressions_and_declarations_with_an_implied_any_type: { code: 6052, category: 2 /* Message */, key: \"Warn on expressions and declarations with an implied 'any' type.\" },\n        File_0_not_found: { code: 6053, category: 1 /* Error */, key: \"File '{0}' not found.\" },\n        File_0_must_have_extension_ts_or_d_ts: { code: 6054, category: 1 /* Error */, key: \"File '{0}' must have extension '.ts' or '.d.ts'.\" },\n        Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: { code: 6055, category: 2 /* Message */, key: \"Suppress noImplicitAny errors for indexing objects lacking index signatures.\" },\n        Variable_0_implicitly_has_an_1_type: { code: 7005, category: 1 /* Error */, key: \"Variable '{0}' implicitly has an '{1}' type.\" },\n        Parameter_0_implicitly_has_an_1_type: { code: 7006, category: 1 /* Error */, key: \"Parameter '{0}' implicitly has an '{1}' type.\" },\n        Member_0_implicitly_has_an_1_type: { code: 7008, category: 1 /* Error */, key: \"Member '{0}' implicitly has an '{1}' type.\" },\n        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: { code: 7009, category: 1 /* Error */, key: \"'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.\" },\n        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: { code: 7010, category: 1 /* Error */, key: \"'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.\" },\n        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: { code: 7011, category: 1 /* Error */, key: \"Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.\" },\n        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7013, category: 1 /* Error */, key: \"Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.\" },\n        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation: { code: 7016, category: 1 /* Error */, key: \"Property '{0}' implicitly has type 'any', because its 'set' accessor lacks a type annotation.\" },\n        Index_signature_of_object_type_implicitly_has_an_any_type: { code: 7017, category: 1 /* Error */, key: \"Index signature of object type implicitly has an 'any' type.\" },\n        Object_literal_s_property_0_implicitly_has_an_1_type: { code: 7018, category: 1 /* Error */, key: \"Object literal's property '{0}' implicitly has an '{1}' type.\" },\n        Rest_parameter_0_implicitly_has_an_any_type: { code: 7019, category: 1 /* Error */, key: \"Rest parameter '{0}' implicitly has an 'any[]' type.\" },\n        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: { code: 7020, category: 1 /* Error */, key: \"Call signature, which lacks return-type annotation, implicitly has an 'any' return type.\" },\n        _0_implicitly_has_type_any_because_it_is_referenced_directly_or_indirectly_in_its_own_type_annotation: { code: 7021, category: 1 /* Error */, key: \"'{0}' implicitly has type 'any' because it is referenced directly or indirectly in its own type annotation.\" },\n        _0_implicitly_has_type_any_because_it_is_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: { code: 7022, category: 1 /* Error */, key: \"'{0}' implicitly has type 'any' because it is does not have a type annotation and is referenced directly or indirectly in its own initializer.\" },\n        _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: { code: 7023, category: 1 /* Error */, key: \"'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.\" },\n        Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: { code: 7024, category: 1 /* Error */, key: \"Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.\" },\n        You_cannot_rename_this_element: { code: 8000, category: 1 /* Error */, key: \"You cannot rename this element.\" },\n        yield_expressions_are_not_currently_supported: { code: 9000, category: 1 /* Error */, key: \"'yield' expressions are not currently supported.\" },\n        Generators_are_not_currently_supported: { code: 9001, category: 1 /* Error */, key: \"Generators are not currently supported.\" },\n        Computed_property_names_are_not_currently_supported: { code: 9002, category: 1 /* Error */, key: \"Computed property names are not currently supported.\" },\n    };\n})(ts || (ts = {}));\n/// <reference path=\"types.ts\"/>\n/// <reference path=\"core.ts\"/>\n/// <reference path=\"diagnosticInformationMap.generated.ts\"/>\nvar ts;\n(function (ts) {\n    var textToToken = {\n        \"any\": 109 /* AnyKeyword */,\n        \"boolean\": 110 /* BooleanKeyword */,\n        \"break\": 64 /* BreakKeyword */,\n        \"case\": 65 /* CaseKeyword */,\n        \"catch\": 66 /* CatchKeyword */,\n        \"class\": 67 /* ClassKeyword */,\n        \"continue\": 69 /* ContinueKeyword */,\n        \"const\": 68 /* ConstKeyword */,\n        \"constructor\": 111 /* ConstructorKeyword */,\n        \"debugger\": 70 /* DebuggerKeyword */,\n        \"declare\": 112 /* DeclareKeyword */,\n        \"default\": 71 /* DefaultKeyword */,\n        \"delete\": 72 /* DeleteKeyword */,\n        \"do\": 73 /* DoKeyword */,\n        \"else\": 74 /* ElseKeyword */,\n        \"enum\": 75 /* EnumKeyword */,\n        \"export\": 76 /* ExportKeyword */,\n        \"extends\": 77 /* ExtendsKeyword */,\n        \"false\": 78 /* FalseKeyword */,\n        \"finally\": 79 /* FinallyKeyword */,\n        \"for\": 80 /* ForKeyword */,\n        \"function\": 81 /* FunctionKeyword */,\n        \"get\": 113 /* GetKeyword */,\n        \"if\": 82 /* IfKeyword */,\n        \"implements\": 100 /* ImplementsKeyword */,\n        \"import\": 83 /* ImportKeyword */,\n        \"in\": 84 /* InKeyword */,\n        \"instanceof\": 85 /* InstanceOfKeyword */,\n        \"interface\": 101 /* InterfaceKeyword */,\n        \"let\": 102 /* LetKeyword */,\n        \"module\": 114 /* ModuleKeyword */,\n        \"new\": 86 /* NewKeyword */,\n        \"null\": 87 /* NullKeyword */,\n        \"number\": 116 /* NumberKeyword */,\n        \"package\": 103 /* PackageKeyword */,\n        \"private\": 104 /* PrivateKeyword */,\n        \"protected\": 105 /* ProtectedKeyword */,\n        \"public\": 106 /* PublicKeyword */,\n        \"require\": 115 /* RequireKeyword */,\n        \"return\": 88 /* ReturnKeyword */,\n        \"set\": 117 /* SetKeyword */,\n        \"static\": 107 /* StaticKeyword */,\n        \"string\": 118 /* StringKeyword */,\n        \"super\": 89 /* SuperKeyword */,\n        \"switch\": 90 /* SwitchKeyword */,\n        \"this\": 91 /* ThisKeyword */,\n        \"throw\": 92 /* ThrowKeyword */,\n        \"true\": 93 /* TrueKeyword */,\n        \"try\": 94 /* TryKeyword */,\n        \"type\": 119 /* TypeKeyword */,\n        \"typeof\": 95 /* TypeOfKeyword */,\n        \"var\": 96 /* VarKeyword */,\n        \"void\": 97 /* VoidKeyword */,\n        \"while\": 98 /* WhileKeyword */,\n        \"with\": 99 /* WithKeyword */,\n        \"yield\": 108 /* YieldKeyword */,\n        \"{\": 13 /* OpenBraceToken */,\n        \"}\": 14 /* CloseBraceToken */,\n        \"(\": 15 /* OpenParenToken */,\n        \")\": 16 /* CloseParenToken */,\n        \"[\": 17 /* OpenBracketToken */,\n        \"]\": 18 /* CloseBracketToken */,\n        \".\": 19 /* DotToken */,\n        \"...\": 20 /* DotDotDotToken */,\n        \";\": 21 /* SemicolonToken */,\n        \",\": 22 /* CommaToken */,\n        \"<\": 23 /* LessThanToken */,\n        \">\": 24 /* GreaterThanToken */,\n        \"<=\": 25 /* LessThanEqualsToken */,\n        \">=\": 26 /* GreaterThanEqualsToken */,\n        \"==\": 27 /* EqualsEqualsToken */,\n        \"!=\": 28 /* ExclamationEqualsToken */,\n        \"===\": 29 /* EqualsEqualsEqualsToken */,\n        \"!==\": 30 /* ExclamationEqualsEqualsToken */,\n        \"=>\": 31 /* EqualsGreaterThanToken */,\n        \"+\": 32 /* PlusToken */,\n        \"-\": 33 /* MinusToken */,\n        \"*\": 34 /* AsteriskToken */,\n        \"/\": 35 /* SlashToken */,\n        \"%\": 36 /* PercentToken */,\n        \"++\": 37 /* PlusPlusToken */,\n        \"--\": 38 /* MinusMinusToken */,\n        \"<<\": 39 /* LessThanLessThanToken */,\n        \">>\": 40 /* GreaterThanGreaterThanToken */,\n        \">>>\": 41 /* GreaterThanGreaterThanGreaterThanToken */,\n        \"&\": 42 /* AmpersandToken */,\n        \"|\": 43 /* BarToken */,\n        \"^\": 44 /* CaretToken */,\n        \"!\": 45 /* ExclamationToken */,\n        \"~\": 46 /* TildeToken */,\n        \"&&\": 47 /* AmpersandAmpersandToken */,\n        \"||\": 48 /* BarBarToken */,\n        \"?\": 49 /* QuestionToken */,\n        \":\": 50 /* ColonToken */,\n        \"=\": 51 /* EqualsToken */,\n        \"+=\": 52 /* PlusEqualsToken */,\n        \"-=\": 53 /* MinusEqualsToken */,\n        \"*=\": 54 /* AsteriskEqualsToken */,\n        \"/=\": 55 /* SlashEqualsToken */,\n        \"%=\": 56 /* PercentEqualsToken */,\n        \"<<=\": 57 /* LessThanLessThanEqualsToken */,\n        \">>=\": 58 /* GreaterThanGreaterThanEqualsToken */,\n        \">>>=\": 59 /* GreaterThanGreaterThanGreaterThanEqualsToken */,\n        \"&=\": 60 /* AmpersandEqualsToken */,\n        \"|=\": 61 /* BarEqualsToken */,\n        \"^=\": 62 /* CaretEqualsToken */,\n    };\n    /*\n        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers\n        IdentifierStart ::\n            Can contain Unicode 3.0.0  categories:\n            Uppercase letter (Lu),\n            Lowercase letter (Ll),\n            Titlecase letter (Lt),\n            Modifier letter (Lm),\n            Other letter (Lo), or\n            Letter number (Nl).\n        IdentifierPart :: =\n            Can contain IdentifierStart + Unicode 3.0.0  categories:\n            Non-spacing mark (Mn),\n            Combining spacing mark (Mc),\n            Decimal number (Nd), or\n            Connector punctuation (Pc).\n\n        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:\n        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt\n    */\n    var unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];\n    var unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];\n    /*\n        As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers\n        IdentifierStart ::\n            Can contain Unicode 6.2  categories:\n            Uppercase letter (Lu),\n            Lowercase letter (Ll),\n            Titlecase letter (Lt),\n            Modifier letter (Lm),\n            Other letter (Lo), or\n            Letter number (Nl).\n        IdentifierPart ::\n            Can contain IdentifierStart + Unicode 6.2  categories:\n            Non-spacing mark (Mn),\n            Combining spacing mark (Mc),\n            Decimal number (Nd),\n            Connector punctuation (Pc),\n            <ZWNJ>, or\n            <ZWJ>.\n\n        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:\n        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt\n    */\n    var unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];\n    var unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];\n    function lookupInUnicodeMap(code, map) {\n        // Bail out quickly if it couldn't possibly be in the map.\n        if (code < map[0]) {\n            return false;\n        }\n        // Perform binary search in one of the Unicode range maps\n        var lo = 0;\n        var hi = map.length;\n        var mid;\n        while (lo + 1 < hi) {\n            mid = lo + (hi - lo) / 2;\n            // mid has to be even to catch a range's beginning\n            mid -= mid % 2;\n            if (map[mid] <= code && code <= map[mid + 1]) {\n                return true;\n            }\n            if (code < map[mid]) {\n                hi = mid;\n            }\n            else {\n                lo = mid + 2;\n            }\n        }\n        return false;\n    }\n    function isUnicodeIdentifierStart(code, languageVersion) {\n        return languageVersion === 0 /* ES3 */ ? lookupInUnicodeMap(code, unicodeES3IdentifierStart) : lookupInUnicodeMap(code, unicodeES5IdentifierStart);\n    }\n    function isUnicodeIdentifierPart(code, languageVersion) {\n        return languageVersion === 0 /* ES3 */ ? lookupInUnicodeMap(code, unicodeES3IdentifierPart) : lookupInUnicodeMap(code, unicodeES5IdentifierPart);\n    }\n    function makeReverseMap(source) {\n        var result = [];\n        for (var name in source) {\n            if (source.hasOwnProperty(name)) {\n                result[source[name]] = name;\n            }\n        }\n        return result;\n    }\n    var tokenStrings = makeReverseMap(textToToken);\n    function tokenToString(t) {\n        return tokenStrings[t];\n    }\n    ts.tokenToString = tokenToString;\n    function computeLineStarts(text) {\n        var result = new Array();\n        var pos = 0;\n        var lineStart = 0;\n        while (pos < text.length) {\n            var ch = text.charCodeAt(pos++);\n            switch (ch) {\n                case 13 /* carriageReturn */:\n                    if (text.charCodeAt(pos) === 10 /* lineFeed */) {\n                        pos++;\n                    }\n                case 10 /* lineFeed */:\n                    result.push(lineStart);\n                    lineStart = pos;\n                    break;\n                default:\n                    if (ch > 127 /* maxAsciiCharacter */ && isLineBreak(ch)) {\n                        result.push(lineStart);\n                        lineStart = pos;\n                    }\n                    break;\n            }\n        }\n        result.push(lineStart);\n        return result;\n    }\n    ts.computeLineStarts = computeLineStarts;\n    function getPositionFromLineAndCharacter(lineStarts, line, character) {\n        ts.Debug.assert(line > 0);\n        return lineStarts[line - 1] + character - 1;\n    }\n    ts.getPositionFromLineAndCharacter = getPositionFromLineAndCharacter;\n    function getLineAndCharacterOfPosition(lineStarts, position) {\n        var lineNumber = ts.binarySearch(lineStarts, position);\n        if (lineNumber < 0) {\n            // If the actual position was not found, \n            // the binary search returns the negative value of the next line start\n            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20\n            // then the search will return -2\n            lineNumber = (~lineNumber) - 1;\n        }\n        return {\n            line: lineNumber + 1,\n            character: position - lineStarts[lineNumber] + 1\n        };\n    }\n    ts.getLineAndCharacterOfPosition = getLineAndCharacterOfPosition;\n    function positionToLineAndCharacter(text, pos) {\n        var lineStarts = computeLineStarts(text);\n        return getLineAndCharacterOfPosition(lineStarts, pos);\n    }\n    ts.positionToLineAndCharacter = positionToLineAndCharacter;\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    function isWhiteSpace(ch) {\n        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ || ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ || ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n    }\n    ts.isWhiteSpace = isWhiteSpace;\n    function isLineBreak(ch) {\n        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */ || ch === 133 /* nextLine */;\n    }\n    ts.isLineBreak = isLineBreak;\n    function isDigit(ch) {\n        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n    }\n    function isOctalDigit(ch) {\n        return ch >= 48 /* _0 */ && ch <= 55 /* _7 */;\n    }\n    ts.isOctalDigit = isOctalDigit;\n    function skipTrivia(text, pos, stopAfterLineBreak) {\n        while (true) {\n            var ch = text.charCodeAt(pos);\n            switch (ch) {\n                case 13 /* carriageReturn */:\n                    if (text.charCodeAt(pos + 1) === 10 /* lineFeed */)\n                        pos++;\n                case 10 /* lineFeed */:\n                    pos++;\n                    if (stopAfterLineBreak)\n                        return pos;\n                    continue;\n                case 9 /* tab */:\n                case 11 /* verticalTab */:\n                case 12 /* formFeed */:\n                case 32 /* space */:\n                    pos++;\n                    continue;\n                case 47 /* slash */:\n                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                        pos += 2;\n                        while (pos < text.length) {\n                            if (isLineBreak(text.charCodeAt(pos))) {\n                                break;\n                            }\n                            pos++;\n                        }\n                        continue;\n                    }\n                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                        pos += 2;\n                        while (pos < text.length) {\n                            if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                                pos += 2;\n                                break;\n                            }\n                            pos++;\n                        }\n                        continue;\n                    }\n                    break;\n                default:\n                    if (ch > 127 /* maxAsciiCharacter */ && (isWhiteSpace(ch) || isLineBreak(ch))) {\n                        pos++;\n                        continue;\n                    }\n                    break;\n            }\n            return pos;\n        }\n    }\n    ts.skipTrivia = skipTrivia;\n    // Extract comments from the given source text starting at the given position. If trailing is false, whitespace is skipped until\n    // the first line break and comments between that location and the next token are returned. If trailing is true, comments occurring\n    // between the given position and the next line break are returned. The return value is an array containing a TextRange for each\n    // comment. Single-line comment ranges include the beginning '//' characters but not the ending line break. Multi-line comment\n    // ranges include the beginning '/* and ending '*/' characters. The return value is undefined if no comments were found.\n    function getCommentRanges(text, pos, trailing) {\n        var result;\n        var collecting = trailing || pos === 0;\n        while (true) {\n            var ch = text.charCodeAt(pos);\n            switch (ch) {\n                case 13 /* carriageReturn */:\n                    if (text.charCodeAt(pos + 1) === 10 /* lineFeed */)\n                        pos++;\n                case 10 /* lineFeed */:\n                    pos++;\n                    if (trailing) {\n                        return result;\n                    }\n                    collecting = true;\n                    if (result && result.length) {\n                        result[result.length - 1].hasTrailingNewLine = true;\n                    }\n                    continue;\n                case 9 /* tab */:\n                case 11 /* verticalTab */:\n                case 12 /* formFeed */:\n                case 32 /* space */:\n                    pos++;\n                    continue;\n                case 47 /* slash */:\n                    var nextChar = text.charCodeAt(pos + 1);\n                    var hasTrailingNewLine = false;\n                    if (nextChar === 47 /* slash */ || nextChar === 42 /* asterisk */) {\n                        var startPos = pos;\n                        pos += 2;\n                        if (nextChar === 47 /* slash */) {\n                            while (pos < text.length) {\n                                if (isLineBreak(text.charCodeAt(pos))) {\n                                    hasTrailingNewLine = true;\n                                    break;\n                                }\n                                pos++;\n                            }\n                        }\n                        else {\n                            while (pos < text.length) {\n                                if (text.charCodeAt(pos) === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                                    pos += 2;\n                                    break;\n                                }\n                                pos++;\n                            }\n                        }\n                        if (collecting) {\n                            if (!result)\n                                result = [];\n                            result.push({ pos: startPos, end: pos, hasTrailingNewLine: hasTrailingNewLine });\n                        }\n                        continue;\n                    }\n                    break;\n                default:\n                    if (ch > 127 /* maxAsciiCharacter */ && (isWhiteSpace(ch) || isLineBreak(ch))) {\n                        if (result && result.length && isLineBreak(ch)) {\n                            result[result.length - 1].hasTrailingNewLine = true;\n                        }\n                        pos++;\n                        continue;\n                    }\n                    break;\n            }\n            return result;\n        }\n    }\n    function getLeadingCommentRanges(text, pos) {\n        return getCommentRanges(text, pos, false);\n    }\n    ts.getLeadingCommentRanges = getLeadingCommentRanges;\n    function getTrailingCommentRanges(text, pos) {\n        return getCommentRanges(text, pos, true);\n    }\n    ts.getTrailingCommentRanges = getTrailingCommentRanges;\n    function isIdentifierStart(ch, languageVersion) {\n        return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);\n    }\n    ts.isIdentifierStart = isIdentifierStart;\n    function isIdentifierPart(ch, languageVersion) {\n        return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);\n    }\n    ts.isIdentifierPart = isIdentifierPart;\n    function createScanner(languageVersion, skipTrivia, text, onError) {\n        var pos; // Current position (end position of text of current token)\n        var len; // Length of text\n        var startPos; // Start position of whitespace before current token\n        var tokenPos; // Start position of text of current token\n        var token;\n        var tokenValue;\n        var precedingLineBreak;\n        var tokenIsUnterminated;\n        function error(message) {\n            if (onError) {\n                onError(message);\n            }\n        }\n        function isIdentifierStart(ch) {\n            return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);\n        }\n        function isIdentifierPart(ch) {\n            return ch >= 65 /* A */ && ch <= 90 /* Z */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 48 /* _0 */ && ch <= 57 /* _9 */ || ch === 36 /* $ */ || ch === 95 /* _ */ || ch > 127 /* maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);\n        }\n        function scanNumber() {\n            var start = pos;\n            while (isDigit(text.charCodeAt(pos)))\n                pos++;\n            if (text.charCodeAt(pos) === 46 /* dot */) {\n                pos++;\n                while (isDigit(text.charCodeAt(pos)))\n                    pos++;\n            }\n            var end = pos;\n            if (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */) {\n                pos++;\n                if (text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */)\n                    pos++;\n                if (isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                    while (isDigit(text.charCodeAt(pos)))\n                        pos++;\n                    end = pos;\n                }\n                else {\n                    error(ts.Diagnostics.Digit_expected);\n                }\n            }\n            return +(text.substring(start, end));\n        }\n        function scanOctalDigits() {\n            var start = pos;\n            while (isOctalDigit(text.charCodeAt(pos))) {\n                pos++;\n            }\n            return +(text.substring(start, pos));\n        }\n        function scanHexDigits(count, mustMatchCount) {\n            var digits = 0;\n            var value = 0;\n            while (digits < count || !mustMatchCount) {\n                var ch = text.charCodeAt(pos);\n                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                    value = value * 16 + ch - 48 /* _0 */;\n                }\n                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                    value = value * 16 + ch - 65 /* A */ + 10;\n                }\n                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                    value = value * 16 + ch - 97 /* a */ + 10;\n                }\n                else {\n                    break;\n                }\n                pos++;\n                digits++;\n            }\n            if (digits < count) {\n                value = -1;\n            }\n            return value;\n        }\n        function scanString() {\n            var quote = text.charCodeAt(pos++);\n            var result = \"\";\n            var start = pos;\n            while (true) {\n                if (pos >= len) {\n                    result += text.substring(start, pos);\n                    tokenIsUnterminated = true;\n                    error(ts.Diagnostics.Unterminated_string_literal);\n                    break;\n                }\n                var ch = text.charCodeAt(pos);\n                if (ch === quote) {\n                    result += text.substring(start, pos);\n                    pos++;\n                    break;\n                }\n                if (ch === 92 /* backslash */) {\n                    result += text.substring(start, pos);\n                    result += scanEscapeSequence();\n                    start = pos;\n                    continue;\n                }\n                if (isLineBreak(ch)) {\n                    result += text.substring(start, pos);\n                    tokenIsUnterminated = true;\n                    error(ts.Diagnostics.Unterminated_string_literal);\n                    break;\n                }\n                pos++;\n            }\n            return result;\n        }\n        /**\n         * Sets the current 'tokenValue' and returns a NoSubstitutionTemplateLiteral or\n         * a literal component of a TemplateExpression.\n         */\n        function scanTemplateAndSetTokenValue() {\n            var startedWithBacktick = text.charCodeAt(pos) === 96 /* backtick */;\n            pos++;\n            var start = pos;\n            var contents = \"\";\n            var resultingToken;\n            while (true) {\n                if (pos >= len) {\n                    contents += text.substring(start, pos);\n                    tokenIsUnterminated = true;\n                    error(ts.Diagnostics.Unterminated_template_literal);\n                    resultingToken = startedWithBacktick ? 9 /* NoSubstitutionTemplateLiteral */ : 12 /* TemplateTail */;\n                    break;\n                }\n                var currChar = text.charCodeAt(pos);\n                // '`'\n                if (currChar === 96 /* backtick */) {\n                    contents += text.substring(start, pos);\n                    pos++;\n                    resultingToken = startedWithBacktick ? 9 /* NoSubstitutionTemplateLiteral */ : 12 /* TemplateTail */;\n                    break;\n                }\n                // '${'\n                if (currChar === 36 /* $ */ && pos + 1 < len && text.charCodeAt(pos + 1) === 123 /* openBrace */) {\n                    contents += text.substring(start, pos);\n                    pos += 2;\n                    resultingToken = startedWithBacktick ? 10 /* TemplateHead */ : 11 /* TemplateMiddle */;\n                    break;\n                }\n                // Escape character\n                if (currChar === 92 /* backslash */) {\n                    contents += text.substring(start, pos);\n                    contents += scanEscapeSequence();\n                    start = pos;\n                    continue;\n                }\n                // Speculated ECMAScript 6 Spec 11.8.6.1:\n                // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for Template Values\n                // An explicit EscapeSequence is needed to include a <CR> or <CR><LF> sequence.\n                if (currChar === 13 /* carriageReturn */) {\n                    contents += text.substring(start, pos);\n                    if (pos + 1 < len && text.charCodeAt(pos + 1) === 10 /* lineFeed */) {\n                        pos++;\n                    }\n                    pos++;\n                    contents += \"\\n\";\n                    start = pos;\n                    continue;\n                }\n                pos++;\n            }\n            ts.Debug.assert(resultingToken !== undefined);\n            tokenValue = contents;\n            return resultingToken;\n        }\n        function scanEscapeSequence() {\n            pos++;\n            if (pos >= len) {\n                error(ts.Diagnostics.Unexpected_end_of_text);\n                return \"\";\n            }\n            var ch = text.charCodeAt(pos++);\n            switch (ch) {\n                case 48 /* _0 */:\n                    return \"\\0\";\n                case 98 /* b */:\n                    return \"\\b\";\n                case 116 /* t */:\n                    return \"\\t\";\n                case 110 /* n */:\n                    return \"\\n\";\n                case 118 /* v */:\n                    return \"\\v\";\n                case 102 /* f */:\n                    return \"\\f\";\n                case 114 /* r */:\n                    return \"\\r\";\n                case 39 /* singleQuote */:\n                    return \"\\'\";\n                case 34 /* doubleQuote */:\n                    return \"\\\"\";\n                case 120 /* x */:\n                case 117 /* u */:\n                    var ch = scanHexDigits(ch === 120 /* x */ ? 2 : 4, true);\n                    if (ch >= 0) {\n                        return String.fromCharCode(ch);\n                    }\n                    else {\n                        error(ts.Diagnostics.Hexadecimal_digit_expected);\n                        return \"\";\n                    }\n                case 13 /* carriageReturn */:\n                    if (pos < len && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                        pos++;\n                    }\n                case 10 /* lineFeed */:\n                case 8232 /* lineSeparator */:\n                case 8233 /* paragraphSeparator */:\n                    return \"\";\n                default:\n                    return String.fromCharCode(ch);\n            }\n        }\n        // Current character is known to be a backslash. Check for Unicode escape of the form '\\uXXXX'\n        // and return code point value if valid Unicode escape is found. Otherwise return -1.\n        function peekUnicodeEscape() {\n            if (pos + 5 < len && text.charCodeAt(pos + 1) === 117 /* u */) {\n                var start = pos;\n                pos += 2;\n                var value = scanHexDigits(4, true);\n                pos = start;\n                return value;\n            }\n            return -1;\n        }\n        function scanIdentifierParts() {\n            var result = \"\";\n            var start = pos;\n            while (pos < len) {\n                var ch = text.charCodeAt(pos);\n                if (isIdentifierPart(ch)) {\n                    pos++;\n                }\n                else if (ch === 92 /* backslash */) {\n                    ch = peekUnicodeEscape();\n                    if (!(ch >= 0 && isIdentifierPart(ch))) {\n                        break;\n                    }\n                    result += text.substring(start, pos);\n                    result += String.fromCharCode(ch);\n                    // Valid Unicode escape is always six characters\n                    pos += 6;\n                    start = pos;\n                }\n                else {\n                    break;\n                }\n            }\n            result += text.substring(start, pos);\n            return result;\n        }\n        function getIdentifierToken() {\n            // Reserved words are between 2 and 11 characters long and start with a lowercase letter\n            var len = tokenValue.length;\n            if (len >= 2 && len <= 11) {\n                var ch = tokenValue.charCodeAt(0);\n                if (ch >= 97 /* a */ && ch <= 122 /* z */ && hasOwnProperty.call(textToToken, tokenValue)) {\n                    return token = textToToken[tokenValue];\n                }\n            }\n            return token = 63 /* Identifier */;\n        }\n        function scanBinaryOrOctalDigits(base) {\n            ts.Debug.assert(base !== 2 || base !== 8, \"Expected either base 2 or base 8\");\n            var value = 0;\n            // For counting number of digits; Valid binaryIntegerLiteral must have at least one binary digit following B or b.\n            // Similarly valid octalIntegerLiteral must have at least one octal digit following o or O.\n            var numberOfDigits = 0;\n            while (true) {\n                var ch = text.charCodeAt(pos);\n                var valueOfCh = ch - 48 /* _0 */;\n                if (!isDigit(ch) || valueOfCh >= base) {\n                    break;\n                }\n                value = value * base + valueOfCh;\n                pos++;\n                numberOfDigits++;\n            }\n            // Invalid binaryIntegerLiteral or octalIntegerLiteral\n            if (numberOfDigits === 0) {\n                return -1;\n            }\n            return value;\n        }\n        function scan() {\n            startPos = pos;\n            precedingLineBreak = false;\n            tokenIsUnterminated = false;\n            while (true) {\n                tokenPos = pos;\n                if (pos >= len) {\n                    return token = 1 /* EndOfFileToken */;\n                }\n                var ch = text.charCodeAt(pos);\n                switch (ch) {\n                    case 10 /* lineFeed */:\n                    case 13 /* carriageReturn */:\n                        precedingLineBreak = true;\n                        if (skipTrivia) {\n                            pos++;\n                            continue;\n                        }\n                        else {\n                            if (ch === 13 /* carriageReturn */ && pos + 1 < len && text.charCodeAt(pos + 1) === 10 /* lineFeed */) {\n                                // consume both CR and LF\n                                pos += 2;\n                            }\n                            else {\n                                pos++;\n                            }\n                            return token = 4 /* NewLineTrivia */;\n                        }\n                    case 9 /* tab */:\n                    case 11 /* verticalTab */:\n                    case 12 /* formFeed */:\n                    case 32 /* space */:\n                        if (skipTrivia) {\n                            pos++;\n                            continue;\n                        }\n                        else {\n                            while (pos < len && isWhiteSpace(text.charCodeAt(pos))) {\n                                pos++;\n                            }\n                            return token = 5 /* WhitespaceTrivia */;\n                        }\n                    case 33 /* exclamation */:\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {\n                                return pos += 3, token = 30 /* ExclamationEqualsEqualsToken */;\n                            }\n                            return pos += 2, token = 28 /* ExclamationEqualsToken */;\n                        }\n                        return pos++, token = 45 /* ExclamationToken */;\n                    case 34 /* doubleQuote */:\n                    case 39 /* singleQuote */:\n                        tokenValue = scanString();\n                        return token = 7 /* StringLiteral */;\n                    case 96 /* backtick */:\n                        return token = scanTemplateAndSetTokenValue();\n                    case 37 /* percent */:\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 56 /* PercentEqualsToken */;\n                        }\n                        return pos++, token = 36 /* PercentToken */;\n                    case 38 /* ampersand */:\n                        if (text.charCodeAt(pos + 1) === 38 /* ampersand */) {\n                            return pos += 2, token = 47 /* AmpersandAmpersandToken */;\n                        }\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 60 /* AmpersandEqualsToken */;\n                        }\n                        return pos++, token = 42 /* AmpersandToken */;\n                    case 40 /* openParen */:\n                        return pos++, token = 15 /* OpenParenToken */;\n                    case 41 /* closeParen */:\n                        return pos++, token = 16 /* CloseParenToken */;\n                    case 42 /* asterisk */:\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 54 /* AsteriskEqualsToken */;\n                        }\n                        return pos++, token = 34 /* AsteriskToken */;\n                    case 43 /* plus */:\n                        if (text.charCodeAt(pos + 1) === 43 /* plus */) {\n                            return pos += 2, token = 37 /* PlusPlusToken */;\n                        }\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 52 /* PlusEqualsToken */;\n                        }\n                        return pos++, token = 32 /* PlusToken */;\n                    case 44 /* comma */:\n                        return pos++, token = 22 /* CommaToken */;\n                    case 45 /* minus */:\n                        if (text.charCodeAt(pos + 1) === 45 /* minus */) {\n                            return pos += 2, token = 38 /* MinusMinusToken */;\n                        }\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 53 /* MinusEqualsToken */;\n                        }\n                        return pos++, token = 33 /* MinusToken */;\n                    case 46 /* dot */:\n                        if (isDigit(text.charCodeAt(pos + 1))) {\n                            tokenValue = \"\" + scanNumber();\n                            return token = 6 /* NumericLiteral */;\n                        }\n                        if (text.charCodeAt(pos + 1) === 46 /* dot */ && text.charCodeAt(pos + 2) === 46 /* dot */) {\n                            return pos += 3, token = 20 /* DotDotDotToken */;\n                        }\n                        return pos++, token = 19 /* DotToken */;\n                    case 47 /* slash */:\n                        // Single-line comment\n                        if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                            pos += 2;\n                            while (pos < len) {\n                                if (isLineBreak(text.charCodeAt(pos))) {\n                                    break;\n                                }\n                                pos++;\n                            }\n                            if (skipTrivia) {\n                                continue;\n                            }\n                            else {\n                                return token = 2 /* SingleLineCommentTrivia */;\n                            }\n                        }\n                        // Multi-line comment\n                        if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                            pos += 2;\n                            var commentClosed = false;\n                            while (pos < len) {\n                                var ch = text.charCodeAt(pos);\n                                if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                                    pos += 2;\n                                    commentClosed = true;\n                                    break;\n                                }\n                                if (isLineBreak(ch)) {\n                                    precedingLineBreak = true;\n                                }\n                                pos++;\n                            }\n                            if (!commentClosed) {\n                                error(ts.Diagnostics.Asterisk_Slash_expected);\n                            }\n                            if (skipTrivia) {\n                                continue;\n                            }\n                            else {\n                                tokenIsUnterminated = !commentClosed;\n                                return token = 3 /* MultiLineCommentTrivia */;\n                            }\n                        }\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 55 /* SlashEqualsToken */;\n                        }\n                        return pos++, token = 35 /* SlashToken */;\n                    case 48 /* _0 */:\n                        if (pos + 2 < len && (text.charCodeAt(pos + 1) === 88 /* X */ || text.charCodeAt(pos + 1) === 120 /* x */)) {\n                            pos += 2;\n                            var value = scanHexDigits(1, false);\n                            if (value < 0) {\n                                error(ts.Diagnostics.Hexadecimal_digit_expected);\n                                value = 0;\n                            }\n                            tokenValue = \"\" + value;\n                            return token = 6 /* NumericLiteral */;\n                        }\n                        else if (pos + 2 < len && (text.charCodeAt(pos + 1) === 66 /* B */ || text.charCodeAt(pos + 1) === 98 /* b */)) {\n                            pos += 2;\n                            var value = scanBinaryOrOctalDigits(2);\n                            if (value < 0) {\n                                error(ts.Diagnostics.Binary_digit_expected);\n                                value = 0;\n                            }\n                            tokenValue = \"\" + value;\n                            return 6 /* NumericLiteral */;\n                        }\n                        else if (pos + 2 < len && (text.charCodeAt(pos + 1) === 79 /* O */ || text.charCodeAt(pos + 1) === 111 /* o */)) {\n                            pos += 2;\n                            var value = scanBinaryOrOctalDigits(8);\n                            if (value < 0) {\n                                error(ts.Diagnostics.Octal_digit_expected);\n                                value = 0;\n                            }\n                            tokenValue = \"\" + value;\n                            return 6 /* NumericLiteral */;\n                        }\n                        // Try to parse as an octal\n                        if (pos + 1 < len && isOctalDigit(text.charCodeAt(pos + 1))) {\n                            tokenValue = \"\" + scanOctalDigits();\n                            return token = 6 /* NumericLiteral */;\n                        }\n                    case 49 /* _1 */:\n                    case 50 /* _2 */:\n                    case 51 /* _3 */:\n                    case 52 /* _4 */:\n                    case 53 /* _5 */:\n                    case 54 /* _6 */:\n                    case 55 /* _7 */:\n                    case 56 /* _8 */:\n                    case 57 /* _9 */:\n                        tokenValue = \"\" + scanNumber();\n                        return token = 6 /* NumericLiteral */;\n                    case 58 /* colon */:\n                        return pos++, token = 50 /* ColonToken */;\n                    case 59 /* semicolon */:\n                        return pos++, token = 21 /* SemicolonToken */;\n                    case 60 /* lessThan */:\n                        if (text.charCodeAt(pos + 1) === 60 /* lessThan */) {\n                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {\n                                return pos += 3, token = 57 /* LessThanLessThanEqualsToken */;\n                            }\n                            return pos += 2, token = 39 /* LessThanLessThanToken */;\n                        }\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 25 /* LessThanEqualsToken */;\n                        }\n                        return pos++, token = 23 /* LessThanToken */;\n                    case 61 /* equals */:\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            if (text.charCodeAt(pos + 2) === 61 /* equals */) {\n                                return pos += 3, token = 29 /* EqualsEqualsEqualsToken */;\n                            }\n                            return pos += 2, token = 27 /* EqualsEqualsToken */;\n                        }\n                        if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {\n                            return pos += 2, token = 31 /* EqualsGreaterThanToken */;\n                        }\n                        return pos++, token = 51 /* EqualsToken */;\n                    case 62 /* greaterThan */:\n                        return pos++, token = 24 /* GreaterThanToken */;\n                    case 63 /* question */:\n                        return pos++, token = 49 /* QuestionToken */;\n                    case 91 /* openBracket */:\n                        return pos++, token = 17 /* OpenBracketToken */;\n                    case 93 /* closeBracket */:\n                        return pos++, token = 18 /* CloseBracketToken */;\n                    case 94 /* caret */:\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 62 /* CaretEqualsToken */;\n                        }\n                        return pos++, token = 44 /* CaretToken */;\n                    case 123 /* openBrace */:\n                        return pos++, token = 13 /* OpenBraceToken */;\n                    case 124 /* bar */:\n                        if (text.charCodeAt(pos + 1) === 124 /* bar */) {\n                            return pos += 2, token = 48 /* BarBarToken */;\n                        }\n                        if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                            return pos += 2, token = 61 /* BarEqualsToken */;\n                        }\n                        return pos++, token = 43 /* BarToken */;\n                    case 125 /* closeBrace */:\n                        return pos++, token = 14 /* CloseBraceToken */;\n                    case 126 /* tilde */:\n                        return pos++, token = 46 /* TildeToken */;\n                    case 92 /* backslash */:\n                        var ch = peekUnicodeEscape();\n                        if (ch >= 0 && isIdentifierStart(ch)) {\n                            pos += 6;\n                            tokenValue = String.fromCharCode(ch) + scanIdentifierParts();\n                            return token = getIdentifierToken();\n                        }\n                        error(ts.Diagnostics.Invalid_character);\n                        return pos++, token = 0 /* Unknown */;\n                    default:\n                        if (isIdentifierStart(ch)) {\n                            pos++;\n                            while (pos < len && isIdentifierPart(ch = text.charCodeAt(pos)))\n                                pos++;\n                            tokenValue = text.substring(tokenPos, pos);\n                            if (ch === 92 /* backslash */) {\n                                tokenValue += scanIdentifierParts();\n                            }\n                            return token = getIdentifierToken();\n                        }\n                        else if (isWhiteSpace(ch)) {\n                            pos++;\n                            continue;\n                        }\n                        else if (isLineBreak(ch)) {\n                            precedingLineBreak = true;\n                            pos++;\n                            continue;\n                        }\n                        error(ts.Diagnostics.Invalid_character);\n                        return pos++, token = 0 /* Unknown */;\n                }\n            }\n        }\n        function reScanGreaterToken() {\n            if (token === 24 /* GreaterThanToken */) {\n                if (text.charCodeAt(pos) === 62 /* greaterThan */) {\n                    if (text.charCodeAt(pos + 1) === 62 /* greaterThan */) {\n                        if (text.charCodeAt(pos + 2) === 61 /* equals */) {\n                            return pos += 3, token = 59 /* GreaterThanGreaterThanGreaterThanEqualsToken */;\n                        }\n                        return pos += 2, token = 41 /* GreaterThanGreaterThanGreaterThanToken */;\n                    }\n                    if (text.charCodeAt(pos + 1) === 61 /* equals */) {\n                        return pos += 2, token = 58 /* GreaterThanGreaterThanEqualsToken */;\n                    }\n                    return pos++, token = 40 /* GreaterThanGreaterThanToken */;\n                }\n                if (text.charCodeAt(pos) === 61 /* equals */) {\n                    return pos++, token = 26 /* GreaterThanEqualsToken */;\n                }\n            }\n            return token;\n        }\n        function reScanSlashToken() {\n            if (token === 35 /* SlashToken */ || token === 55 /* SlashEqualsToken */) {\n                var p = tokenPos + 1;\n                var inEscape = false;\n                var inCharacterClass = false;\n                while (true) {\n                    // If we reach the end of a file, or hit a newline, then this is an unterminated\n                    // regex.  Report error and return what we have so far.\n                    if (p >= len) {\n                        tokenIsUnterminated = true;\n                        error(ts.Diagnostics.Unterminated_regular_expression_literal);\n                        break;\n                    }\n                    var ch = text.charCodeAt(p);\n                    if (isLineBreak(ch)) {\n                        tokenIsUnterminated = true;\n                        error(ts.Diagnostics.Unterminated_regular_expression_literal);\n                        break;\n                    }\n                    if (inEscape) {\n                        // Parsing an escape character;\n                        // reset the flag and just advance to the next char.\n                        inEscape = false;\n                    }\n                    else if (ch === 47 /* slash */ && !inCharacterClass) {\n                        // A slash within a character class is permissible,\n                        // but in general it signals the end of the regexp literal.\n                        p++;\n                        break;\n                    }\n                    else if (ch === 91 /* openBracket */) {\n                        inCharacterClass = true;\n                    }\n                    else if (ch === 92 /* backslash */) {\n                        inEscape = true;\n                    }\n                    else if (ch === 93 /* closeBracket */) {\n                        inCharacterClass = false;\n                    }\n                    p++;\n                }\n                while (p < len && isIdentifierPart(text.charCodeAt(p))) {\n                    p++;\n                }\n                pos = p;\n                tokenValue = text.substring(tokenPos, pos);\n                token = 8 /* RegularExpressionLiteral */;\n            }\n            return token;\n        }\n        /**\n         * Unconditionally back up and scan a template expression portion.\n         */\n        function reScanTemplateToken() {\n            ts.Debug.assert(token === 14 /* CloseBraceToken */, \"'reScanTemplateToken' should only be called on a '}'\");\n            pos = tokenPos;\n            return token = scanTemplateAndSetTokenValue();\n        }\n        function speculationHelper(callback, isLookahead) {\n            var savePos = pos;\n            var saveStartPos = startPos;\n            var saveTokenPos = tokenPos;\n            var saveToken = token;\n            var saveTokenValue = tokenValue;\n            var savePrecedingLineBreak = precedingLineBreak;\n            var result = callback();\n            // If our callback returned something 'falsy' or we're just looking ahead,\n            // then unconditionally restore us to where we were.\n            if (!result || isLookahead) {\n                pos = savePos;\n                startPos = saveStartPos;\n                tokenPos = saveTokenPos;\n                token = saveToken;\n                tokenValue = saveTokenValue;\n                precedingLineBreak = savePrecedingLineBreak;\n            }\n            return result;\n        }\n        function lookAhead(callback) {\n            return speculationHelper(callback, true);\n        }\n        function tryScan(callback) {\n            return speculationHelper(callback, false);\n        }\n        function setText(newText) {\n            text = newText || \"\";\n            len = text.length;\n            setTextPos(0);\n        }\n        function setTextPos(textPos) {\n            pos = textPos;\n            startPos = textPos;\n            tokenPos = textPos;\n            token = 0 /* Unknown */;\n            precedingLineBreak = false;\n        }\n        setText(text);\n        return {\n            getStartPos: function () { return startPos; },\n            getTextPos: function () { return pos; },\n            getToken: function () { return token; },\n            getTokenPos: function () { return tokenPos; },\n            getTokenText: function () { return text.substring(tokenPos, pos); },\n            getTokenValue: function () { return tokenValue; },\n            hasPrecedingLineBreak: function () { return precedingLineBreak; },\n            isIdentifier: function () { return token === 63 /* Identifier */ || token > 99 /* LastReservedWord */; },\n            isReservedWord: function () { return token >= 64 /* FirstReservedWord */ && token <= 99 /* LastReservedWord */; },\n            isUnterminated: function () { return tokenIsUnterminated; },\n            reScanGreaterToken: reScanGreaterToken,\n            reScanSlashToken: reScanSlashToken,\n            reScanTemplateToken: reScanTemplateToken,\n            scan: scan,\n            setText: setText,\n            setTextPos: setTextPos,\n            tryScan: tryScan,\n            lookAhead: lookAhead,\n        };\n    }\n    ts.createScanner = createScanner;\n})(ts || (ts = {}));\n/// <reference path=\"types.ts\" />\nvar ts;\n(function (ts) {\n    function getDeclarationOfKind(symbol, kind) {\n        var declarations = symbol.declarations;\n        for (var i = 0; i < declarations.length; i++) {\n            var declaration = declarations[i];\n            if (declaration.kind === kind) {\n                return declaration;\n            }\n        }\n        return undefined;\n    }\n    ts.getDeclarationOfKind = getDeclarationOfKind;\n    // Pool writers to avoid needing to allocate them for every symbol we write.\n    var stringWriters = [];\n    function getSingleLineStringWriter() {\n        if (stringWriters.length == 0) {\n            var str = \"\";\n            var writeText = function (text) { return str += text; };\n            return {\n                string: function () { return str; },\n                writeKeyword: writeText,\n                writeOperator: writeText,\n                writePunctuation: writeText,\n                writeSpace: writeText,\n                writeStringLiteral: writeText,\n                writeParameter: writeText,\n                writeSymbol: writeText,\n                // Completely ignore indentation for string writers.  And map newlines to\n                // a single space.\n                writeLine: function () { return str += \" \"; },\n                increaseIndent: function () {\n                },\n                decreaseIndent: function () {\n                },\n                clear: function () { return str = \"\"; },\n                trackSymbol: function () {\n                }\n            };\n        }\n        return stringWriters.pop();\n    }\n    ts.getSingleLineStringWriter = getSingleLineStringWriter;\n    function releaseStringWriter(writer) {\n        writer.clear();\n        stringWriters.push(writer);\n    }\n    ts.releaseStringWriter = releaseStringWriter;\n    function getFullWidth(node) {\n        return node.end - node.pos;\n    }\n    ts.getFullWidth = getFullWidth;\n    function hasFlag(val, flag) {\n        return (val & flag) !== 0;\n    }\n    ts.hasFlag = hasFlag;\n    // Returns true if this node contains a parse error anywhere underneath it.\n    function containsParseError(node) {\n        if (!hasFlag(node.parserContextFlags, 32 /* HasPropagatedChildContainsErrorFlag */)) {\n            // A node is considered to contain a parse error if:\n            //  a) the parser explicitly marked that it had an error\n            //  b) any of it's children reported that it had an error.\n            var val = hasFlag(node.parserContextFlags, 16 /* ContainsError */) || ts.forEachChild(node, containsParseError);\n            // If so, mark ourselves accordingly. \n            if (val) {\n                node.parserContextFlags |= 16 /* ContainsError */;\n            }\n            // Also mark that we've propogated the child information to this node.  This way we can\n            // always consult the bit directly on this node without needing to check its children\n            // again.\n            node.parserContextFlags |= 32 /* HasPropagatedChildContainsErrorFlag */;\n        }\n        return hasFlag(node.parserContextFlags, 16 /* ContainsError */);\n    }\n    ts.containsParseError = containsParseError;\n    function getSourceFileOfNode(node) {\n        while (node && node.kind !== 201 /* SourceFile */) {\n            node = node.parent;\n        }\n        return node;\n    }\n    ts.getSourceFileOfNode = getSourceFileOfNode;\n    // This is a useful function for debugging purposes.\n    function nodePosToString(node) {\n        var file = getSourceFileOfNode(node);\n        var loc = file.getLineAndCharacterFromPosition(node.pos);\n        return file.filename + \"(\" + loc.line + \",\" + loc.character + \")\";\n    }\n    ts.nodePosToString = nodePosToString;\n    function getStartPosOfNode(node) {\n        return node.pos;\n    }\n    ts.getStartPosOfNode = getStartPosOfNode;\n    function isMissingNode(node) {\n        return node.pos === node.end && node.kind !== 1 /* EndOfFileToken */;\n    }\n    ts.isMissingNode = isMissingNode;\n    function getTokenPosOfNode(node, sourceFile) {\n        // With nodes that have no width (i.e. 'Missing' nodes), we actually *don't*\n        // want to skip trivia because this will launch us forward to the next token.\n        if (isMissingNode(node)) {\n            return node.pos;\n        }\n        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos);\n    }\n    ts.getTokenPosOfNode = getTokenPosOfNode;\n    function getSourceTextOfNodeFromSourceFile(sourceFile, node) {\n        if (isMissingNode(node)) {\n            return \"\";\n        }\n        var text = sourceFile.text;\n        return text.substring(ts.skipTrivia(text, node.pos), node.end);\n    }\n    ts.getSourceTextOfNodeFromSourceFile = getSourceTextOfNodeFromSourceFile;\n    function getTextOfNodeFromSourceText(sourceText, node) {\n        if (isMissingNode(node)) {\n            return \"\";\n        }\n        return sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);\n    }\n    ts.getTextOfNodeFromSourceText = getTextOfNodeFromSourceText;\n    function getTextOfNode(node) {\n        return getSourceTextOfNodeFromSourceFile(getSourceFileOfNode(node), node);\n    }\n    ts.getTextOfNode = getTextOfNode;\n    // Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__'\n    function escapeIdentifier(identifier) {\n        return identifier.length >= 2 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ ? \"_\" + identifier : identifier;\n    }\n    ts.escapeIdentifier = escapeIdentifier;\n    // Remove extra underscore from escaped identifier\n    function unescapeIdentifier(identifier) {\n        return identifier.length >= 3 && identifier.charCodeAt(0) === 95 /* _ */ && identifier.charCodeAt(1) === 95 /* _ */ && identifier.charCodeAt(2) === 95 /* _ */ ? identifier.substr(1) : identifier;\n    }\n    ts.unescapeIdentifier = unescapeIdentifier;\n    // Return display name of an identifier\n    // Computed property names will just be emitted as \"[<expr>]\", where <expr> is the source\n    // text of the expression in the computed property.\n    function declarationNameToString(name) {\n        return getFullWidth(name) === 0 ? \"(Missing)\" : getTextOfNode(name);\n    }\n    ts.declarationNameToString = declarationNameToString;\n    function createDiagnosticForNode(node, message, arg0, arg1, arg2) {\n        node = getErrorSpanForNode(node);\n        var file = getSourceFileOfNode(node);\n        var start = getTokenPosOfNode(node, file);\n        var length = node.end - start;\n        return ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2);\n    }\n    ts.createDiagnosticForNode = createDiagnosticForNode;\n    function createDiagnosticForNodeFromMessageChain(node, messageChain, newLine) {\n        node = getErrorSpanForNode(node);\n        var file = getSourceFileOfNode(node);\n        var start = ts.skipTrivia(file.text, node.pos);\n        var length = node.end - start;\n        return ts.flattenDiagnosticChain(file, start, length, messageChain, newLine);\n    }\n    ts.createDiagnosticForNodeFromMessageChain = createDiagnosticForNodeFromMessageChain;\n    function getErrorSpanForNode(node) {\n        var errorSpan;\n        switch (node.kind) {\n            case 183 /* VariableDeclaration */:\n            case 185 /* ClassDeclaration */:\n            case 186 /* InterfaceDeclaration */:\n            case 189 /* ModuleDeclaration */:\n            case 188 /* EnumDeclaration */:\n            case 200 /* EnumMember */:\n                errorSpan = node.name;\n                break;\n        }\n        // We now have the ideal error span, but it may be a node that is optional and absent\n        // (e.g. the name of a function expression), in which case errorSpan will be undefined.\n        // Alternatively, it might be required and missing (e.g. the name of a module), in which\n        // case its pos will equal its end (length 0). In either of these cases, we should fall\n        // back to the original node that the error was issued on.\n        return errorSpan && errorSpan.pos < errorSpan.end ? errorSpan : node;\n    }\n    ts.getErrorSpanForNode = getErrorSpanForNode;\n    function isExternalModule(file) {\n        return file.externalModuleIndicator !== undefined;\n    }\n    ts.isExternalModule = isExternalModule;\n    function isDeclarationFile(file) {\n        return (file.flags & 1024 /* DeclarationFile */) !== 0;\n    }\n    ts.isDeclarationFile = isDeclarationFile;\n    function isConstEnumDeclaration(node) {\n        return node.kind === 188 /* EnumDeclaration */ && isConst(node);\n    }\n    ts.isConstEnumDeclaration = isConstEnumDeclaration;\n    function isConst(node) {\n        return !!(node.flags & 4096 /* Const */);\n    }\n    ts.isConst = isConst;\n    function isLet(node) {\n        return !!(node.flags & 2048 /* Let */);\n    }\n    ts.isLet = isLet;\n    function isPrologueDirective(node) {\n        return node.kind === 166 /* ExpressionStatement */ && node.expression.kind === 7 /* StringLiteral */;\n    }\n    ts.isPrologueDirective = isPrologueDirective;\n    function getLeadingCommentRangesOfNode(node, sourceFileOfNode) {\n        sourceFileOfNode = sourceFileOfNode || getSourceFileOfNode(node);\n        // If parameter/type parameter, the prev token trailing comments are part of this node too\n        if (node.kind === 123 /* Parameter */ || node.kind === 122 /* TypeParameter */) {\n            // e.g.   (/** blah */ a, /** blah */ b);\n            return ts.concatenate(ts.getTrailingCommentRanges(sourceFileOfNode.text, node.pos), ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos));\n        }\n        else {\n            return ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos);\n        }\n    }\n    ts.getLeadingCommentRangesOfNode = getLeadingCommentRangesOfNode;\n    function getJsDocComments(node, sourceFileOfNode) {\n        return ts.filter(getLeadingCommentRangesOfNode(node, sourceFileOfNode), isJsDocComment);\n        function isJsDocComment(comment) {\n            // True if the comment starts with '/**' but not if it is '/**/'\n            return sourceFileOfNode.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */ && sourceFileOfNode.text.charCodeAt(comment.pos + 2) === 42 /* asterisk */ && sourceFileOfNode.text.charCodeAt(comment.pos + 3) !== 47 /* slash */;\n        }\n    }\n    ts.getJsDocComments = getJsDocComments;\n    ts.fullTripleSlashReferencePathRegEx = /^(\\/\\/\\/\\s*<reference\\s+path\\s*=\\s*)('|\")(.+?)\\2.*?\\/>/;\n    // Warning: This has the same semantics as the forEach family of functions,\n    //          in that traversal terminates in the event that 'visitor' supplies a truthy value.\n    function forEachReturnStatement(body, visitor) {\n        return traverse(body);\n        function traverse(node) {\n            switch (node.kind) {\n                case 174 /* ReturnStatement */:\n                    return visitor(node);\n                case 163 /* Block */:\n                case 167 /* IfStatement */:\n                case 168 /* DoStatement */:\n                case 169 /* WhileStatement */:\n                case 170 /* ForStatement */:\n                case 171 /* ForInStatement */:\n                case 175 /* WithStatement */:\n                case 176 /* SwitchStatement */:\n                case 194 /* CaseClause */:\n                case 195 /* DefaultClause */:\n                case 177 /* LabeledStatement */:\n                case 179 /* TryStatement */:\n                case 180 /* TryBlock */:\n                case 197 /* CatchClause */:\n                case 181 /* FinallyBlock */:\n                    return ts.forEachChild(node, traverse);\n            }\n        }\n    }\n    ts.forEachReturnStatement = forEachReturnStatement;\n    function isAnyFunction(node) {\n        if (node) {\n            switch (node.kind) {\n                case 150 /* FunctionExpression */:\n                case 184 /* FunctionDeclaration */:\n                case 151 /* ArrowFunction */:\n                case 125 /* Method */:\n                case 127 /* GetAccessor */:\n                case 128 /* SetAccessor */:\n                case 126 /* Constructor */:\n                    return true;\n            }\n        }\n        return false;\n    }\n    ts.isAnyFunction = isAnyFunction;\n    function isFunctionBlock(node) {\n        return node !== undefined && node.kind === 163 /* Block */ && isAnyFunction(node.parent);\n    }\n    ts.isFunctionBlock = isFunctionBlock;\n    function isObjectLiteralMethod(node) {\n        return node !== undefined && node.kind === 125 /* Method */ && node.parent.kind === 142 /* ObjectLiteralExpression */;\n    }\n    ts.isObjectLiteralMethod = isObjectLiteralMethod;\n    function getContainingFunction(node) {\n        while (true) {\n            node = node.parent;\n            if (!node || isAnyFunction(node)) {\n                return node;\n            }\n        }\n    }\n    ts.getContainingFunction = getContainingFunction;\n    function getThisContainer(node, includeArrowFunctions) {\n        while (true) {\n            node = node.parent;\n            if (!node) {\n                return undefined;\n            }\n            switch (node.kind) {\n                case 151 /* ArrowFunction */:\n                    if (!includeArrowFunctions) {\n                        continue;\n                    }\n                case 184 /* FunctionDeclaration */:\n                case 150 /* FunctionExpression */:\n                case 189 /* ModuleDeclaration */:\n                case 124 /* Property */:\n                case 125 /* Method */:\n                case 126 /* Constructor */:\n                case 127 /* GetAccessor */:\n                case 128 /* SetAccessor */:\n                case 188 /* EnumDeclaration */:\n                case 201 /* SourceFile */:\n                    return node;\n            }\n        }\n    }\n    ts.getThisContainer = getThisContainer;\n    function getSuperContainer(node) {\n        while (true) {\n            node = node.parent;\n            if (!node) {\n                return undefined;\n            }\n            switch (node.kind) {\n                case 124 /* Property */:\n                case 125 /* Method */:\n                case 126 /* Constructor */:\n                case 127 /* GetAccessor */:\n                case 128 /* SetAccessor */:\n                    return node;\n            }\n        }\n    }\n    ts.getSuperContainer = getSuperContainer;\n    function getInvokedExpression(node) {\n        if (node.kind === 147 /* TaggedTemplateExpression */) {\n            return node.tag;\n        }\n        // Will either be a CallExpression or NewExpression.\n        return node.expression;\n    }\n    ts.getInvokedExpression = getInvokedExpression;\n    function isExpression(node) {\n        switch (node.kind) {\n            case 91 /* ThisKeyword */:\n            case 89 /* SuperKeyword */:\n            case 87 /* NullKeyword */:\n            case 93 /* TrueKeyword */:\n            case 78 /* FalseKeyword */:\n            case 8 /* RegularExpressionLiteral */:\n            case 141 /* ArrayLiteralExpression */:\n            case 142 /* ObjectLiteralExpression */:\n            case 143 /* PropertyAccessExpression */:\n            case 144 /* ElementAccessExpression */:\n            case 145 /* CallExpression */:\n            case 146 /* NewExpression */:\n            case 147 /* TaggedTemplateExpression */:\n            case 148 /* TypeAssertionExpression */:\n            case 149 /* ParenthesizedExpression */:\n            case 150 /* FunctionExpression */:\n            case 151 /* ArrowFunction */:\n            case 154 /* VoidExpression */:\n            case 152 /* DeleteExpression */:\n            case 153 /* TypeOfExpression */:\n            case 155 /* PrefixUnaryExpression */:\n            case 156 /* PostfixUnaryExpression */:\n            case 157 /* BinaryExpression */:\n            case 158 /* ConditionalExpression */:\n            case 159 /* TemplateExpression */:\n            case 9 /* NoSubstitutionTemplateLiteral */:\n            case 161 /* OmittedExpression */:\n                return true;\n            case 120 /* QualifiedName */:\n                while (node.parent.kind === 120 /* QualifiedName */) {\n                    node = node.parent;\n                }\n                return node.parent.kind === 135 /* TypeQuery */;\n            case 63 /* Identifier */:\n                if (node.parent.kind === 135 /* TypeQuery */) {\n                    return true;\n                }\n            case 6 /* NumericLiteral */:\n            case 7 /* StringLiteral */:\n                var parent = node.parent;\n                switch (parent.kind) {\n                    case 183 /* VariableDeclaration */:\n                    case 123 /* Parameter */:\n                    case 124 /* Property */:\n                    case 200 /* EnumMember */:\n                    case 198 /* PropertyAssignment */:\n                        return parent.initializer === node;\n                    case 166 /* ExpressionStatement */:\n                    case 167 /* IfStatement */:\n                    case 168 /* DoStatement */:\n                    case 169 /* WhileStatement */:\n                    case 174 /* ReturnStatement */:\n                    case 175 /* WithStatement */:\n                    case 176 /* SwitchStatement */:\n                    case 194 /* CaseClause */:\n                    case 178 /* ThrowStatement */:\n                    case 176 /* SwitchStatement */:\n                        return parent.expression === node;\n                    case 170 /* ForStatement */:\n                        return parent.initializer === node || parent.condition === node || parent.iterator === node;\n                    case 171 /* ForInStatement */:\n                        return parent.variable === node || parent.expression === node;\n                    case 148 /* TypeAssertionExpression */:\n                        return node === parent.expression;\n                    case 162 /* TemplateSpan */:\n                        return node === parent.expression;\n                    default:\n                        if (isExpression(parent)) {\n                            return true;\n                        }\n                }\n        }\n        return false;\n    }\n    ts.isExpression = isExpression;\n    function isExternalModuleImportDeclaration(node) {\n        return node.kind === 191 /* ImportDeclaration */ && node.moduleReference.kind === 193 /* ExternalModuleReference */;\n    }\n    ts.isExternalModuleImportDeclaration = isExternalModuleImportDeclaration;\n    function getExternalModuleImportDeclarationExpression(node) {\n        ts.Debug.assert(isExternalModuleImportDeclaration(node));\n        return node.moduleReference.expression;\n    }\n    ts.getExternalModuleImportDeclarationExpression = getExternalModuleImportDeclarationExpression;\n    function isInternalModuleImportDeclaration(node) {\n        return node.kind === 191 /* ImportDeclaration */ && node.moduleReference.kind !== 193 /* ExternalModuleReference */;\n    }\n    ts.isInternalModuleImportDeclaration = isInternalModuleImportDeclaration;\n    function hasDotDotDotToken(node) {\n        return node && node.kind === 123 /* Parameter */ && node.dotDotDotToken !== undefined;\n    }\n    ts.hasDotDotDotToken = hasDotDotDotToken;\n    function hasQuestionToken(node) {\n        if (node) {\n            switch (node.kind) {\n                case 123 /* Parameter */:\n                    return node.questionToken !== undefined;\n                case 125 /* Method */:\n                    return node.questionToken !== undefined;\n                case 199 /* ShorthandPropertyAssignment */:\n                case 198 /* PropertyAssignment */:\n                case 124 /* Property */:\n                    return node.questionToken !== undefined;\n            }\n        }\n        return false;\n    }\n    ts.hasQuestionToken = hasQuestionToken;\n    function hasRestParameters(s) {\n        return s.parameters.length > 0 && s.parameters[s.parameters.length - 1].dotDotDotToken !== undefined;\n    }\n    ts.hasRestParameters = hasRestParameters;\n    function isLiteralKind(kind) {\n        return 6 /* FirstLiteralToken */ <= kind && kind <= 9 /* LastLiteralToken */;\n    }\n    ts.isLiteralKind = isLiteralKind;\n    function isTextualLiteralKind(kind) {\n        return kind === 7 /* StringLiteral */ || kind === 9 /* NoSubstitutionTemplateLiteral */;\n    }\n    ts.isTextualLiteralKind = isTextualLiteralKind;\n    function isTemplateLiteralKind(kind) {\n        return 9 /* FirstTemplateToken */ <= kind && kind <= 12 /* LastTemplateToken */;\n    }\n    ts.isTemplateLiteralKind = isTemplateLiteralKind;\n    function isInAmbientContext(node) {\n        while (node) {\n            if (node.flags & (2 /* Ambient */ | 1024 /* DeclarationFile */))\n                return true;\n            node = node.parent;\n        }\n        return false;\n    }\n    ts.isInAmbientContext = isInAmbientContext;\n    function isDeclaration(node) {\n        switch (node.kind) {\n            case 122 /* TypeParameter */:\n            case 123 /* Parameter */:\n            case 183 /* VariableDeclaration */:\n            case 124 /* Property */:\n            case 198 /* PropertyAssignment */:\n            case 199 /* ShorthandPropertyAssignment */:\n            case 200 /* EnumMember */:\n            case 125 /* Method */:\n            case 184 /* FunctionDeclaration */:\n            case 127 /* GetAccessor */:\n            case 128 /* SetAccessor */:\n            case 126 /* Constructor */:\n            case 185 /* ClassDeclaration */:\n            case 186 /* InterfaceDeclaration */:\n            case 187 /* TypeAliasDeclaration */:\n            case 188 /* EnumDeclaration */:\n            case 189 /* ModuleDeclaration */:\n            case 191 /* ImportDeclaration */:\n                return true;\n        }\n        return false;\n    }\n    ts.isDeclaration = isDeclaration;\n    function isStatement(n) {\n        switch (n.kind) {\n            case 173 /* BreakStatement */:\n            case 172 /* ContinueStatement */:\n            case 182 /* DebuggerStatement */:\n            case 168 /* DoStatement */:\n            case 166 /* ExpressionStatement */:\n            case 165 /* EmptyStatement */:\n            case 171 /* ForInStatement */:\n            case 170 /* ForStatement */:\n            case 167 /* IfStatement */:\n            case 177 /* LabeledStatement */:\n            case 174 /* ReturnStatement */:\n            case 176 /* SwitchStatement */:\n            case 92 /* ThrowKeyword */:\n            case 179 /* TryStatement */:\n            case 164 /* VariableStatement */:\n            case 169 /* WhileStatement */:\n            case 175 /* WithStatement */:\n            case 192 /* ExportAssignment */:\n                return true;\n            default:\n                return false;\n        }\n    }\n    ts.isStatement = isStatement;\n    // True if the given identifier, string literal, or number literal is the name of a declaration node\n    function isDeclarationOrFunctionExpressionOrCatchVariableName(name) {\n        if (name.kind !== 63 /* Identifier */ && name.kind !== 7 /* StringLiteral */ && name.kind !== 6 /* NumericLiteral */) {\n            return false;\n        }\n        var parent = name.parent;\n        if (isDeclaration(parent) || parent.kind === 150 /* FunctionExpression */) {\n            return parent.name === name;\n        }\n        if (parent.kind === 197 /* CatchClause */) {\n            return parent.name === name;\n        }\n        return false;\n    }\n    ts.isDeclarationOrFunctionExpressionOrCatchVariableName = isDeclarationOrFunctionExpressionOrCatchVariableName;\n    function getClassBaseTypeNode(node) {\n        var heritageClause = getHeritageClause(node.heritageClauses, 77 /* ExtendsKeyword */);\n        return heritageClause && heritageClause.types.length > 0 ? heritageClause.types[0] : undefined;\n    }\n    ts.getClassBaseTypeNode = getClassBaseTypeNode;\n    function getClassImplementedTypeNodes(node) {\n        var heritageClause = getHeritageClause(node.heritageClauses, 100 /* ImplementsKeyword */);\n        return heritageClause ? heritageClause.types : undefined;\n    }\n    ts.getClassImplementedTypeNodes = getClassImplementedTypeNodes;\n    function getInterfaceBaseTypeNodes(node) {\n        var heritageClause = getHeritageClause(node.heritageClauses, 77 /* ExtendsKeyword */);\n        return heritageClause ? heritageClause.types : undefined;\n    }\n    ts.getInterfaceBaseTypeNodes = getInterfaceBaseTypeNodes;\n    function getHeritageClause(clauses, kind) {\n        if (clauses) {\n            for (var i = 0, n = clauses.length; i < n; i++) {\n                if (clauses[i].token === kind) {\n                    return clauses[i];\n                }\n            }\n        }\n        return undefined;\n    }\n    ts.getHeritageClause = getHeritageClause;\n    function tryResolveScriptReference(program, sourceFile, reference) {\n        if (!program.getCompilerOptions().noResolve) {\n            var referenceFileName = ts.isRootedDiskPath(reference.filename) ? reference.filename : ts.combinePaths(ts.getDirectoryPath(sourceFile.filename), reference.filename);\n            referenceFileName = ts.getNormalizedAbsolutePath(referenceFileName, program.getCompilerHost().getCurrentDirectory());\n            return program.getSourceFile(referenceFileName);\n        }\n    }\n    ts.tryResolveScriptReference = tryResolveScriptReference;\n    function getAncestor(node, kind) {\n        switch (kind) {\n            case 185 /* ClassDeclaration */:\n                while (node) {\n                    switch (node.kind) {\n                        case 185 /* ClassDeclaration */:\n                            return node;\n                        case 188 /* EnumDeclaration */:\n                        case 186 /* InterfaceDeclaration */:\n                        case 187 /* TypeAliasDeclaration */:\n                        case 189 /* ModuleDeclaration */:\n                        case 191 /* ImportDeclaration */:\n                            // early exit cases - declarations cannot be nested in classes\n                            return undefined;\n                        default:\n                            node = node.parent;\n                            continue;\n                    }\n                }\n                break;\n            default:\n                while (node) {\n                    if (node.kind === kind) {\n                        return node;\n                    }\n                    node = node.parent;\n                }\n                break;\n        }\n        return undefined;\n    }\n    ts.getAncestor = getAncestor;\n    function getFileReferenceFromReferencePath(comment, commentRange) {\n        var simpleReferenceRegEx = /^\\/\\/\\/\\s*<reference\\s+/gim;\n        var isNoDefaultLibRegEx = /^(\\/\\/\\/\\s*<reference\\s+no-default-lib\\s*=\\s*)('|\")(.+?)\\2\\s*\\/>/gim;\n        if (simpleReferenceRegEx.exec(comment)) {\n            if (isNoDefaultLibRegEx.exec(comment)) {\n                return {\n                    isNoDefaultLib: true\n                };\n            }\n            else {\n                var matchResult = ts.fullTripleSlashReferencePathRegEx.exec(comment);\n                if (matchResult) {\n                    var start = commentRange.pos;\n                    var end = commentRange.end;\n                    return {\n                        fileReference: {\n                            pos: start,\n                            end: end,\n                            filename: matchResult[3]\n                        },\n                        isNoDefaultLib: false\n                    };\n                }\n                else {\n                    return {\n                        diagnosticMessage: ts.Diagnostics.Invalid_reference_directive_syntax,\n                        isNoDefaultLib: false\n                    };\n                }\n            }\n        }\n        return undefined;\n    }\n    ts.getFileReferenceFromReferencePath = getFileReferenceFromReferencePath;\n    function isKeyword(token) {\n        return 64 /* FirstKeyword */ <= token && token <= 119 /* LastKeyword */;\n    }\n    ts.isKeyword = isKeyword;\n    function isTrivia(token) {\n        return 2 /* FirstTriviaToken */ <= token && token <= 5 /* LastTriviaToken */;\n    }\n    ts.isTrivia = isTrivia;\n    function isModifier(token) {\n        switch (token) {\n            case 106 /* PublicKeyword */:\n            case 104 /* PrivateKeyword */:\n            case 105 /* ProtectedKeyword */:\n            case 107 /* StaticKeyword */:\n            case 76 /* ExportKeyword */:\n            case 112 /* DeclareKeyword */:\n            case 68 /* ConstKeyword */:\n                return true;\n        }\n        return false;\n    }\n    ts.isModifier = isModifier;\n})(ts || (ts = {}));\n/// <reference path=\"types.ts\"/>\n/// <reference path=\"core.ts\"/>\n/// <reference path=\"scanner.ts\"/>\n/// <reference path=\"utilities.ts\"/>\nvar ts;\n(function (ts) {\n    var nodeConstructors = new Array(204 /* Count */);\n    function getNodeConstructor(kind) {\n        return nodeConstructors[kind] || (nodeConstructors[kind] = ts.objectAllocator.getNodeConstructor(kind));\n    }\n    ts.getNodeConstructor = getNodeConstructor;\n    function createRootNode(kind, pos, end, flags) {\n        var node = new (getNodeConstructor(kind))();\n        node.pos = pos;\n        node.end = end;\n        node.flags = flags;\n        return node;\n    }\n    // Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes\n    // stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,\n    // embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns\n    // a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.\n    function forEachChild(node, cbNode, cbNodes) {\n        function child(node) {\n            if (node) {\n                return cbNode(node);\n            }\n        }\n        function children(nodes) {\n            if (nodes) {\n                if (cbNodes) {\n                    return cbNodes(nodes);\n                }\n                for (var i = 0, len = nodes.length; i < len; i++) {\n                    var result = cbNode(nodes[i]);\n                    if (result) {\n                        return result;\n                    }\n                }\n                return undefined;\n            }\n        }\n        if (!node) {\n            return;\n        }\n        switch (node.kind) {\n            case 120 /* QualifiedName */:\n                return child(node.left) || child(node.right);\n            case 122 /* TypeParameter */:\n                return child(node.name) || child(node.constraint);\n            case 123 /* Parameter */:\n                return children(node.modifiers) || child(node.dotDotDotToken) || child(node.name) || child(node.questionToken) || child(node.type) || child(node.initializer);\n            case 124 /* Property */:\n            case 198 /* PropertyAssignment */:\n            case 199 /* ShorthandPropertyAssignment */:\n                return children(node.modifiers) || child(node.name) || child(node.questionToken) || child(node.type) || child(node.initializer);\n            case 133 /* FunctionType */:\n            case 134 /* ConstructorType */:\n            case 129 /* CallSignature */:\n            case 130 /* ConstructSignature */:\n            case 131 /* IndexSignature */:\n                return children(node.modifiers) || children(node.typeParameters) || children(node.parameters) || child(node.type);\n            case 125 /* Method */:\n            case 126 /* Constructor */:\n            case 127 /* GetAccessor */:\n            case 128 /* SetAccessor */:\n            case 150 /* FunctionExpression */:\n            case 184 /* FunctionDeclaration */:\n            case 151 /* ArrowFunction */:\n                return children(node.modifiers) || child(node.name) || child(node.questionToken) || children(node.typeParameters) || children(node.parameters) || child(node.type) || child(node.body);\n            case 132 /* TypeReference */:\n                return child(node.typeName) || children(node.typeArguments);\n            case 135 /* TypeQuery */:\n                return child(node.exprName);\n            case 136 /* TypeLiteral */:\n                return children(node.members);\n            case 137 /* ArrayType */:\n                return child(node.elementType);\n            case 138 /* TupleType */:\n                return children(node.elementTypes);\n            case 139 /* UnionType */:\n                return children(node.types);\n            case 140 /* ParenthesizedType */:\n                return child(node.type);\n            case 141 /* ArrayLiteralExpression */:\n                return children(node.elements);\n            case 142 /* ObjectLiteralExpression */:\n                return children(node.properties);\n            case 143 /* PropertyAccessExpression */:\n                return child(node.expression) || child(node.name);\n            case 144 /* ElementAccessExpression */:\n                return child(node.expression) || child(node.argumentExpression);\n            case 145 /* CallExpression */:\n            case 146 /* NewExpression */:\n                return child(node.expression) || children(node.typeArguments) || children(node.arguments);\n            case 147 /* TaggedTemplateExpression */:\n                return child(node.tag) || child(node.template);\n            case 148 /* TypeAssertionExpression */:\n                return child(node.type) || child(node.expression);\n            case 149 /* ParenthesizedExpression */:\n                return child(node.expression);\n            case 152 /* DeleteExpression */:\n                return child(node.expression);\n            case 153 /* TypeOfExpression */:\n                return child(node.expression);\n            case 154 /* VoidExpression */:\n                return child(node.expression);\n            case 155 /* PrefixUnaryExpression */:\n                return child(node.operand);\n            case 156 /* PostfixUnaryExpression */:\n                return child(node.operand);\n            case 157 /* BinaryExpression */:\n                return child(node.left) || child(node.right);\n            case 158 /* ConditionalExpression */:\n                return child(node.condition) || child(node.whenTrue) || child(node.whenFalse);\n            case 163 /* Block */:\n            case 180 /* TryBlock */:\n            case 181 /* FinallyBlock */:\n            case 190 /* ModuleBlock */:\n                return children(node.statements);\n            case 201 /* SourceFile */:\n                return children(node.statements) || child(node.endOfFileToken);\n            case 164 /* VariableStatement */:\n                return children(node.modifiers) || children(node.declarations);\n            case 166 /* ExpressionStatement */:\n                return child(node.expression);\n            case 167 /* IfStatement */:\n                return child(node.expression) || child(node.thenStatement) || child(node.elseStatement);\n            case 168 /* DoStatement */:\n                return child(node.statement) || child(node.expression);\n            case 169 /* WhileStatement */:\n                return child(node.expression) || child(node.statement);\n            case 170 /* ForStatement */:\n                return children(node.declarations) || child(node.initializer) || child(node.condition) || child(node.iterator) || child(node.statement);\n            case 171 /* ForInStatement */:\n                return children(node.declarations) || child(node.variable) || child(node.expression) || child(node.statement);\n            case 172 /* ContinueStatement */:\n            case 173 /* BreakStatement */:\n                return child(node.label);\n            case 174 /* ReturnStatement */:\n                return child(node.expression);\n            case 175 /* WithStatement */:\n                return child(node.expression) || child(node.statement);\n            case 176 /* SwitchStatement */:\n                return child(node.expression) || children(node.clauses);\n            case 194 /* CaseClause */:\n                return child(node.expression) || children(node.statements);\n            case 195 /* DefaultClause */:\n                return children(node.statements);\n            case 177 /* LabeledStatement */:\n                return child(node.label) || child(node.statement);\n            case 178 /* ThrowStatement */:\n                return child(node.expression);\n            case 179 /* TryStatement */:\n                return child(node.tryBlock) || child(node.catchClause) || child(node.finallyBlock);\n            case 197 /* CatchClause */:\n                return child(node.name) || child(node.type) || child(node.block);\n            case 183 /* VariableDeclaration */:\n                return children(node.modifiers) || child(node.name) || child(node.type) || child(node.initializer);\n            case 185 /* ClassDeclaration */:\n                return children(node.modifiers) || child(node.name) || children(node.typeParameters) || children(node.heritageClauses) || children(node.members);\n            case 186 /* InterfaceDeclaration */:\n                return children(node.modifiers) || child(node.name) || children(node.typeParameters) || children(node.heritageClauses) || children(node.members);\n            case 187 /* TypeAliasDeclaration */:\n                return children(node.modifiers) || child(node.name) || child(node.type);\n            case 188 /* EnumDeclaration */:\n                return children(node.modifiers) || child(node.name) || children(node.members);\n            case 200 /* EnumMember */:\n                return child(node.name) || child(node.initializer);\n            case 189 /* ModuleDeclaration */:\n                return children(node.modifiers) || child(node.name) || child(node.body);\n            case 191 /* ImportDeclaration */:\n                return children(node.modifiers) || child(node.name) || child(node.moduleReference);\n            case 192 /* ExportAssignment */:\n                return children(node.modifiers) || child(node.exportName);\n            case 159 /* TemplateExpression */:\n                return child(node.head) || children(node.templateSpans);\n            case 162 /* TemplateSpan */:\n                return child(node.expression) || child(node.literal);\n            case 121 /* ComputedPropertyName */:\n                return child(node.expression);\n            case 196 /* HeritageClause */:\n                return children(node.types);\n            case 193 /* ExternalModuleReference */:\n                return child(node.expression);\n        }\n    }\n    ts.forEachChild = forEachChild;\n    // TODO (drosen, mhegazy): Move to a more appropriate file.\n    function createCompilerHost(options) {\n        var currentDirectory;\n        var existingDirectories = {};\n        function getCanonicalFileName(fileName) {\n            // if underlying system can distinguish between two files whose names differs only in cases then file name already in canonical form.\n            // otherwise use toLowerCase as a canonical form.\n            return ts.sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase();\n        }\n        // returned by CScript sys environment\n        var unsupportedFileEncodingErrorCode = -2147024809;\n        function getSourceFile(filename, languageVersion, onError) {\n            try {\n                var text = ts.sys.readFile(filename, options.charset);\n            }\n            catch (e) {\n                if (onError) {\n                    onError(e.number === unsupportedFileEncodingErrorCode ? ts.createCompilerDiagnostic(ts.Diagnostics.Unsupported_file_encoding).messageText : e.message);\n                }\n                text = \"\";\n            }\n            return text !== undefined ? createSourceFile(filename, text, languageVersion, \"0\") : undefined;\n        }\n        function writeFile(fileName, data, writeByteOrderMark, onError) {\n            function directoryExists(directoryPath) {\n                if (ts.hasProperty(existingDirectories, directoryPath)) {\n                    return true;\n                }\n                if (ts.sys.directoryExists(directoryPath)) {\n                    existingDirectories[directoryPath] = true;\n                    return true;\n                }\n                return false;\n            }\n            function ensureDirectoriesExist(directoryPath) {\n                if (directoryPath.length > ts.getRootLength(directoryPath) && !directoryExists(directoryPath)) {\n                    var parentDirectory = ts.getDirectoryPath(directoryPath);\n                    ensureDirectoriesExist(parentDirectory);\n                    ts.sys.createDirectory(directoryPath);\n                }\n            }\n            try {\n                ensureDirectoriesExist(ts.getDirectoryPath(ts.normalizePath(fileName)));\n                ts.sys.writeFile(fileName, data, writeByteOrderMark);\n            }\n            catch (e) {\n                if (onError) {\n                    onError(e.message);\n                }\n            }\n        }\n        return {\n            getSourceFile: getSourceFile,\n            getDefaultLibFilename: function (options) { return ts.combinePaths(ts.getDirectoryPath(ts.normalizePath(ts.sys.getExecutingFilePath())), options.target === 2 /* ES6 */ ? \"lib.es6.d.ts\" : \"lib.d.ts\"); },\n            writeFile: writeFile,\n            getCurrentDirectory: function () { return currentDirectory || (currentDirectory = ts.sys.getCurrentDirectory()); },\n            useCaseSensitiveFileNames: function () { return ts.sys.useCaseSensitiveFileNames; },\n            getCanonicalFileName: getCanonicalFileName,\n            getNewLine: function () { return ts.sys.newLine; }\n        };\n    }\n    ts.createCompilerHost = createCompilerHost;\n    function parsingContextErrors(context) {\n        switch (context) {\n            case 0 /* SourceElements */: return ts.Diagnostics.Declaration_or_statement_expected;\n            case 1 /* ModuleElements */: return ts.Diagnostics.Declaration_or_statement_expected;\n            case 2 /* BlockStatements */: return ts.Diagnostics.Statement_expected;\n            case 3 /* SwitchClauses */: return ts.Diagnostics.case_or_default_expected;\n            case 4 /* SwitchClauseStatements */: return ts.Diagnostics.Statement_expected;\n            case 5 /* TypeMembers */: return ts.Diagnostics.Property_or_signature_expected;\n            case 6 /* ClassMembers */: return ts.Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected;\n            case 7 /* EnumMembers */: return ts.Diagnostics.Enum_member_expected;\n            case 8 /* TypeReferences */: return ts.Diagnostics.Type_reference_expected;\n            case 9 /* VariableDeclarations */: return ts.Diagnostics.Variable_declaration_expected;\n            case 10 /* ArgumentExpressions */: return ts.Diagnostics.Argument_expression_expected;\n            case 11 /* ObjectLiteralMembers */: return ts.Diagnostics.Property_assignment_expected;\n            case 12 /* ArrayLiteralMembers */: return ts.Diagnostics.Expression_or_comma_expected;\n            case 13 /* Parameters */: return ts.Diagnostics.Parameter_declaration_expected;\n            case 14 /* TypeParameters */: return ts.Diagnostics.Type_parameter_declaration_expected;\n            case 15 /* TypeArguments */: return ts.Diagnostics.Type_argument_expected;\n            case 16 /* TupleElementTypes */: return ts.Diagnostics.Type_expected;\n            case 17 /* HeritageClauses */: return ts.Diagnostics.Unexpected_token_expected;\n        }\n    }\n    ;\n    function modifierToFlag(token) {\n        switch (token) {\n            case 107 /* StaticKeyword */: return 128 /* Static */;\n            case 106 /* PublicKeyword */: return 16 /* Public */;\n            case 105 /* ProtectedKeyword */: return 64 /* Protected */;\n            case 104 /* PrivateKeyword */: return 32 /* Private */;\n            case 76 /* ExportKeyword */: return 1 /* Export */;\n            case 112 /* DeclareKeyword */: return 2 /* Ambient */;\n            case 68 /* ConstKeyword */: return 4096 /* Const */;\n        }\n        return 0;\n    }\n    function isEvalOrArgumentsIdentifier(node) {\n        return node.kind === 63 /* Identifier */ && (node.text === \"eval\" || node.text === \"arguments\");\n    }\n    /// Should be called only on prologue directives (isPrologueDirective(node) should be true)\n    function isUseStrictPrologueDirective(sourceFile, node) {\n        ts.Debug.assert(ts.isPrologueDirective(node));\n        var nodeText = ts.getSourceTextOfNodeFromSourceFile(sourceFile, node.expression);\n        return nodeText === '\"use strict\"' || nodeText === \"'use strict'\";\n    }\n    function createSourceFile(filename, sourceText, languageVersion, version, isOpen) {\n        if (isOpen === void 0) { isOpen = false; }\n        var token;\n        var parsingContext;\n        var identifiers = {};\n        var identifierCount = 0;\n        var nodeCount = 0;\n        var lineStarts;\n        // Flags that dictate what parsing context we're in.  For example:\n        // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is\n        // that some tokens that would be considered identifiers may be considered keywords.  When \n        // rewinding, we need to store and restore this as the mode may have changed.\n        //\n        // When adding more parser context flags, consider which is the more common case that the \n        // flag will be in.  This should be hte 'false' state for that flag.  The reason for this is\n        // that we don't store data in our nodes unless the value is in the *non-default* state.  So,\n        // for example, more often than code 'allows-in' (or doesn't 'disallow-in').  We opt for \n        // 'disallow-in' set to 'false'.  Otherwise, if we had 'allowsIn' set to 'true', then almost\n        // all nodes would need extra state on them to store this info.\n        //\n        // Note:  'allowIn' and 'allowYield' track 1:1 with the [in] and [yield] concepts in the ES6\n        // grammar specification.\n        //\n        // An important thing about these context concepts.  By default they are effectively inherited\n        // while parsing through every grammar production.  i.e. if you don't change them, then when\n        // you parse a sub-production, it will have the same context values as hte parent production.\n        // This is great most of the time.  After all, consider all the 'expression' grammar productions\n        // and how nearly all of them pass along the 'in' and 'yield' context values:\n        //\n        // EqualityExpression[In, Yield] :\n        //      RelationalExpression[?In, ?Yield]\n        //      EqualityExpression[?In, ?Yield] == RelationalExpression[?In, ?Yield]\n        //      EqualityExpression[?In, ?Yield] != RelationalExpression[?In, ?Yield]\n        //      EqualityExpression[?In, ?Yield] === RelationalExpression[?In, ?Yield]\n        //      EqualityExpression[?In, ?Yield] !== RelationalExpression[?In, ?Yield]\n        //\n        // Where you have to be careful is then understanding what the points are in the grammar \n        // where the values are *not* passed along.  For example:\n        //\n        // SingleNameBinding[Yield,GeneratorParameter]\n        //      [+GeneratorParameter]BindingIdentifier[Yield] Initializer[In]opt\n        //      [~GeneratorParameter]BindingIdentifier[?Yield]Initializer[In, ?Yield]opt\n        //\n        // Here this is saying that if the GeneratorParameter context flag is set, that we should \n        // explicitly set the 'yield' context flag to false before calling into the BindingIdentifier\n        // and we should explicitly unset the 'yield' context flag before calling into the Initializer.\n        // production.  Conversely, if the GeneratorParameter context flag is not set, then we \n        // should leave the 'yield' context flag alone.\n        //\n        // Getting this all correct is tricky and requires careful reading of the grammar to \n        // understand when these values should be changed versus when they should be inherited.\n        //\n        // Note: it should not be necessary to save/restore these flags during speculative/lookahead\n        // parsing.  These context flags are naturally stored and restored through normal recursive\n        // descent parsing and unwinding.\n        var contextFlags = 0;\n        // Whether or not we've had a parse error since creating the last AST node.  If we have \n        // encountered an error, it will be stored on the next AST node we create.  Parse errors\n        // can be broken down into three categories:\n        //\n        // 1) An error that occurred during scanning.  For example, an unterminated literal, or a\n        //    character that was completely not understood.\n        //\n        // 2) A token was expected, but was not present.  This type of error is commonly produced\n        //    by the 'parseExpected' function.\n        //\n        // 3) A token was present that no parsing function was able to consume.  This type of error\n        //    only occurs in the 'abortParsingListOrMoveToNextToken' function when the parser \n        //    decides to skip the token.\n        //\n        // In all of these cases, we want to mark the next node as having had an error before it.\n        // With this mark, we can know in incremental settings if this node can be reused, or if\n        // we have to reparse it.  If we don't keep this information around, we may just reuse the\n        // node.  in that event we would then not produce the same errors as we did before, causing\n        // significant confusion problems.\n        //\n        // Note: it is necessary that this value be saved/restored during speculative/lookahead \n        // parsing.  During lookahead parsing, we will often create a node.  That node will have \n        // this value attached, and then this value will be set back to 'false'.  If we decide to\n        // rewind, we must get back to the same value we had prior to the lookahead.\n        //\n        // Note: any errors at the end of the file that do not precede a regular node, should get\n        // attached to the EOF token.\n        var parseErrorBeforeNextFinishedNode = false;\n        function setContextFlag(val, flag) {\n            if (val) {\n                contextFlags |= flag;\n            }\n            else {\n                contextFlags &= ~flag;\n            }\n        }\n        function setStrictModeContext(val) {\n            setContextFlag(val, 1 /* StrictMode */);\n        }\n        function setDisallowInContext(val) {\n            setContextFlag(val, 2 /* DisallowIn */);\n        }\n        function setYieldContext(val) {\n            setContextFlag(val, 4 /* Yield */);\n        }\n        function setGeneratorParameterContext(val) {\n            setContextFlag(val, 8 /* GeneratorParameter */);\n        }\n        function allowInAnd(func) {\n            if (contextFlags & 2 /* DisallowIn */) {\n                setDisallowInContext(false);\n                var result = func();\n                setDisallowInContext(true);\n                return result;\n            }\n            // no need to do anything special if 'in' is already allowed.\n            return func();\n        }\n        function disallowInAnd(func) {\n            if (contextFlags & 2 /* DisallowIn */) {\n                // no need to do anything special if 'in' is already disallowed.\n                return func();\n            }\n            setDisallowInContext(true);\n            var result = func();\n            setDisallowInContext(false);\n            return result;\n        }\n        function doInYieldContext(func) {\n            if (contextFlags & 4 /* Yield */) {\n                // no need to do anything special if we're already in the [Yield] context.\n                return func();\n            }\n            setYieldContext(true);\n            var result = func();\n            setYieldContext(false);\n            return result;\n        }\n        function doOutsideOfYieldContext(func) {\n            if (contextFlags & 4 /* Yield */) {\n                setYieldContext(false);\n                var result = func();\n                setYieldContext(true);\n                return result;\n            }\n            // no need to do anything special if we're not in the [Yield] context.\n            return func();\n        }\n        function inYieldContext() {\n            return (contextFlags & 4 /* Yield */) !== 0;\n        }\n        function inStrictModeContext() {\n            return (contextFlags & 1 /* StrictMode */) !== 0;\n        }\n        function inGeneratorParameterContext() {\n            return (contextFlags & 8 /* GeneratorParameter */) !== 0;\n        }\n        function inDisallowInContext() {\n            return (contextFlags & 2 /* DisallowIn */) !== 0;\n        }\n        function getLineStarts() {\n            return lineStarts || (lineStarts = ts.computeLineStarts(sourceText));\n        }\n        function getLineAndCharacterFromSourcePosition(position) {\n            return ts.getLineAndCharacterOfPosition(getLineStarts(), position);\n        }\n        function getPositionFromSourceLineAndCharacter(line, character) {\n            return ts.getPositionFromLineAndCharacter(getLineStarts(), line, character);\n        }\n        function parseErrorAtCurrentToken(message, arg0) {\n            var start = scanner.getTokenPos();\n            var length = scanner.getTextPos() - start;\n            parseErrorAtPosition(start, length, message, arg0);\n        }\n        function parseErrorAtPosition(start, length, message, arg0) {\n            // Don't report another error if it would just be at the same position as the last error.\n            var lastError = ts.lastOrUndefined(sourceFile.parseDiagnostics);\n            if (!lastError || start !== lastError.start) {\n                sourceFile.parseDiagnostics.push(ts.createFileDiagnostic(sourceFile, start, length, message, arg0));\n            }\n            // Mark that we've encountered an error.  We'll set an appropriate bit on the next \n            // node we finish so that it can't be reused incrementally.\n            parseErrorBeforeNextFinishedNode = true;\n        }\n        function scanError(message) {\n            var pos = scanner.getTextPos();\n            parseErrorAtPosition(pos, 0, message);\n        }\n        function getNodePos() {\n            return scanner.getStartPos();\n        }\n        function getNodeEnd() {\n            return scanner.getStartPos();\n        }\n        function nextToken() {\n            return token = scanner.scan();\n        }\n        function getTokenPos(pos) {\n            return ts.skipTrivia(sourceText, pos);\n        }\n        function reScanGreaterToken() {\n            return token = scanner.reScanGreaterToken();\n        }\n        function reScanSlashToken() {\n            return token = scanner.reScanSlashToken();\n        }\n        function reScanTemplateToken() {\n            return token = scanner.reScanTemplateToken();\n        }\n        function speculationHelper(callback, isLookAhead) {\n            // Keep track of the state we'll need to rollback to if lookahead fails (or if the \n            // caller asked us to always reset our state).\n            var saveToken = token;\n            var saveParseDiagnosticsLength = sourceFile.parseDiagnostics.length;\n            var saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;\n            // Note: it is not actually necessary to save/restore the context flags here.  That's\n            // because the saving/restorating of these flags happens naturally through the recursive\n            // descent nature of our parser.  However, we still store this here just so we can \n            // assert that that invariant holds.\n            var saveContextFlags = contextFlags;\n            // If we're only looking ahead, then tell the scanner to only lookahead as well.\n            // Otherwise, if we're actually speculatively parsing, then tell the scanner to do the \n            // same. \n            var result = isLookAhead ? scanner.lookAhead(callback) : scanner.tryScan(callback);\n            ts.Debug.assert(saveContextFlags === contextFlags);\n            // If our callback returned something 'falsy' or we're just looking ahead,\n            // then unconditionally restore us to where we were.\n            if (!result || isLookAhead) {\n                token = saveToken;\n                sourceFile.parseDiagnostics.length = saveParseDiagnosticsLength;\n                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;\n            }\n            return result;\n        }\n        // Invokes the provided callback then unconditionally restores the parser to the state it \n        // was in immediately prior to invoking the callback.  The result of invoking the callback\n        // is returned from this function.\n        function lookAhead(callback) {\n            return speculationHelper(callback, true);\n        }\n        // Invokes the provided callback.  If the callback returns something falsy, then it restores\n        // the parser to the state it was in immediately prior to invoking the callback.  If the \n        // callback returns something truthy, then the parser state is not rolled back.  The result\n        // of invoking the callback is returned from this function.\n        function tryParse(callback) {\n            return speculationHelper(callback, false);\n        }\n        function isIdentifier() {\n            if (token === 63 /* Identifier */) {\n                return true;\n            }\n            // If we have a 'yield' keyword, and we're in the [yield] context, then 'yield' is \n            // considered a keyword and is not an identifier.\n            if (token === 108 /* YieldKeyword */ && inYieldContext()) {\n                return false;\n            }\n            return inStrictModeContext() ? token > 108 /* LastFutureReservedWord */ : token > 99 /* LastReservedWord */;\n        }\n        function parseExpected(kind, diagnosticMessage, arg0) {\n            if (token === kind) {\n                nextToken();\n                return true;\n            }\n            // Report specific message if provided with one.  Otherwise, report generic fallback message.\n            if (diagnosticMessage) {\n                parseErrorAtCurrentToken(diagnosticMessage, arg0);\n            }\n            else {\n                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(kind));\n            }\n            return false;\n        }\n        function parseOptional(t) {\n            if (token === t) {\n                nextToken();\n                return true;\n            }\n            return false;\n        }\n        function parseOptionalToken(t) {\n            if (token === t) {\n                var node = createNode(t);\n                nextToken();\n                return finishNode(node);\n            }\n            return undefined;\n        }\n        function canParseSemicolon() {\n            // If there's a real semicolon, then we can always parse it out.\n            if (token === 21 /* SemicolonToken */) {\n                return true;\n            }\n            // We can parse out an optional semicolon in ASI cases in the following cases.\n            return token === 14 /* CloseBraceToken */ || token === 1 /* EndOfFileToken */ || scanner.hasPrecedingLineBreak();\n        }\n        function parseSemicolon(diagnosticMessage) {\n            if (canParseSemicolon()) {\n                if (token === 21 /* SemicolonToken */) {\n                    // consume the semicolon if it was explicitly provided.\n                    nextToken();\n                }\n                return true;\n            }\n            else {\n                return parseExpected(21 /* SemicolonToken */, diagnosticMessage);\n            }\n        }\n        function createNode(kind, pos) {\n            nodeCount++;\n            var node = new (nodeConstructors[kind] || (nodeConstructors[kind] = ts.objectAllocator.getNodeConstructor(kind)))();\n            if (!(pos >= 0)) {\n                pos = scanner.getStartPos();\n            }\n            node.pos = pos;\n            node.end = pos;\n            return node;\n        }\n        function finishNode(node) {\n            node.end = scanner.getStartPos();\n            if (contextFlags) {\n                node.parserContextFlags = contextFlags;\n            }\n            // Keep track on the node if we encountered an error while parsing it.  If we did, then\n            // we cannot reuse the node incrementally.  Once we've marked this node, clear out the\n            // flag so that we don't mark any subsequent nodes.\n            if (parseErrorBeforeNextFinishedNode) {\n                parseErrorBeforeNextFinishedNode = false;\n                node.parserContextFlags |= 16 /* ContainsError */;\n            }\n            return node;\n        }\n        function createMissingNode(kind, reportAtCurrentPosition, diagnosticMessage, arg0) {\n            if (reportAtCurrentPosition) {\n                parseErrorAtPosition(scanner.getStartPos(), 0, diagnosticMessage, arg0);\n            }\n            else {\n                parseErrorAtCurrentToken(diagnosticMessage, arg0);\n            }\n            var result = createNode(kind, scanner.getStartPos());\n            result.text = \"\";\n            return finishNode(result);\n        }\n        function internIdentifier(text) {\n            text = ts.escapeIdentifier(text);\n            return ts.hasProperty(identifiers, text) ? identifiers[text] : (identifiers[text] = text);\n        }\n        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues\n        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for\n        // each identifier in order to reduce memory consumption.\n        function createIdentifier(isIdentifier, diagnosticMessage) {\n            identifierCount++;\n            if (isIdentifier) {\n                var node = createNode(63 /* Identifier */);\n                node.text = internIdentifier(scanner.getTokenValue());\n                nextToken();\n                return finishNode(node);\n            }\n            return createMissingNode(63 /* Identifier */, false, diagnosticMessage || ts.Diagnostics.Identifier_expected);\n        }\n        function parseIdentifier(diagnosticMessage) {\n            return createIdentifier(isIdentifier(), diagnosticMessage);\n        }\n        function parseIdentifierName() {\n            return createIdentifier(isIdentifierOrKeyword());\n        }\n        function isLiteralPropertyName() {\n            return isIdentifierOrKeyword() || token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */;\n        }\n        function parsePropertyName() {\n            if (token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */) {\n                return parseLiteralNode(true);\n            }\n            if (token === 17 /* OpenBracketToken */) {\n                return parseComputedPropertyName();\n            }\n            return parseIdentifierName();\n        }\n        function parseComputedPropertyName() {\n            // PropertyName[Yield,GeneratorParameter] :\n            //     LiteralPropertyName\n            //     [+GeneratorParameter] ComputedPropertyName\n            //     [~GeneratorParameter] ComputedPropertyName[?Yield]\n            // \n            // ComputedPropertyName[Yield] :\n            //     [ AssignmentExpression[In, ?Yield] ]\n            //\n            var node = createNode(121 /* ComputedPropertyName */);\n            parseExpected(17 /* OpenBracketToken */);\n            // We parse any expression (including a comma expression). But the grammar\n            // says that only an assignment expression is allowed, so the grammar checker\n            // will error if it sees a comma expression.\n            var yieldContext = inYieldContext();\n            if (inGeneratorParameterContext()) {\n                setYieldContext(false);\n            }\n            node.expression = allowInAnd(parseExpression);\n            if (inGeneratorParameterContext()) {\n                setYieldContext(yieldContext);\n            }\n            parseExpected(18 /* CloseBracketToken */);\n            return finishNode(node);\n        }\n        function parseContextualModifier(t) {\n            return token === t && tryParse(nextTokenCanFollowModifier);\n        }\n        function nextTokenCanFollowModifier() {\n            nextToken();\n            return canFollowModifier();\n        }\n        function parseAnyContextualModifier() {\n            return ts.isModifier(token) && tryParse(nextTokenCanFollowContextualModifier);\n        }\n        function nextTokenCanFollowContextualModifier() {\n            if (token === 68 /* ConstKeyword */) {\n                // 'const' is only a modifier if followed by 'enum'.\n                return nextToken() === 75 /* EnumKeyword */;\n            }\n            nextToken();\n            return canFollowModifier();\n        }\n        function canFollowModifier() {\n            return token === 17 /* OpenBracketToken */ || token === 34 /* AsteriskToken */ || isLiteralPropertyName();\n        }\n        // True if positioned at the start of a list element\n        function isListElement(kind, inErrorRecovery) {\n            switch (kind) {\n                case 0 /* SourceElements */:\n                case 1 /* ModuleElements */:\n                    return isSourceElement(inErrorRecovery);\n                case 2 /* BlockStatements */:\n                case 4 /* SwitchClauseStatements */:\n                    return isStatement(inErrorRecovery);\n                case 3 /* SwitchClauses */:\n                    return token === 65 /* CaseKeyword */ || token === 71 /* DefaultKeyword */;\n                case 5 /* TypeMembers */:\n                    return isStartOfTypeMember();\n                case 6 /* ClassMembers */:\n                    return lookAhead(isClassMemberStart);\n                case 7 /* EnumMembers */:\n                    // Include open bracket computed properties. This technically also lets in indexers,\n                    // which would be a candidate for improved error reporting.\n                    return token === 17 /* OpenBracketToken */ || isLiteralPropertyName();\n                case 11 /* ObjectLiteralMembers */:\n                    return token === 17 /* OpenBracketToken */ || token === 34 /* AsteriskToken */ || isLiteralPropertyName();\n                case 8 /* TypeReferences */:\n                    // We want to make sure that the \"extends\" in \"extends foo\" or the \"implements\" in\n                    // \"implements foo\" is not considered a type name.\n                    return isIdentifier() && !isNotHeritageClauseTypeName();\n                case 9 /* VariableDeclarations */:\n                case 14 /* TypeParameters */:\n                    return isIdentifier();\n                case 10 /* ArgumentExpressions */:\n                    return token === 22 /* CommaToken */ || isStartOfExpression();\n                case 12 /* ArrayLiteralMembers */:\n                    return token === 22 /* CommaToken */ || isStartOfExpression();\n                case 13 /* Parameters */:\n                    return isStartOfParameter();\n                case 15 /* TypeArguments */:\n                case 16 /* TupleElementTypes */:\n                    return token === 22 /* CommaToken */ || isStartOfType();\n                case 17 /* HeritageClauses */:\n                    return isHeritageClause();\n            }\n            ts.Debug.fail(\"Non-exhaustive case in 'isListElement'.\");\n        }\n        function nextTokenIsIdentifier() {\n            nextToken();\n            return isIdentifier();\n        }\n        function isNotHeritageClauseTypeName() {\n            if (token === 100 /* ImplementsKeyword */ || token === 77 /* ExtendsKeyword */) {\n                return lookAhead(nextTokenIsIdentifier);\n            }\n            return false;\n        }\n        // True if positioned at a list terminator\n        function isListTerminator(kind) {\n            if (token === 1 /* EndOfFileToken */) {\n                // Being at the end of the file ends all lists.\n                return true;\n            }\n            switch (kind) {\n                case 1 /* ModuleElements */:\n                case 2 /* BlockStatements */:\n                case 3 /* SwitchClauses */:\n                case 5 /* TypeMembers */:\n                case 6 /* ClassMembers */:\n                case 7 /* EnumMembers */:\n                case 11 /* ObjectLiteralMembers */:\n                    return token === 14 /* CloseBraceToken */;\n                case 4 /* SwitchClauseStatements */:\n                    return token === 14 /* CloseBraceToken */ || token === 65 /* CaseKeyword */ || token === 71 /* DefaultKeyword */;\n                case 8 /* TypeReferences */:\n                    return token === 13 /* OpenBraceToken */ || token === 77 /* ExtendsKeyword */ || token === 100 /* ImplementsKeyword */;\n                case 9 /* VariableDeclarations */:\n                    return isVariableDeclaratorListTerminator();\n                case 14 /* TypeParameters */:\n                    // Tokens other than '>' are here for better error recovery\n                    return token === 24 /* GreaterThanToken */ || token === 15 /* OpenParenToken */ || token === 13 /* OpenBraceToken */ || token === 77 /* ExtendsKeyword */ || token === 100 /* ImplementsKeyword */;\n                case 10 /* ArgumentExpressions */:\n                    // Tokens other than ')' are here for better error recovery\n                    return token === 16 /* CloseParenToken */ || token === 21 /* SemicolonToken */;\n                case 12 /* ArrayLiteralMembers */:\n                case 16 /* TupleElementTypes */:\n                    return token === 18 /* CloseBracketToken */;\n                case 13 /* Parameters */:\n                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery\n                    return token === 16 /* CloseParenToken */ || token === 18 /* CloseBracketToken */ || token === 13 /* OpenBraceToken */;\n                case 15 /* TypeArguments */:\n                    // Tokens other than '>' are here for better error recovery\n                    return token === 24 /* GreaterThanToken */ || token === 15 /* OpenParenToken */;\n                case 17 /* HeritageClauses */:\n                    return token === 13 /* OpenBraceToken */ || token === 14 /* CloseBraceToken */;\n            }\n        }\n        function isVariableDeclaratorListTerminator() {\n            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done \n            // with parsing the list of  variable declarators.\n            if (canParseSemicolon()) {\n                return true;\n            }\n            // in the case where we're parsing the variable declarator of a 'for-in' statement, we \n            // are done if we see an 'in' keyword in front of us.\n            if (token === 84 /* InKeyword */) {\n                return true;\n            }\n            // ERROR RECOVERY TWEAK:\n            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an\n            // arrow function here and it's going to be very unlikely that we'll resynchronize and get\n            // another variable declaration.\n            if (token === 31 /* EqualsGreaterThanToken */) {\n                return true;\n            }\n            // Keep trying to parse out variable declarators.\n            return false;\n        }\n        // True if positioned at element or terminator of the current list or any enclosing list\n        function isInSomeParsingContext() {\n            for (var kind = 0; kind < 18 /* Count */; kind++) {\n                if (parsingContext & (1 << kind)) {\n                    if (isListElement(kind, true) || isListTerminator(kind)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        // Parses a list of elements\n        function parseList(kind, checkForStrictMode, parseElement) {\n            var saveParsingContext = parsingContext;\n            parsingContext |= 1 << kind;\n            var result = [];\n            result.pos = getNodePos();\n            var savedStrictModeContext = inStrictModeContext();\n            while (!isListTerminator(kind)) {\n                if (isListElement(kind, false)) {\n                    var element = parseElement();\n                    result.push(element);\n                    // test elements only if we are not already in strict mode\n                    if (checkForStrictMode && !inStrictModeContext()) {\n                        if (ts.isPrologueDirective(element)) {\n                            if (isUseStrictPrologueDirective(sourceFile, element)) {\n                                setStrictModeContext(true);\n                                checkForStrictMode = false;\n                            }\n                        }\n                        else {\n                            checkForStrictMode = false;\n                        }\n                    }\n                    continue;\n                }\n                if (abortParsingListOrMoveToNextToken(kind)) {\n                    break;\n                }\n            }\n            setStrictModeContext(savedStrictModeContext);\n            result.end = getNodeEnd();\n            parsingContext = saveParsingContext;\n            return result;\n        }\n        // Returns true if we should abort parsing.\n        function abortParsingListOrMoveToNextToken(kind) {\n            parseErrorAtCurrentToken(parsingContextErrors(kind));\n            if (isInSomeParsingContext()) {\n                return true;\n            }\n            nextToken();\n            return false;\n        }\n        // Parses a comma-delimited list of elements\n        function parseDelimitedList(kind, parseElement) {\n            var saveParsingContext = parsingContext;\n            parsingContext |= 1 << kind;\n            var result = [];\n            result.pos = getNodePos();\n            var commaStart = -1; // Meaning the previous token was not a comma\n            while (true) {\n                if (isListElement(kind, false)) {\n                    result.push(parseElement());\n                    commaStart = scanner.getTokenPos();\n                    if (parseOptional(22 /* CommaToken */)) {\n                        continue;\n                    }\n                    commaStart = -1; // Back to the state where the last token was not a comma\n                    if (isListTerminator(kind)) {\n                        break;\n                    }\n                    parseExpected(22 /* CommaToken */);\n                    continue;\n                }\n                if (isListTerminator(kind)) {\n                    break;\n                }\n                if (abortParsingListOrMoveToNextToken(kind)) {\n                    break;\n                }\n            }\n            // Recording the trailing comma is deliberately done after the previous\n            // loop, and not just if we see a list terminator. This is because the list\n            // may have ended incorrectly, but it is still important to know if there\n            // was a trailing comma.\n            // Check if the last token was a comma.\n            if (commaStart >= 0) {\n                // Always preserve a trailing comma by marking it on the NodeArray\n                result.hasTrailingComma = true;\n            }\n            result.end = getNodeEnd();\n            parsingContext = saveParsingContext;\n            return result;\n        }\n        function createMissingList() {\n            var pos = getNodePos();\n            var result = [];\n            result.pos = pos;\n            result.end = pos;\n            return result;\n        }\n        function parseBracketedList(kind, parseElement, open, close) {\n            if (parseExpected(open)) {\n                var result = parseDelimitedList(kind, parseElement);\n                parseExpected(close);\n                return result;\n            }\n            return createMissingList();\n        }\n        // The allowReservedWords parameter controls whether reserved words are permitted after the first dot\n        function parseEntityName(allowReservedWords, diagnosticMessage) {\n            var entity = parseIdentifier(diagnosticMessage);\n            while (parseOptional(19 /* DotToken */)) {\n                var node = createNode(120 /* QualifiedName */, entity.pos);\n                node.left = entity;\n                node.right = parseRightSideOfDot(allowReservedWords);\n                entity = finishNode(node);\n            }\n            return entity;\n        }\n        function parseRightSideOfDot(allowIdentifierNames) {\n            // Technically a keyword is valid here as all keywords are identifier names.\n            // However, often we'll encounter this in error situations when the keyword\n            // is actually starting another valid construct.\n            //\n            // So, we check for the following specific case:\n            //\n            //      name.\n            //      keyword identifierNameOrKeyword\n            //\n            // Note: the newlines are important here.  For example, if that above code \n            // were rewritten into:\n            //\n            //      name.keyword\n            //      identifierNameOrKeyword\n            //\n            // Then we would consider it valid.  That's because ASI would take effect and\n            // the code would be implicitly: \"name.keyword; identifierNameOrKeyword\".  \n            // In the first case though, ASI will not take effect because there is not a\n            // line terminator after the keyword.\n            if (scanner.hasPrecedingLineBreak() && scanner.isReservedWord()) {\n                var matchesPattern = lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);\n                if (matchesPattern) {\n                    // Report that we need an identifier.  However, report it right after the dot, \n                    // and not on the next token.  This is because the next token might actually \n                    // be an identifier and the error woudl be quite confusing.\n                    return createMissingNode(63 /* Identifier */, true, ts.Diagnostics.Identifier_expected);\n                }\n            }\n            return allowIdentifierNames ? parseIdentifierName() : parseIdentifier();\n        }\n        function parseTokenNode() {\n            var node = createNode(token);\n            nextToken();\n            return finishNode(node);\n        }\n        function parseTemplateExpression() {\n            var template = createNode(159 /* TemplateExpression */);\n            template.head = parseLiteralNode();\n            ts.Debug.assert(template.head.kind === 10 /* TemplateHead */, \"Template head has wrong token kind\");\n            var templateSpans = [];\n            templateSpans.pos = getNodePos();\n            do {\n                templateSpans.push(parseTemplateSpan());\n            } while (templateSpans[templateSpans.length - 1].literal.kind === 11 /* TemplateMiddle */);\n            templateSpans.end = getNodeEnd();\n            template.templateSpans = templateSpans;\n            return finishNode(template);\n        }\n        function parseTemplateSpan() {\n            var span = createNode(162 /* TemplateSpan */);\n            span.expression = allowInAnd(parseExpression);\n            var literal;\n            if (token === 14 /* CloseBraceToken */) {\n                reScanTemplateToken();\n                literal = parseLiteralNode();\n            }\n            else {\n                literal = createMissingNode(12 /* TemplateTail */, false, ts.Diagnostics._0_expected, ts.tokenToString(14 /* CloseBraceToken */));\n            }\n            span.literal = literal;\n            return finishNode(span);\n        }\n        function parseLiteralNode(internName) {\n            var node = createNode(token);\n            var text = scanner.getTokenValue();\n            node.text = internName ? internIdentifier(text) : text;\n            if (scanner.isUnterminated()) {\n                node.isUnterminated = true;\n            }\n            var tokenPos = scanner.getTokenPos();\n            nextToken();\n            finishNode(node);\n            // Octal literals are not allowed in strict mode or ES5\n            // Note that theoretically the following condition would hold true literals like 009,\n            // which is not octal.But because of how the scanner separates the tokens, we would\n            // never get a token like this. Instead, we would get 00 and 9 as two separate tokens.\n            // We also do not need to check for negatives because any prefix operator would be part of a\n            // parent unary expression.\n            if (node.kind === 6 /* NumericLiteral */ && sourceText.charCodeAt(tokenPos) === 48 /* _0 */ && ts.isOctalDigit(sourceText.charCodeAt(tokenPos + 1))) {\n                node.flags |= 8192 /* OctalLiteral */;\n            }\n            return node;\n        }\n        // TYPES\n        function parseTypeReference() {\n            var node = createNode(132 /* TypeReference */);\n            node.typeName = parseEntityName(false, ts.Diagnostics.Type_expected);\n            if (!scanner.hasPrecedingLineBreak() && token === 23 /* LessThanToken */) {\n                node.typeArguments = parseBracketedList(15 /* TypeArguments */, parseType, 23 /* LessThanToken */, 24 /* GreaterThanToken */);\n            }\n            return finishNode(node);\n        }\n        function parseTypeQuery() {\n            var node = createNode(135 /* TypeQuery */);\n            parseExpected(95 /* TypeOfKeyword */);\n            node.exprName = parseEntityName(true);\n            return finishNode(node);\n        }\n        function parseTypeParameter() {\n            var node = createNode(122 /* TypeParameter */);\n            node.name = parseIdentifier();\n            if (parseOptional(77 /* ExtendsKeyword */)) {\n                // It's not uncommon for people to write improper constraints to a generic.  If the \n                // user writes a constraint that is an expression and not an actual type, then parse\n                // it out as an expression (so we can recover well), but report that a type is needed\n                // instead.\n                if (isStartOfType() || !isStartOfExpression()) {\n                    node.constraint = parseType();\n                }\n                else {\n                    // It was not a type, and it looked like an expression.  Parse out an expression\n                    // here so we recover well.  Note: it is important that we call parseUnaryExpression\n                    // and not parseExpression here.  If the user has:\n                    //\n                    //      <T extends \"\">\n                    //\n                    // We do *not* want to consume the  >  as we're consuming the expression for \"\".\n                    node.expression = parseUnaryExpressionOrHigher();\n                }\n            }\n            return finishNode(node);\n        }\n        function parseTypeParameters() {\n            if (token === 23 /* LessThanToken */) {\n                return parseBracketedList(14 /* TypeParameters */, parseTypeParameter, 23 /* LessThanToken */, 24 /* GreaterThanToken */);\n            }\n        }\n        function parseParameterType() {\n            if (parseOptional(50 /* ColonToken */)) {\n                return token === 7 /* StringLiteral */ ? parseLiteralNode(true) : parseType();\n            }\n            return undefined;\n        }\n        function isStartOfParameter() {\n            return token === 20 /* DotDotDotToken */ || isIdentifier() || ts.isModifier(token);\n        }\n        function setModifiers(node, modifiers) {\n            if (modifiers) {\n                node.flags |= modifiers.flags;\n                node.modifiers = modifiers;\n            }\n        }\n        function parseParameter() {\n            var node = createNode(123 /* Parameter */);\n            setModifiers(node, parseModifiers());\n            node.dotDotDotToken = parseOptionalToken(20 /* DotDotDotToken */);\n            // SingleNameBinding[Yield,GeneratorParameter] : See 13.2.3\n            //      [+GeneratorParameter]BindingIdentifier[Yield]Initializer[In]opt\n            //      [~GeneratorParameter]BindingIdentifier[?Yield]Initializer[In, ?Yield]opt\n            node.name = inGeneratorParameterContext() ? doInYieldContext(parseIdentifier) : parseIdentifier();\n            if (ts.getFullWidth(node.name) === 0 && node.flags === 0 && ts.isModifier(token)) {\n                // in cases like\n                // 'use strict' \n                // function foo(static)\n                // isParameter('static') === true, because of isModifier('static')\n                // however 'static' is not a legal identifier in a strict mode.\n                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)\n                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)\n                // to avoid this we'll advance cursor to the next token.\n                nextToken();\n            }\n            node.questionToken = parseOptionalToken(49 /* QuestionToken */);\n            node.type = parseParameterType();\n            node.initializer = inGeneratorParameterContext() ? doOutsideOfYieldContext(parseParameterInitializer) : parseParameterInitializer();\n            // Do not check for initializers in an ambient context for parameters. This is not\n            // a grammar error because the grammar allows arbitrary call signatures in\n            // an ambient context.\n            // It is actually not necessary for this to be an error at all. The reason is that\n            // function/constructor implementations are syntactically disallowed in ambient\n            // contexts. In addition, parameter initializers are semantically disallowed in\n            // overload signatures. So parameter initializers are transitively disallowed in\n            // ambient contexts.\n            return finishNode(node);\n        }\n        function parseParameterInitializer() {\n            return parseInitializer(true);\n        }\n        function fillSignature(returnToken, yieldAndGeneratorParameterContext, requireCompleteParameterList, signature) {\n            var returnTokenRequired = returnToken === 31 /* EqualsGreaterThanToken */;\n            signature.typeParameters = parseTypeParameters();\n            signature.parameters = parseParameterList(yieldAndGeneratorParameterContext, requireCompleteParameterList);\n            if (returnTokenRequired) {\n                parseExpected(returnToken);\n                signature.type = parseType();\n            }\n            else if (parseOptional(returnToken)) {\n                signature.type = parseType();\n            }\n        }\n        // Note: after careful analysis of the grammar, it does not appear to be possible to \n        // have 'Yield' And 'GeneratorParameter' not in sync.  i.e. any production calling\n        // this FormalParameters production either always sets both to true, or always sets\n        // both to false.  As such we only have a single parameter to represent both.\n        function parseParameterList(yieldAndGeneratorParameterContext, requireCompleteParameterList) {\n            // FormalParameters[Yield,GeneratorParameter] :\n            //      ...\n            //\n            // FormalParameter[Yield,GeneratorParameter] :\n            //      BindingElement[?Yield, ?GeneratorParameter]\n            //\n            // BindingElement[Yield, GeneratorParameter ] : See 13.2.3\n            //      SingleNameBinding[?Yield, ?GeneratorParameter]\n            //      [+GeneratorParameter]BindingPattern[?Yield, GeneratorParameter]Initializer[In]opt\n            //      [~GeneratorParameter]BindingPattern[?Yield]Initializer[In, ?Yield]opt\n            //\n            // SingleNameBinding[Yield, GeneratorParameter] : See 13.2.3\n            //      [+GeneratorParameter]BindingIdentifier[Yield]Initializer[In]opt\n            //      [~GeneratorParameter]BindingIdentifier[?Yield]Initializer[In, ?Yield]opt\n            if (parseExpected(15 /* OpenParenToken */)) {\n                var savedYieldContext = inYieldContext();\n                var savedGeneratorParameterContext = inGeneratorParameterContext();\n                setYieldContext(yieldAndGeneratorParameterContext);\n                setGeneratorParameterContext(yieldAndGeneratorParameterContext);\n                var result = parseDelimitedList(13 /* Parameters */, parseParameter);\n                setYieldContext(savedYieldContext);\n                setGeneratorParameterContext(savedGeneratorParameterContext);\n                if (!parseExpected(16 /* CloseParenToken */) && requireCompleteParameterList) {\n                    // Caller insisted that we had to end with a )   We didn't.  So just return\n                    // undefined here.\n                    return undefined;\n                }\n                return result;\n            }\n            // We didn't even have an open paren.  If the caller requires a complete parameter list,\n            // we definitely can't provide that.  However, if they're ok with an incomplete one,\n            // then just return an empty set of parameters.\n            return requireCompleteParameterList ? undefined : createMissingList();\n        }\n        function parseTypeMemberSemicolon() {\n            // Try to parse out an explicit or implicit (ASI) semicolon for a type member.  If we\n            // don't have one, then an appropriate error will be reported.\n            if (parseSemicolon()) {\n                return;\n            }\n            // If we don't have a semicolon, then the user may have written a comma instead \n            // accidently (pretty easy to do since commas are so prevalent as list separators). So\n            // just consume the comma and keep going.  Note: we'll have already reported the error\n            // about the missing semicolon above.\n            parseOptional(22 /* CommaToken */);\n        }\n        function parseSignatureMember(kind) {\n            var node = createNode(kind);\n            if (kind === 130 /* ConstructSignature */) {\n                parseExpected(86 /* NewKeyword */);\n            }\n            fillSignature(50 /* ColonToken */, false, false, node);\n            parseTypeMemberSemicolon();\n            return finishNode(node);\n        }\n        function isIndexSignature() {\n            if (token !== 17 /* OpenBracketToken */) {\n                return false;\n            }\n            return lookAhead(isUnambiguouslyIndexSignature);\n        }\n        function isUnambiguouslyIndexSignature() {\n            // The only allowed sequence is:\n            //\n            //   [id:\n            //\n            // However, for error recovery, we also check the following cases:\n            //\n            //   [...\n            //   [id,\n            //   [id?,\n            //   [id?:\n            //   [id?]\n            //   [public id\n            //   [private id\n            //   [protected id\n            //   []\n            //\n            nextToken();\n            if (token === 20 /* DotDotDotToken */ || token === 18 /* CloseBracketToken */) {\n                return true;\n            }\n            if (ts.isModifier(token)) {\n                nextToken();\n                if (isIdentifier()) {\n                    return true;\n                }\n            }\n            else if (!isIdentifier()) {\n                return false;\n            }\n            else {\n                // Skip the identifier\n                nextToken();\n            }\n            // A colon signifies a well formed indexer\n            // A comma should be a badly formed indexer because comma expressions are not allowed\n            // in computed properties.\n            if (token === 50 /* ColonToken */ || token === 22 /* CommaToken */) {\n                return true;\n            }\n            // Question mark could be an indexer with an optional property,\n            // or it could be a conditional expression in a computed property.\n            if (token !== 49 /* QuestionToken */) {\n                return false;\n            }\n            // If any of the following tokens are after the question mark, it cannot\n            // be a conditional expression, so treat it as an indexer.\n            nextToken();\n            return token === 50 /* ColonToken */ || token === 22 /* CommaToken */ || token === 18 /* CloseBracketToken */;\n        }\n        function parseIndexSignatureDeclaration(fullStart, modifiers) {\n            var node = createNode(131 /* IndexSignature */, fullStart);\n            setModifiers(node, modifiers);\n            node.parameters = parseBracketedList(13 /* Parameters */, parseParameter, 17 /* OpenBracketToken */, 18 /* CloseBracketToken */);\n            node.type = parseTypeAnnotation();\n            parseTypeMemberSemicolon();\n            return finishNode(node);\n        }\n        function parsePropertyOrMethodSignature() {\n            var fullStart = scanner.getStartPos();\n            var name = parsePropertyName();\n            var questionToken = parseOptionalToken(49 /* QuestionToken */);\n            if (token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) {\n                var method = createNode(125 /* Method */, fullStart);\n                method.name = name;\n                method.questionToken = questionToken;\n                // Method signatues don't exist in expression contexts.  So they have neither\n                // [Yield] nor [GeneratorParameter]\n                fillSignature(50 /* ColonToken */, false, false, method);\n                parseTypeMemberSemicolon();\n                return finishNode(method);\n            }\n            else {\n                var property = createNode(124 /* Property */, fullStart);\n                property.name = name;\n                property.questionToken = questionToken;\n                property.type = parseTypeAnnotation();\n                parseTypeMemberSemicolon();\n                return finishNode(property);\n            }\n        }\n        function isStartOfTypeMember() {\n            switch (token) {\n                case 15 /* OpenParenToken */:\n                case 23 /* LessThanToken */:\n                case 17 /* OpenBracketToken */:\n                    return true;\n                default:\n                    return isLiteralPropertyName() && lookAhead(isTypeMemberWithLiteralPropertyName);\n            }\n        }\n        function isTypeMemberWithLiteralPropertyName() {\n            nextToken();\n            return token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */ || token === 49 /* QuestionToken */ || token === 50 /* ColonToken */ || canParseSemicolon();\n        }\n        function parseTypeMember() {\n            switch (token) {\n                case 15 /* OpenParenToken */:\n                case 23 /* LessThanToken */:\n                    return parseSignatureMember(129 /* CallSignature */);\n                case 17 /* OpenBracketToken */:\n                    // Indexer or computed property\n                    return isIndexSignature() ? parseIndexSignatureDeclaration(scanner.getStartPos(), undefined) : parsePropertyOrMethodSignature();\n                case 86 /* NewKeyword */:\n                    if (lookAhead(isStartOfConstructSignature)) {\n                        return parseSignatureMember(130 /* ConstructSignature */);\n                    }\n                case 7 /* StringLiteral */:\n                case 6 /* NumericLiteral */:\n                    return parsePropertyOrMethodSignature();\n                default:\n                    if (isIdentifierOrKeyword()) {\n                        return parsePropertyOrMethodSignature();\n                    }\n            }\n        }\n        function isStartOfConstructSignature() {\n            nextToken();\n            return token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */;\n        }\n        function parseTypeLiteral() {\n            var node = createNode(136 /* TypeLiteral */);\n            node.members = parseObjectTypeMembers();\n            return finishNode(node);\n        }\n        function parseObjectTypeMembers() {\n            var members;\n            if (parseExpected(13 /* OpenBraceToken */)) {\n                members = parseList(5 /* TypeMembers */, false, parseTypeMember);\n                parseExpected(14 /* CloseBraceToken */);\n            }\n            else {\n                members = createMissingList();\n            }\n            return members;\n        }\n        function parseTupleType() {\n            var node = createNode(138 /* TupleType */);\n            node.elementTypes = parseBracketedList(16 /* TupleElementTypes */, parseType, 17 /* OpenBracketToken */, 18 /* CloseBracketToken */);\n            return finishNode(node);\n        }\n        function parseParenthesizedType() {\n            var node = createNode(140 /* ParenthesizedType */);\n            parseExpected(15 /* OpenParenToken */);\n            node.type = parseType();\n            parseExpected(16 /* CloseParenToken */);\n            return finishNode(node);\n        }\n        function parseFunctionOrConstructorType(kind) {\n            var node = createNode(kind);\n            if (kind === 134 /* ConstructorType */) {\n                parseExpected(86 /* NewKeyword */);\n            }\n            fillSignature(31 /* EqualsGreaterThanToken */, false, false, node);\n            return finishNode(node);\n        }\n        function parseKeywordAndNoDot() {\n            var node = parseTokenNode();\n            return token === 19 /* DotToken */ ? undefined : node;\n        }\n        function parseNonArrayType() {\n            switch (token) {\n                case 109 /* AnyKeyword */:\n                case 118 /* StringKeyword */:\n                case 116 /* NumberKeyword */:\n                case 110 /* BooleanKeyword */:\n                    // If these are followed by a dot, then parse these out as a dotted type reference instead.\n                    var node = tryParse(parseKeywordAndNoDot);\n                    return node || parseTypeReference();\n                case 97 /* VoidKeyword */:\n                    return parseTokenNode();\n                case 95 /* TypeOfKeyword */:\n                    return parseTypeQuery();\n                case 13 /* OpenBraceToken */:\n                    return parseTypeLiteral();\n                case 17 /* OpenBracketToken */:\n                    return parseTupleType();\n                case 15 /* OpenParenToken */:\n                    return parseParenthesizedType();\n                default:\n                    return parseTypeReference();\n            }\n        }\n        function isStartOfType() {\n            switch (token) {\n                case 109 /* AnyKeyword */:\n                case 118 /* StringKeyword */:\n                case 116 /* NumberKeyword */:\n                case 110 /* BooleanKeyword */:\n                case 97 /* VoidKeyword */:\n                case 95 /* TypeOfKeyword */:\n                case 13 /* OpenBraceToken */:\n                case 17 /* OpenBracketToken */:\n                case 23 /* LessThanToken */:\n                case 86 /* NewKeyword */:\n                    return true;\n                case 15 /* OpenParenToken */:\n                    // Only consider '(' the start of a type if followed by ')', '...', an identifier, a modifier,\n                    // or something that starts a type. We don't want to consider things like '(1)' a type.\n                    return lookAhead(isStartOfParenthesizedOrFunctionType);\n                default:\n                    return isIdentifier();\n            }\n        }\n        function isStartOfParenthesizedOrFunctionType() {\n            nextToken();\n            return token === 16 /* CloseParenToken */ || isStartOfParameter() || isStartOfType();\n        }\n        function parseArrayTypeOrHigher() {\n            var type = parseNonArrayType();\n            while (!scanner.hasPrecedingLineBreak() && parseOptional(17 /* OpenBracketToken */)) {\n                parseExpected(18 /* CloseBracketToken */);\n                var node = createNode(137 /* ArrayType */, type.pos);\n                node.elementType = type;\n                type = finishNode(node);\n            }\n            return type;\n        }\n        function parseUnionTypeOrHigher() {\n            var type = parseArrayTypeOrHigher();\n            if (token === 43 /* BarToken */) {\n                var types = [type];\n                types.pos = type.pos;\n                while (parseOptional(43 /* BarToken */)) {\n                    types.push(parseArrayTypeOrHigher());\n                }\n                types.end = getNodeEnd();\n                var node = createNode(139 /* UnionType */, type.pos);\n                node.types = types;\n                type = finishNode(node);\n            }\n            return type;\n        }\n        function isStartOfFunctionType() {\n            if (token === 23 /* LessThanToken */) {\n                return true;\n            }\n            return token === 15 /* OpenParenToken */ && lookAhead(isUnambiguouslyStartOfFunctionType);\n        }\n        function isUnambiguouslyStartOfFunctionType() {\n            nextToken();\n            if (token === 16 /* CloseParenToken */ || token === 20 /* DotDotDotToken */) {\n                // ( )\n                // ( ...\n                return true;\n            }\n            if (isIdentifier() || ts.isModifier(token)) {\n                nextToken();\n                if (token === 50 /* ColonToken */ || token === 22 /* CommaToken */ || token === 49 /* QuestionToken */ || token === 51 /* EqualsToken */ || isIdentifier() || ts.isModifier(token)) {\n                    // ( id :\n                    // ( id ,\n                    // ( id ?\n                    // ( id =\n                    // ( modifier id\n                    return true;\n                }\n                if (token === 16 /* CloseParenToken */) {\n                    nextToken();\n                    if (token === 31 /* EqualsGreaterThanToken */) {\n                        // ( id ) =>\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        function parseType() {\n            // The rules about 'yield' only apply to actual code/expression contexts.  They don't\n            // apply to 'type' contexts.  So we disable these parameters here before moving on.\n            var savedYieldContext = inYieldContext();\n            var savedGeneratorParameterContext = inGeneratorParameterContext();\n            setYieldContext(false);\n            setGeneratorParameterContext(false);\n            var result = parseTypeWorker();\n            setYieldContext(savedYieldContext);\n            setGeneratorParameterContext(savedGeneratorParameterContext);\n            return result;\n        }\n        function parseTypeWorker() {\n            if (isStartOfFunctionType()) {\n                return parseFunctionOrConstructorType(133 /* FunctionType */);\n            }\n            if (token === 86 /* NewKeyword */) {\n                return parseFunctionOrConstructorType(134 /* ConstructorType */);\n            }\n            return parseUnionTypeOrHigher();\n        }\n        function parseTypeAnnotation() {\n            return parseOptional(50 /* ColonToken */) ? parseType() : undefined;\n        }\n        // EXPRESSIONS\n        function isStartOfExpression() {\n            switch (token) {\n                case 91 /* ThisKeyword */:\n                case 89 /* SuperKeyword */:\n                case 87 /* NullKeyword */:\n                case 93 /* TrueKeyword */:\n                case 78 /* FalseKeyword */:\n                case 6 /* NumericLiteral */:\n                case 7 /* StringLiteral */:\n                case 9 /* NoSubstitutionTemplateLiteral */:\n                case 10 /* TemplateHead */:\n                case 15 /* OpenParenToken */:\n                case 17 /* OpenBracketToken */:\n                case 13 /* OpenBraceToken */:\n                case 81 /* FunctionKeyword */:\n                case 86 /* NewKeyword */:\n                case 35 /* SlashToken */:\n                case 55 /* SlashEqualsToken */:\n                case 32 /* PlusToken */:\n                case 33 /* MinusToken */:\n                case 46 /* TildeToken */:\n                case 45 /* ExclamationToken */:\n                case 72 /* DeleteKeyword */:\n                case 95 /* TypeOfKeyword */:\n                case 97 /* VoidKeyword */:\n                case 37 /* PlusPlusToken */:\n                case 38 /* MinusMinusToken */:\n                case 23 /* LessThanToken */:\n                case 63 /* Identifier */:\n                case 108 /* YieldKeyword */:\n                    // Yield always starts an expression.  Either it is an identifier (in which case\n                    // it is definitely an expression).  Or it's a keyword (either because we're in\n                    // a generator, or in strict mode (or both)) and it started a yield expression.\n                    return true;\n                default:\n                    // Error tolerance.  If we see the start of some binary operator, we consider\n                    // that the start of an expression.  That way we'll parse out a missing identifier,\n                    // give a good message about an identifier being missing, and then consume the\n                    // rest of the binary expression.\n                    if (isBinaryOperator()) {\n                        return true;\n                    }\n                    return isIdentifier();\n            }\n        }\n        function isStartOfExpressionStatement() {\n            // As per the grammar, neither '{' nor 'function' can start an expression statement.\n            return token !== 13 /* OpenBraceToken */ && token !== 81 /* FunctionKeyword */ && isStartOfExpression();\n        }\n        function parseExpression() {\n            // Expression[in]:\n            //      AssignmentExpression[in] \n            //      Expression[in] , AssignmentExpression[in]\n            var expr = parseAssignmentExpressionOrHigher();\n            while (parseOptional(22 /* CommaToken */)) {\n                expr = makeBinaryExpression(expr, 22 /* CommaToken */, parseAssignmentExpressionOrHigher());\n            }\n            return expr;\n        }\n        function parseInitializer(inParameter) {\n            if (token !== 51 /* EqualsToken */) {\n                // It's not uncommon during typing for the user to miss writing the '=' token.  Check if\n                // there is no newline after the last token and if we're on an expression.  If so, parse\n                // this as an equals-value clause with a missing equals.\n                // NOTE: There are two places where we allow equals-value clauses.  The first is in a \n                // variable declarator.  The second is with a parameter.  For variable declarators\n                // it's more likely that a { would be a allowed (as an object literal).  While this\n                // is also allowed for parameters, the risk is that we consume the { as an object\n                // literal when it really will be for the block following the parameter.\n                if (scanner.hasPrecedingLineBreak() || (inParameter && token === 13 /* OpenBraceToken */) || !isStartOfExpression()) {\n                    // preceding line break, open brace in a parameter (likely a function body) or current token is not an expression - \n                    // do not try to parse initializer\n                    return undefined;\n                }\n            }\n            // Initializer[In, Yield] :\n            //     = AssignmentExpression[?In, ?Yield]\n            parseExpected(51 /* EqualsToken */);\n            return parseAssignmentExpressionOrHigher();\n        }\n        function parseAssignmentExpressionOrHigher() {\n            //  AssignmentExpression[in,yield]:\n            //      1) ConditionalExpression[?in,?yield]\n            //      2) LeftHandSideExpression = AssignmentExpression[?in,?yield]\n            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[?in,?yield]\n            //      4) ArrowFunctionExpression[?in,?yield]\n            //      5) [+Yield] YieldExpression[?In]\n            //\n            // Note: for ease of implementation we treat productions '2' and '3' as the same thing. \n            // (i.e. they're both BinaryExpressions with an assignment operator in it).\n            // First, do the simple check if we have a YieldExpression (production '5').\n            if (isYieldExpression()) {\n                return parseYieldExpression();\n            }\n            // Then, check if we have an arrow function (production '4') that starts with a parenthesized\n            // parameter list. If we do, we must *not* recurse for productions 1, 2 or 3. An ArrowFunction is\n            // not a  LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done \n            // with AssignmentExpression if we see one.\n            var arrowExpression = tryParseParenthesizedArrowFunctionExpression();\n            if (arrowExpression) {\n                return arrowExpression;\n            }\n            // Now try to see if we're in production '1', '2' or '3'.  A conditional expression can\n            // start with a LogicalOrExpression, while the assignment productions can only start with\n            // LeftHandSideExpressions.\n            //\n            // So, first, we try to just parse out a BinaryExpression.  If we get something that is a \n            // LeftHandSide or higher, then we can try to parse out the assignment expression part.  \n            // Otherwise, we try to parse out the conditional expression bit.  We want to allow any \n            // binary expression here, so we pass in the 'lowest' precedence here so that it matches\n            // and consumes anything.\n            var expr = parseBinaryExpressionOrHigher(0);\n            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized\n            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single\n            // identifier and the current token is an arrow.\n            if (expr.kind === 63 /* Identifier */ && token === 31 /* EqualsGreaterThanToken */) {\n                return parseSimpleArrowFunctionExpression(expr);\n            }\n            // Now see if we might be in cases '2' or '3'.\n            // If the expression was a LHS expression, and we have an assignment operator, then \n            // we're in '2' or '3'. Consume the assignment and return.\n            //\n            // Note: we call reScanGreaterToken so that we get an appropriately merged token\n            // for cases like > > =  becoming >>=\n            if (isLeftHandSideExpression(expr) && isAssignmentOperator(reScanGreaterToken())) {\n                var operator = token;\n                nextToken();\n                return makeBinaryExpression(expr, operator, parseAssignmentExpressionOrHigher());\n            }\n            // It wasn't an assignment or a lambda.  This is a conditional expression:\n            return parseConditionalExpressionRest(expr);\n        }\n        function isYieldExpression() {\n            if (token === 108 /* YieldKeyword */) {\n                // If we have a 'yield' keyword, and htis is a context where yield expressions are \n                // allowed, then definitely parse out a yield expression.\n                if (inYieldContext()) {\n                    return true;\n                }\n                if (inStrictModeContext()) {\n                    // If we're in strict mode, then 'yield' is a keyword, could only ever start\n                    // a yield expression.\n                    return true;\n                }\n                // We're in a context where 'yield expr' is not allowed.  However, if we can\n                // definitely tell that the user was trying to parse a 'yield expr' and not\n                // just a normal expr that start with a 'yield' identifier, then parse out\n                // a 'yield expr'.  We can then report an error later that they are only \n                // allowed in generator expressions.\n                // \n                // for example, if we see 'yield(foo)', then we'll have to treat that as an\n                // invocation expression of something called 'yield'.  However, if we have\n                // 'yield foo' then that is not legal as a normal expression, so we can \n                // definitely recognize this as a yield expression.\n                //\n                // for now we just check if the next token is an identifier.  More heuristics\n                // can be added here later as necessary.  We just need to make sure that we\n                // don't accidently consume something legal.\n                return lookAhead(nextTokenIsIdentifierOnSameLine);\n            }\n            return false;\n        }\n        function nextTokenIsIdentifierOnSameLine() {\n            nextToken();\n            return !scanner.hasPrecedingLineBreak() && isIdentifier();\n        }\n        function parseYieldExpression() {\n            var node = createNode(160 /* YieldExpression */);\n            // YieldExpression[In] :\n            //      yield\n            //      yield [no LineTerminator here] [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]\n            //      yield [no LineTerminator here] * [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]\n            nextToken();\n            if (!scanner.hasPrecedingLineBreak() && (token === 34 /* AsteriskToken */ || isStartOfExpression())) {\n                node.asteriskToken = parseOptionalToken(34 /* AsteriskToken */);\n                node.expression = parseAssignmentExpressionOrHigher();\n                return finishNode(node);\n            }\n            else {\n                // if the next token is not on the same line as yield.  or we don't have an '*' or \n                // the start of an expressin, then this is just a simple \"yield\" expression.\n                return finishNode(node);\n            }\n        }\n        function parseSimpleArrowFunctionExpression(identifier) {\n            ts.Debug.assert(token === 31 /* EqualsGreaterThanToken */, \"parseSimpleArrowFunctionExpression should only have been called if we had a =>\");\n            var node = createNode(151 /* ArrowFunction */, identifier.pos);\n            var parameter = createNode(123 /* Parameter */, identifier.pos);\n            parameter.name = identifier;\n            finishNode(parameter);\n            node.parameters = [parameter];\n            node.parameters.pos = parameter.pos;\n            node.parameters.end = parameter.end;\n            parseExpected(31 /* EqualsGreaterThanToken */);\n            node.body = parseArrowFunctionExpressionBody();\n            return finishNode(node);\n        }\n        function tryParseParenthesizedArrowFunctionExpression() {\n            var triState = isParenthesizedArrowFunctionExpression();\n            if (triState === 0 /* False */) {\n                // It's definitely not a parenthesized arrow function expression.\n                return undefined;\n            }\n            // If we definitely have an arrow function, then we can just parse one, not requiring a\n            // following => or { token. Otherwise, we *might* have an arrow function.  Try to parse\n            // it out, but don't allow any ambiguity, and return 'undefined' if this could be an\n            // expression instead.\n            var arrowFunction = triState === 1 /* True */ ? parseParenthesizedArrowFunctionExpressionHead(true) : tryParse(parsePossibleParenthesizedArrowFunctionExpressionHead);\n            if (!arrowFunction) {\n                // Didn't appear to actually be a parenthesized arrow function.  Just bail out.\n                return undefined;\n            }\n            // If we have an arrow, then try to parse the body. Even if not, try to parse if we \n            // have an opening brace, just in case we're in an error state.\n            if (parseExpected(31 /* EqualsGreaterThanToken */) || token === 13 /* OpenBraceToken */) {\n                arrowFunction.body = parseArrowFunctionExpressionBody();\n            }\n            else {\n                // If not, we're probably better off bailing out and returning a bogus function expression.\n                arrowFunction.body = parseIdentifier();\n            }\n            return finishNode(arrowFunction);\n        }\n        //  True        -> We definitely expect a parenthesized arrow function here.\n        //  False       -> There *cannot* be a parenthesized arrow function here.\n        //  Unknown     -> There *might* be a parenthesized arrow function here.\n        //                 Speculatively look ahead to be sure, and rollback if not.\n        function isParenthesizedArrowFunctionExpression() {\n            if (token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) {\n                return lookAhead(isParenthesizedArrowFunctionExpressionWorker);\n            }\n            if (token === 31 /* EqualsGreaterThanToken */) {\n                // ERROR RECOVERY TWEAK:\n                // If we see a standalone => try to parse it as an arrow function expression as that's\n                // likely what the user intended to write.\n                return 1 /* True */;\n            }\n            // Definitely not a parenthesized arrow function.\n            return 0 /* False */;\n        }\n        function isParenthesizedArrowFunctionExpressionWorker() {\n            var first = token;\n            var second = nextToken();\n            if (first === 15 /* OpenParenToken */) {\n                if (second === 16 /* CloseParenToken */) {\n                    // Simple cases: \"() =>\", \"(): \", and  \"() {\".\n                    // This is an arrow function with no parameters.\n                    // The last one is not actually an arrow function,\n                    // but this is probably what the user intended.\n                    var third = nextToken();\n                    switch (third) {\n                        case 31 /* EqualsGreaterThanToken */:\n                        case 50 /* ColonToken */:\n                        case 13 /* OpenBraceToken */:\n                            return 1 /* True */;\n                        default:\n                            return 0 /* False */;\n                    }\n                }\n                // Simple case: \"(...\"\n                // This is an arrow function with a rest parameter.\n                if (second === 20 /* DotDotDotToken */) {\n                    return 1 /* True */;\n                }\n                // If we had \"(\" followed by something that's not an identifier,\n                // then this definitely doesn't look like a lambda.\n                // Note: we could be a little more lenient and allow\n                // \"(public\" or \"(private\". These would not ever actually be allowed,\n                // but we could provide a good error message instead of bailing out.\n                if (!isIdentifier()) {\n                    return 0 /* False */;\n                }\n                // If we have something like \"(a:\", then we must have a\n                // type-annotated parameter in an arrow function expression.\n                if (nextToken() === 50 /* ColonToken */) {\n                    return 1 /* True */;\n                }\n                // This *could* be a parenthesized arrow function.\n                // Return Unknown to let the caller know.\n                return 2 /* Unknown */;\n            }\n            else {\n                ts.Debug.assert(first === 23 /* LessThanToken */);\n                // If we have \"<\" not followed by an identifier,\n                // then this definitely is not an arrow function.\n                if (!isIdentifier()) {\n                    return 0 /* False */;\n                }\n                // This *could* be a parenthesized arrow function.\n                return 2 /* Unknown */;\n            }\n        }\n        function parsePossibleParenthesizedArrowFunctionExpressionHead() {\n            return parseParenthesizedArrowFunctionExpressionHead(false);\n        }\n        function parseParenthesizedArrowFunctionExpressionHead(allowAmbiguity) {\n            var node = createNode(151 /* ArrowFunction */);\n            // Arrow functions are never generators.\n            //\n            // If we're speculatively parsing a signature for a parenthesized arrow function, then\n            // we have to have a complete parameter list.  Otherwise we might see something like\n            // a => (b => c)\n            // And think that \"(b =>\" was actually a parenthesized arrow function with a missing \n            // close paren.\n            fillSignature(50 /* ColonToken */, false, !allowAmbiguity, node);\n            // If we couldn't get parameters, we definitely could not parse out an arrow function.\n            if (!node.parameters) {\n                return undefined;\n            }\n            // Parsing a signature isn't enough.\n            // Parenthesized arrow signatures often look like other valid expressions.\n            // For instance:\n            //  - \"(x = 10)\" is an assignment expression parsed as a signature with a default parameter value.\n            //  - \"(x,y)\" is a comma expression parsed as a signature with two parameters.\n            //  - \"a ? (b): c\" will have \"(b):\" parsed as a signature with a return type annotation.\n            //\n            // So we need just a bit of lookahead to ensure that it can only be a signature.\n            if (!allowAmbiguity && token !== 31 /* EqualsGreaterThanToken */ && token !== 13 /* OpenBraceToken */) {\n                // Returning undefined here will cause our caller to rewind to where we started from.\n                return undefined;\n            }\n            return node;\n        }\n        function parseArrowFunctionExpressionBody() {\n            if (token === 13 /* OpenBraceToken */) {\n                return parseFunctionBlock(false, false);\n            }\n            if (isStatement(true) && !isStartOfExpressionStatement() && token !== 81 /* FunctionKeyword */) {\n                // Check if we got a plain statement (i.e. no expression-statements, no functions expressions/declarations)\n                //\n                // Here we try to recover from a potential error situation in the case where the \n                // user meant to supply a block. For example, if the user wrote:\n                //\n                //  a =>\n                //      var v = 0;\n                //  }\n                //\n                // they may be missing an open brace.  Check to see if that's the case so we can\n                // try to recover better.  If we don't do this, then the next close curly we see may end\n                // up preemptively closing the containing construct.\n                //\n                // Note: even when 'ignoreMissingOpenBrace' is passed as true, parseBody will still error.\n                return parseFunctionBlock(false, true);\n            }\n            return parseAssignmentExpressionOrHigher();\n        }\n        function parseConditionalExpressionRest(leftOperand) {\n            // Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.\n            if (!parseOptional(49 /* QuestionToken */)) {\n                return leftOperand;\n            }\n            // Note: we explicitly 'allowIn' in the whenTrue part of the condition expression, and \n            // we do not that for the 'whenFalse' part.  \n            var node = createNode(158 /* ConditionalExpression */, leftOperand.pos);\n            node.condition = leftOperand;\n            node.whenTrue = allowInAnd(parseAssignmentExpressionOrHigher);\n            parseExpected(50 /* ColonToken */);\n            node.whenFalse = parseAssignmentExpressionOrHigher();\n            return finishNode(node);\n        }\n        function parseBinaryExpressionOrHigher(precedence) {\n            var leftOperand = parseUnaryExpressionOrHigher();\n            return parseBinaryExpressionRest(precedence, leftOperand);\n        }\n        function parseBinaryExpressionRest(precedence, leftOperand) {\n            while (true) {\n                // We either have a binary operator here, or we're finished.  We call \n                // reScanGreaterToken so that we merge token sequences like > and = into >=\n                reScanGreaterToken();\n                var newPrecedence = getBinaryOperatorPrecedence();\n                // Check the precedence to see if we should \"take\" this operator\n                if (newPrecedence <= precedence) {\n                    break;\n                }\n                if (token === 84 /* InKeyword */ && inDisallowInContext()) {\n                    break;\n                }\n                var operator = token;\n                nextToken();\n                leftOperand = makeBinaryExpression(leftOperand, operator, parseBinaryExpressionOrHigher(newPrecedence));\n            }\n            return leftOperand;\n        }\n        function isBinaryOperator() {\n            if (inDisallowInContext() && token === 84 /* InKeyword */) {\n                return false;\n            }\n            return getBinaryOperatorPrecedence() > 0;\n        }\n        function getBinaryOperatorPrecedence() {\n            switch (token) {\n                case 48 /* BarBarToken */:\n                    return 1;\n                case 47 /* AmpersandAmpersandToken */:\n                    return 2;\n                case 43 /* BarToken */:\n                    return 3;\n                case 44 /* CaretToken */:\n                    return 4;\n                case 42 /* AmpersandToken */:\n                    return 5;\n                case 27 /* EqualsEqualsToken */:\n                case 28 /* ExclamationEqualsToken */:\n                case 29 /* EqualsEqualsEqualsToken */:\n                case 30 /* ExclamationEqualsEqualsToken */:\n                    return 6;\n                case 23 /* LessThanToken */:\n                case 24 /* GreaterThanToken */:\n                case 25 /* LessThanEqualsToken */:\n                case 26 /* GreaterThanEqualsToken */:\n                case 85 /* InstanceOfKeyword */:\n                case 84 /* InKeyword */:\n                    return 7;\n                case 39 /* LessThanLessThanToken */:\n                case 40 /* GreaterThanGreaterThanToken */:\n                case 41 /* GreaterThanGreaterThanGreaterThanToken */:\n                    return 8;\n                case 32 /* PlusToken */:\n                case 33 /* MinusToken */:\n                    return 9;\n                case 34 /* AsteriskToken */:\n                case 35 /* SlashToken */:\n                case 36 /* PercentToken */:\n                    return 10;\n            }\n            // -1 is lower than all other precedences.  Returning it will cause binary expression\n            // parsing to stop.\n            return -1;\n        }\n        function makeBinaryExpression(left, operator, right) {\n            var node = createNode(157 /* BinaryExpression */, left.pos);\n            node.left = left;\n            node.operator = operator;\n            node.right = right;\n            return finishNode(node);\n        }\n        function parsePrefixUnaryExpression() {\n            var node = createNode(155 /* PrefixUnaryExpression */);\n            node.operator = token;\n            nextToken();\n            node.operand = parseUnaryExpressionOrHigher();\n            return finishNode(node);\n        }\n        function parseDeleteExpression() {\n            var node = createNode(152 /* DeleteExpression */);\n            nextToken();\n            node.expression = parseUnaryExpressionOrHigher();\n            return finishNode(node);\n        }\n        function parseTypeOfExpression() {\n            var node = createNode(153 /* TypeOfExpression */);\n            nextToken();\n            node.expression = parseUnaryExpressionOrHigher();\n            return finishNode(node);\n        }\n        function parseVoidExpression() {\n            var node = createNode(154 /* VoidExpression */);\n            nextToken();\n            node.expression = parseUnaryExpressionOrHigher();\n            return finishNode(node);\n        }\n        function parseUnaryExpressionOrHigher() {\n            switch (token) {\n                case 32 /* PlusToken */:\n                case 33 /* MinusToken */:\n                case 46 /* TildeToken */:\n                case 45 /* ExclamationToken */:\n                case 37 /* PlusPlusToken */:\n                case 38 /* MinusMinusToken */:\n                    return parsePrefixUnaryExpression();\n                case 72 /* DeleteKeyword */:\n                    return parseDeleteExpression();\n                case 95 /* TypeOfKeyword */:\n                    return parseTypeOfExpression();\n                case 97 /* VoidKeyword */:\n                    return parseVoidExpression();\n                case 23 /* LessThanToken */:\n                    return parseTypeAssertion();\n                default:\n                    return parsePostfixExpressionOrHigher();\n            }\n        }\n        function parsePostfixExpressionOrHigher() {\n            var expression = parseLeftHandSideExpressionOrHigher();\n            ts.Debug.assert(isLeftHandSideExpression(expression));\n            if ((token === 37 /* PlusPlusToken */ || token === 38 /* MinusMinusToken */) && !scanner.hasPrecedingLineBreak()) {\n                var node = createNode(156 /* PostfixUnaryExpression */, expression.pos);\n                node.operand = expression;\n                node.operator = token;\n                nextToken();\n                return finishNode(node);\n            }\n            return expression;\n        }\n        function parseLeftHandSideExpressionOrHigher() {\n            // Original Ecma:\n            // LeftHandSideExpression: See 11.2 \n            //      NewExpression\n            //      CallExpression \n            //\n            // Our simplification:\n            //\n            // LeftHandSideExpression: See 11.2 \n            //      MemberExpression  \n            //      CallExpression \n            //\n            // See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with\n            // MemberExpression to make our lives easier.\n            //\n            // to best understand the below code, it's important to see how CallExpression expands\n            // out into its own productions:\n            //\n            // CallExpression:\n            //      MemberExpression Arguments \n            //      CallExpression Arguments\n            //      CallExpression[Expression]\n            //      CallExpression.IdentifierName\n            //      super   (   ArgumentListopt   )\n            //      super.IdentifierName\n            //\n            // Because of the recursion in these calls, we need to bottom out first.  There are two \n            // bottom out states we can run into.  Either we see 'super' which must start either of\n            // the last two CallExpression productions.  Or we have a MemberExpression which either\n            // completes the LeftHandSideExpression, or starts the beginning of the first four\n            // CallExpression productions.\n            var expression = token === 89 /* SuperKeyword */ ? parseSuperExpression() : parseMemberExpressionOrHigher();\n            // Now, we *may* be complete.  However, we might have consumed the start of a \n            // CallExpression.  As such, we need to consume the rest of it here to be complete.\n            return parseCallExpressionRest(expression);\n        }\n        function parseMemberExpressionOrHigher() {\n            // Note: to make our lives simpler, we decompose the the NewExpression productions and\n            // place ObjectCreationExpression and FunctionExpression into PrimaryExpression.\n            // like so:\n            //\n            //   PrimaryExpression : See 11.1 \n            //      this\n            //      Identifier\n            //      Literal\n            //      ArrayLiteral\n            //      ObjectLiteral\n            //      (Expression) \n            //      FunctionExpression\n            //      new MemberExpression Arguments?\n            //\n            //   MemberExpression : See 11.2 \n            //      PrimaryExpression \n            //      MemberExpression[Expression]\n            //      MemberExpression.IdentifierName\n            //\n            //   CallExpression : See 11.2 \n            //      MemberExpression \n            //      CallExpression Arguments\n            //      CallExpression[Expression]\n            //      CallExpression.IdentifierName \n            //\n            // Technically this is ambiguous.  i.e. CallExpression defines:\n            //\n            //   CallExpression:\n            //      CallExpression Arguments\n            // \n            // If you see: \"new Foo()\"\n            //\n            // Then that could be treated as a single ObjectCreationExpression, or it could be \n            // treated as the invocation of \"new Foo\".  We disambiguate that in code (to match\n            // the original grammar) by making sure that if we see an ObjectCreationExpression\n            // we always consume arguments if they are there. So we treat \"new Foo()\" as an\n            // object creation only, and not at all as an invocation)  Another way to think \n            // about this is that for every \"new\" that we see, we will consume an argument list if\n            // it is there as part of the *associated* object creation node.  Any additional\n            // argument lists we see, will become invocation expressions.\n            //\n            // Because there are no other places in the grammar now that refer to FunctionExpression\n            // or ObjectCreationExpression, it is safe to push down into the PrimaryExpression\n            // production.\n            //\n            // Because CallExpression and MemberExpression are left recursive, we need to bottom out\n            // of the recursion immediately.  So we parse out a primary expression to start with.\n            var expression = parsePrimaryExpression();\n            return parseMemberExpressionRest(expression);\n        }\n        function parseSuperExpression() {\n            var expression = parseTokenNode();\n            if (token === 15 /* OpenParenToken */ || token === 19 /* DotToken */) {\n                return expression;\n            }\n            // If we have seen \"super\" it must be followed by '(' or '.'.\n            // If it wasn't then just try to parse out a '.' and report an error.\n            var node = createNode(143 /* PropertyAccessExpression */, expression.pos);\n            node.expression = expression;\n            parseExpected(19 /* DotToken */, ts.Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);\n            node.name = parseRightSideOfDot(true);\n            return finishNode(node);\n        }\n        function parseTypeAssertion() {\n            var node = createNode(148 /* TypeAssertionExpression */);\n            parseExpected(23 /* LessThanToken */);\n            node.type = parseType();\n            parseExpected(24 /* GreaterThanToken */);\n            node.expression = parseUnaryExpressionOrHigher();\n            return finishNode(node);\n        }\n        function parseMemberExpressionRest(expression) {\n            while (true) {\n                var dotOrBracketStart = scanner.getTokenPos();\n                if (parseOptional(19 /* DotToken */)) {\n                    var propertyAccess = createNode(143 /* PropertyAccessExpression */, expression.pos);\n                    propertyAccess.expression = expression;\n                    propertyAccess.name = parseRightSideOfDot(true);\n                    expression = finishNode(propertyAccess);\n                    continue;\n                }\n                if (parseOptional(17 /* OpenBracketToken */)) {\n                    var indexedAccess = createNode(144 /* ElementAccessExpression */, expression.pos);\n                    indexedAccess.expression = expression;\n                    // It's not uncommon for a user to write: \"new Type[]\".\n                    // Check for that common pattern and report a better error message.\n                    if (token !== 18 /* CloseBracketToken */) {\n                        indexedAccess.argumentExpression = allowInAnd(parseExpression);\n                        if (indexedAccess.argumentExpression.kind === 7 /* StringLiteral */ || indexedAccess.argumentExpression.kind === 6 /* NumericLiteral */) {\n                            var literal = indexedAccess.argumentExpression;\n                            literal.text = internIdentifier(literal.text);\n                        }\n                    }\n                    parseExpected(18 /* CloseBracketToken */);\n                    expression = finishNode(indexedAccess);\n                    continue;\n                }\n                if (token === 9 /* NoSubstitutionTemplateLiteral */ || token === 10 /* TemplateHead */) {\n                    var tagExpression = createNode(147 /* TaggedTemplateExpression */, expression.pos);\n                    tagExpression.tag = expression;\n                    tagExpression.template = token === 9 /* NoSubstitutionTemplateLiteral */ ? parseLiteralNode() : parseTemplateExpression();\n                    expression = finishNode(tagExpression);\n                    continue;\n                }\n                return expression;\n            }\n        }\n        function parseCallExpressionRest(expression) {\n            while (true) {\n                expression = parseMemberExpressionRest(expression);\n                if (token === 23 /* LessThanToken */) {\n                    // See if this is the start of a generic invocation.  If so, consume it and\n                    // keep checking for postfix expressions.  Otherwise, it's just a '<' that's \n                    // part of an arithmetic expression.  Break out so we consume it higher in the\n                    // stack.\n                    var typeArguments = tryParse(parseTypeArgumentsInExpression);\n                    if (!typeArguments) {\n                        return expression;\n                    }\n                    var callExpr = createNode(145 /* CallExpression */, expression.pos);\n                    callExpr.expression = expression;\n                    callExpr.typeArguments = typeArguments;\n                    callExpr.arguments = parseArgumentList();\n                    expression = finishNode(callExpr);\n                    continue;\n                }\n                else if (token === 15 /* OpenParenToken */) {\n                    var callExpr = createNode(145 /* CallExpression */, expression.pos);\n                    callExpr.expression = expression;\n                    callExpr.arguments = parseArgumentList();\n                    expression = finishNode(callExpr);\n                    continue;\n                }\n                return expression;\n            }\n        }\n        function parseArgumentList() {\n            parseExpected(15 /* OpenParenToken */);\n            var result = parseDelimitedList(10 /* ArgumentExpressions */, parseArgumentExpression);\n            parseExpected(16 /* CloseParenToken */);\n            return result;\n        }\n        function parseTypeArgumentsInExpression() {\n            if (!parseOptional(23 /* LessThanToken */)) {\n                return undefined;\n            }\n            var typeArguments = parseDelimitedList(15 /* TypeArguments */, parseType);\n            if (!parseExpected(24 /* GreaterThanToken */)) {\n                // If it doesn't have the closing >  then it's definitely not an type argument list.\n                return undefined;\n            }\n            // If we have a '<', then only parse this as a arugment list if the type arguments\n            // are complete and we have an open paren.  if we don't, rewind and return nothing.\n            return typeArguments && canFollowTypeArgumentsInExpression() ? typeArguments : undefined;\n        }\n        function canFollowTypeArgumentsInExpression() {\n            switch (token) {\n                case 15 /* OpenParenToken */:\n                case 19 /* DotToken */:\n                case 16 /* CloseParenToken */:\n                case 18 /* CloseBracketToken */:\n                case 50 /* ColonToken */:\n                case 21 /* SemicolonToken */:\n                case 22 /* CommaToken */:\n                case 49 /* QuestionToken */:\n                case 27 /* EqualsEqualsToken */:\n                case 29 /* EqualsEqualsEqualsToken */:\n                case 28 /* ExclamationEqualsToken */:\n                case 30 /* ExclamationEqualsEqualsToken */:\n                case 47 /* AmpersandAmpersandToken */:\n                case 48 /* BarBarToken */:\n                case 44 /* CaretToken */:\n                case 42 /* AmpersandToken */:\n                case 43 /* BarToken */:\n                case 14 /* CloseBraceToken */:\n                case 1 /* EndOfFileToken */:\n                    // these cases can't legally follow a type arg list.  However, they're not legal \n                    // expressions either.  The user is probably in the middle of a generic type. So\n                    // treat it as such.\n                    return true;\n                default:\n                    // Anything else treat as an expression.\n                    return false;\n            }\n        }\n        function parsePrimaryExpression() {\n            switch (token) {\n                case 6 /* NumericLiteral */:\n                case 7 /* StringLiteral */:\n                case 9 /* NoSubstitutionTemplateLiteral */:\n                    return parseLiteralNode();\n                case 91 /* ThisKeyword */:\n                case 89 /* SuperKeyword */:\n                case 87 /* NullKeyword */:\n                case 93 /* TrueKeyword */:\n                case 78 /* FalseKeyword */:\n                    return parseTokenNode();\n                case 15 /* OpenParenToken */:\n                    return parseParenthesizedExpression();\n                case 17 /* OpenBracketToken */:\n                    return parseArrayLiteralExpression();\n                case 13 /* OpenBraceToken */:\n                    return parseObjectLiteralExpression();\n                case 81 /* FunctionKeyword */:\n                    return parseFunctionExpression();\n                case 86 /* NewKeyword */:\n                    return parseNewExpression();\n                case 35 /* SlashToken */:\n                case 55 /* SlashEqualsToken */:\n                    if (reScanSlashToken() === 8 /* RegularExpressionLiteral */) {\n                        return parseLiteralNode();\n                    }\n                    break;\n                case 10 /* TemplateHead */:\n                    return parseTemplateExpression();\n            }\n            return parseIdentifier(ts.Diagnostics.Expression_expected);\n        }\n        function parseParenthesizedExpression() {\n            var node = createNode(149 /* ParenthesizedExpression */);\n            parseExpected(15 /* OpenParenToken */);\n            node.expression = allowInAnd(parseExpression);\n            parseExpected(16 /* CloseParenToken */);\n            return finishNode(node);\n        }\n        function parseAssignmentExpressionOrOmittedExpression() {\n            return token === 22 /* CommaToken */ ? createNode(161 /* OmittedExpression */) : parseAssignmentExpressionOrHigher();\n        }\n        function parseArrayLiteralElement() {\n            return parseAssignmentExpressionOrOmittedExpression();\n        }\n        function parseArgumentExpression() {\n            return allowInAnd(parseAssignmentExpressionOrOmittedExpression);\n        }\n        function parseArrayLiteralExpression() {\n            var node = createNode(141 /* ArrayLiteralExpression */);\n            parseExpected(17 /* OpenBracketToken */);\n            if (scanner.hasPrecedingLineBreak())\n                node.flags |= 256 /* MultiLine */;\n            node.elements = parseDelimitedList(12 /* ArrayLiteralMembers */, parseArrayLiteralElement);\n            parseExpected(18 /* CloseBracketToken */);\n            return finishNode(node);\n        }\n        function parseObjectLiteralElement() {\n            var fullStart = scanner.getStartPos();\n            var initialToken = token;\n            if (parseContextualModifier(113 /* GetKeyword */) || parseContextualModifier(117 /* SetKeyword */)) {\n                var kind = initialToken === 113 /* GetKeyword */ ? 127 /* GetAccessor */ : 128 /* SetAccessor */;\n                return parseAccessorDeclaration(kind, fullStart, undefined);\n            }\n            var asteriskToken = parseOptionalToken(34 /* AsteriskToken */);\n            var tokenIsIdentifier = isIdentifier();\n            var nameToken = token;\n            var propertyName = parsePropertyName();\n            if (asteriskToken || token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) {\n                return parseMethodDeclaration(fullStart, undefined, asteriskToken, propertyName, undefined, true);\n            }\n            // Disallowing of optional property assignments happens in the grammar checker.\n            var questionToken = parseOptionalToken(49 /* QuestionToken */);\n            // Parse to check if it is short-hand property assignment or normal property assignment\n            if ((token === 22 /* CommaToken */ || token === 14 /* CloseBraceToken */) && tokenIsIdentifier) {\n                var shorthandDeclaration = createNode(199 /* ShorthandPropertyAssignment */, fullStart);\n                shorthandDeclaration.name = propertyName;\n                shorthandDeclaration.questionToken = questionToken;\n                return finishNode(shorthandDeclaration);\n            }\n            else {\n                var propertyAssignment = createNode(198 /* PropertyAssignment */, fullStart);\n                propertyAssignment.name = propertyName;\n                propertyAssignment.questionToken = questionToken;\n                parseExpected(50 /* ColonToken */);\n                propertyAssignment.initializer = allowInAnd(parseAssignmentExpressionOrHigher);\n                return finishNode(propertyAssignment);\n            }\n        }\n        function parseObjectLiteralExpression() {\n            var node = createNode(142 /* ObjectLiteralExpression */);\n            parseExpected(13 /* OpenBraceToken */);\n            if (scanner.hasPrecedingLineBreak()) {\n                node.flags |= 256 /* MultiLine */;\n            }\n            node.properties = parseDelimitedList(11 /* ObjectLiteralMembers */, parseObjectLiteralElement);\n            parseExpected(14 /* CloseBraceToken */);\n            return finishNode(node);\n        }\n        function parseFunctionExpression() {\n            // GeneratorExpression :\n            //      function * BindingIdentifier[Yield]opt (FormalParameters[Yield, GeneratorParameter]) { GeneratorBody[Yield] }\n            // FunctionExpression:\n            //      function BindingIdentifieropt(FormalParameters) { FunctionBody }\n            var node = createNode(150 /* FunctionExpression */);\n            parseExpected(81 /* FunctionKeyword */);\n            node.asteriskToken = parseOptionalToken(34 /* AsteriskToken */);\n            node.name = node.asteriskToken ? doInYieldContext(parseOptionalIdentifier) : parseOptionalIdentifier();\n            fillSignature(50 /* ColonToken */, !!node.asteriskToken, false, node);\n            node.body = parseFunctionBlock(!!node.asteriskToken, false);\n            return finishNode(node);\n        }\n        function parseOptionalIdentifier() {\n            return isIdentifier() ? parseIdentifier() : undefined;\n        }\n        function parseNewExpression() {\n            var node = createNode(146 /* NewExpression */);\n            parseExpected(86 /* NewKeyword */);\n            node.expression = parseMemberExpressionOrHigher();\n            node.typeArguments = tryParse(parseTypeArgumentsInExpression);\n            if (node.typeArguments || token === 15 /* OpenParenToken */) {\n                node.arguments = parseArgumentList();\n            }\n            return finishNode(node);\n        }\n        // STATEMENTS\n        function parseBlock(kind, ignoreMissingOpenBrace, checkForStrictMode) {\n            var node = createNode(kind);\n            if (parseExpected(13 /* OpenBraceToken */) || ignoreMissingOpenBrace) {\n                node.statements = parseList(2 /* BlockStatements */, checkForStrictMode, parseStatement);\n                parseExpected(14 /* CloseBraceToken */);\n            }\n            else {\n                node.statements = createMissingList();\n            }\n            return finishNode(node);\n        }\n        function parseFunctionBlock(allowYield, ignoreMissingOpenBrace) {\n            var savedYieldContext = inYieldContext();\n            setYieldContext(allowYield);\n            var block = parseBlock(163 /* Block */, ignoreMissingOpenBrace, true);\n            setYieldContext(savedYieldContext);\n            return block;\n        }\n        function parseEmptyStatement() {\n            var node = createNode(165 /* EmptyStatement */);\n            parseExpected(21 /* SemicolonToken */);\n            return finishNode(node);\n        }\n        function parseIfStatement() {\n            var node = createNode(167 /* IfStatement */);\n            parseExpected(82 /* IfKeyword */);\n            parseExpected(15 /* OpenParenToken */);\n            node.expression = allowInAnd(parseExpression);\n            parseExpected(16 /* CloseParenToken */);\n            node.thenStatement = parseStatement();\n            node.elseStatement = parseOptional(74 /* ElseKeyword */) ? parseStatement() : undefined;\n            return finishNode(node);\n        }\n        function parseDoStatement() {\n            var node = createNode(168 /* DoStatement */);\n            parseExpected(73 /* DoKeyword */);\n            node.statement = parseStatement();\n            parseExpected(98 /* WhileKeyword */);\n            parseExpected(15 /* OpenParenToken */);\n            node.expression = allowInAnd(parseExpression);\n            parseExpected(16 /* CloseParenToken */);\n            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html\n            // 157 min --- All allen at wirfs-brock.com CONF --- \"do{;}while(false)false\" prohibited in \n            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby\n            //  do;while(0)x will have a semicolon inserted before x.\n            parseOptional(21 /* SemicolonToken */);\n            return finishNode(node);\n        }\n        function parseWhileStatement() {\n            var node = createNode(169 /* WhileStatement */);\n            parseExpected(98 /* WhileKeyword */);\n            parseExpected(15 /* OpenParenToken */);\n            node.expression = allowInAnd(parseExpression);\n            parseExpected(16 /* CloseParenToken */);\n            node.statement = parseStatement();\n            return finishNode(node);\n        }\n        function parseForOrForInStatement() {\n            var pos = getNodePos();\n            parseExpected(80 /* ForKeyword */);\n            parseExpected(15 /* OpenParenToken */);\n            if (token !== 21 /* SemicolonToken */) {\n                if (parseOptional(96 /* VarKeyword */)) {\n                    var declarations = disallowInAnd(parseVariableDeclarationList);\n                }\n                else if (parseOptional(102 /* LetKeyword */)) {\n                    var declarations = setFlag(disallowInAnd(parseVariableDeclarationList), 2048 /* Let */);\n                }\n                else if (parseOptional(68 /* ConstKeyword */)) {\n                    var declarations = setFlag(disallowInAnd(parseVariableDeclarationList), 4096 /* Const */);\n                }\n                else {\n                    var varOrInit = disallowInAnd(parseExpression);\n                }\n            }\n            var forOrForInStatement;\n            if (parseOptional(84 /* InKeyword */)) {\n                var forInStatement = createNode(171 /* ForInStatement */, pos);\n                if (declarations) {\n                    forInStatement.declarations = declarations;\n                }\n                else {\n                    forInStatement.variable = varOrInit;\n                }\n                forInStatement.expression = allowInAnd(parseExpression);\n                parseExpected(16 /* CloseParenToken */);\n                forOrForInStatement = forInStatement;\n            }\n            else {\n                var forStatement = createNode(170 /* ForStatement */, pos);\n                if (declarations) {\n                    forStatement.declarations = declarations;\n                }\n                if (varOrInit) {\n                    forStatement.initializer = varOrInit;\n                }\n                parseExpected(21 /* SemicolonToken */);\n                if (token !== 21 /* SemicolonToken */ && token !== 16 /* CloseParenToken */) {\n                    forStatement.condition = allowInAnd(parseExpression);\n                }\n                parseExpected(21 /* SemicolonToken */);\n                if (token !== 16 /* CloseParenToken */) {\n                    forStatement.iterator = allowInAnd(parseExpression);\n                }\n                parseExpected(16 /* CloseParenToken */);\n                forOrForInStatement = forStatement;\n            }\n            forOrForInStatement.statement = parseStatement();\n            return finishNode(forOrForInStatement);\n        }\n        function parseBreakOrContinueStatement(kind) {\n            var node = createNode(kind);\n            parseExpected(kind === 173 /* BreakStatement */ ? 64 /* BreakKeyword */ : 69 /* ContinueKeyword */);\n            if (!canParseSemicolon()) {\n                node.label = parseIdentifier();\n            }\n            parseSemicolon();\n            return finishNode(node);\n        }\n        function parseReturnStatement() {\n            var node = createNode(174 /* ReturnStatement */);\n            parseExpected(88 /* ReturnKeyword */);\n            if (!canParseSemicolon()) {\n                node.expression = allowInAnd(parseExpression);\n            }\n            parseSemicolon();\n            return finishNode(node);\n        }\n        function parseWithStatement() {\n            var node = createNode(175 /* WithStatement */);\n            parseExpected(99 /* WithKeyword */);\n            parseExpected(15 /* OpenParenToken */);\n            node.expression = allowInAnd(parseExpression);\n            parseExpected(16 /* CloseParenToken */);\n            node.statement = parseStatement();\n            return finishNode(node);\n        }\n        function parseCaseClause() {\n            var node = createNode(194 /* CaseClause */);\n            parseExpected(65 /* CaseKeyword */);\n            node.expression = allowInAnd(parseExpression);\n            parseExpected(50 /* ColonToken */);\n            node.statements = parseList(4 /* SwitchClauseStatements */, false, parseStatement);\n            return finishNode(node);\n        }\n        function parseDefaultClause() {\n            var node = createNode(195 /* DefaultClause */);\n            parseExpected(71 /* DefaultKeyword */);\n            parseExpected(50 /* ColonToken */);\n            node.statements = parseList(4 /* SwitchClauseStatements */, false, parseStatement);\n            return finishNode(node);\n        }\n        function parseCaseOrDefaultClause() {\n            return token === 65 /* CaseKeyword */ ? parseCaseClause() : parseDefaultClause();\n        }\n        function parseSwitchStatement() {\n            var node = createNode(176 /* SwitchStatement */);\n            parseExpected(90 /* SwitchKeyword */);\n            parseExpected(15 /* OpenParenToken */);\n            node.expression = allowInAnd(parseExpression);\n            parseExpected(16 /* CloseParenToken */);\n            parseExpected(13 /* OpenBraceToken */);\n            node.clauses = parseList(3 /* SwitchClauses */, false, parseCaseOrDefaultClause);\n            parseExpected(14 /* CloseBraceToken */);\n            return finishNode(node);\n        }\n        function parseThrowStatement() {\n            // ThrowStatement[Yield] :\n            //      throw [no LineTerminator here]Expression[In, ?Yield];\n            // Because of automatic semicolon insertion, we need to report error if this \n            // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'\n            // directly as that might consume an expression on the following line.  \n            // We just return 'undefined' in that case.  The actual error will be reported in the\n            // grammar walker.\n            var node = createNode(178 /* ThrowStatement */);\n            parseExpected(92 /* ThrowKeyword */);\n            node.expression = scanner.hasPrecedingLineBreak() ? undefined : allowInAnd(parseExpression);\n            parseSemicolon();\n            return finishNode(node);\n        }\n        // TODO: Review for error recovery\n        function parseTryStatement() {\n            var node = createNode(179 /* TryStatement */);\n            node.tryBlock = parseTokenAndBlock(94 /* TryKeyword */);\n            node.catchClause = token === 66 /* CatchKeyword */ ? parseCatchClause() : undefined;\n            // If we don't have a catch clause, then we must have a finally clause.  Try to parse\n            // one out no matter what.\n            node.finallyBlock = !node.catchClause || token === 79 /* FinallyKeyword */ ? parseTokenAndBlock(79 /* FinallyKeyword */) : undefined;\n            return finishNode(node);\n        }\n        function parseTokenAndBlock(token) {\n            var pos = getNodePos();\n            parseExpected(token);\n            var result = parseBlock(token === 94 /* TryKeyword */ ? 180 /* TryBlock */ : 181 /* FinallyBlock */, false, false);\n            result.pos = pos;\n            return result;\n        }\n        function parseCatchClause() {\n            var result = createNode(197 /* CatchClause */);\n            parseExpected(66 /* CatchKeyword */);\n            parseExpected(15 /* OpenParenToken */);\n            result.name = parseIdentifier();\n            result.type = parseTypeAnnotation();\n            parseExpected(16 /* CloseParenToken */);\n            result.block = parseBlock(163 /* Block */, false, false);\n            return finishNode(result);\n        }\n        function parseDebuggerStatement() {\n            var node = createNode(182 /* DebuggerStatement */);\n            parseExpected(70 /* DebuggerKeyword */);\n            parseSemicolon();\n            return finishNode(node);\n        }\n        function isLabel() {\n            return isIdentifier() && lookAhead(nextTokenIsColonToken);\n        }\n        function nextTokenIsColonToken() {\n            return nextToken() === 50 /* ColonToken */;\n        }\n        function parseLabeledStatement() {\n            var node = createNode(177 /* LabeledStatement */);\n            node.label = parseIdentifier();\n            parseExpected(50 /* ColonToken */);\n            node.statement = parseStatement();\n            return finishNode(node);\n        }\n        function parseExpressionStatement() {\n            var node = createNode(166 /* ExpressionStatement */);\n            node.expression = allowInAnd(parseExpression);\n            parseSemicolon();\n            return finishNode(node);\n        }\n        function isStatement(inErrorRecovery) {\n            switch (token) {\n                case 21 /* SemicolonToken */:\n                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.\n                    // The problem is that ';' can show up in far too many contexts, and if we see one\n                    // and assume it's a statement, then we may bail out inappropriately from whatever\n                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then\n                    // we really don't want to assume the class is over and we're on a statement in the\n                    // outer module.  We just want to consume and move on.\n                    return !inErrorRecovery;\n                case 13 /* OpenBraceToken */:\n                case 96 /* VarKeyword */:\n                case 102 /* LetKeyword */:\n                case 81 /* FunctionKeyword */:\n                case 82 /* IfKeyword */:\n                case 73 /* DoKeyword */:\n                case 98 /* WhileKeyword */:\n                case 80 /* ForKeyword */:\n                case 69 /* ContinueKeyword */:\n                case 64 /* BreakKeyword */:\n                case 88 /* ReturnKeyword */:\n                case 99 /* WithKeyword */:\n                case 90 /* SwitchKeyword */:\n                case 92 /* ThrowKeyword */:\n                case 94 /* TryKeyword */:\n                case 70 /* DebuggerKeyword */:\n                case 66 /* CatchKeyword */:\n                case 79 /* FinallyKeyword */:\n                    return true;\n                case 68 /* ConstKeyword */:\n                    // const keyword can precede enum keyword when defining constant enums\n                    // 'const enum' do not start statement.\n                    // In ES 6 'enum' is a future reserved keyword, so it should not be used as identifier\n                    var isConstEnum = lookAhead(nextTokenIsEnumKeyword);\n                    return !isConstEnum;\n                case 101 /* InterfaceKeyword */:\n                case 67 /* ClassKeyword */:\n                case 114 /* ModuleKeyword */:\n                case 75 /* EnumKeyword */:\n                case 119 /* TypeKeyword */:\n                    // When followed by an identifier, these do not start a statement but might\n                    // instead be following declarations\n                    if (isDeclarationStart()) {\n                        return false;\n                    }\n                case 106 /* PublicKeyword */:\n                case 104 /* PrivateKeyword */:\n                case 105 /* ProtectedKeyword */:\n                case 107 /* StaticKeyword */:\n                    // When followed by an identifier or keyword, these do not start a statement but\n                    // might instead be following type members\n                    if (lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine)) {\n                        return false;\n                    }\n                default:\n                    return isStartOfExpression();\n            }\n        }\n        function nextTokenIsEnumKeyword() {\n            nextToken();\n            return token === 75 /* EnumKeyword */;\n        }\n        function nextTokenIsIdentifierOrKeywordOnSameLine() {\n            nextToken();\n            return isIdentifierOrKeyword() && !scanner.hasPrecedingLineBreak();\n        }\n        function parseStatement() {\n            switch (token) {\n                case 13 /* OpenBraceToken */:\n                    return parseBlock(163 /* Block */, false, false);\n                case 96 /* VarKeyword */:\n                case 68 /* ConstKeyword */:\n                    // const here should always be parsed as const declaration because of check in 'isStatement' \n                    return parseVariableStatement(scanner.getStartPos(), undefined);\n                case 81 /* FunctionKeyword */:\n                    return parseFunctionDeclaration(scanner.getStartPos(), undefined);\n                case 21 /* SemicolonToken */:\n                    return parseEmptyStatement();\n                case 82 /* IfKeyword */:\n                    return parseIfStatement();\n                case 73 /* DoKeyword */:\n                    return parseDoStatement();\n                case 98 /* WhileKeyword */:\n                    return parseWhileStatement();\n                case 80 /* ForKeyword */:\n                    return parseForOrForInStatement();\n                case 69 /* ContinueKeyword */:\n                    return parseBreakOrContinueStatement(172 /* ContinueStatement */);\n                case 64 /* BreakKeyword */:\n                    return parseBreakOrContinueStatement(173 /* BreakStatement */);\n                case 88 /* ReturnKeyword */:\n                    return parseReturnStatement();\n                case 99 /* WithKeyword */:\n                    return parseWithStatement();\n                case 90 /* SwitchKeyword */:\n                    return parseSwitchStatement();\n                case 92 /* ThrowKeyword */:\n                    return parseThrowStatement();\n                case 94 /* TryKeyword */:\n                case 66 /* CatchKeyword */:\n                case 79 /* FinallyKeyword */:\n                    return parseTryStatement();\n                case 70 /* DebuggerKeyword */:\n                    return parseDebuggerStatement();\n                case 102 /* LetKeyword */:\n                    // If let follows identifier on the same line, it is declaration parse it as variable statement\n                    if (isLetDeclaration()) {\n                        return parseVariableStatement(scanner.getStartPos(), undefined);\n                    }\n                default:\n                    return isLabel() ? parseLabeledStatement() : parseExpressionStatement();\n            }\n        }\n        function parseFunctionBlockOrSemicolon(isGenerator) {\n            if (token === 13 /* OpenBraceToken */) {\n                return parseFunctionBlock(isGenerator, false);\n            }\n            parseSemicolon(ts.Diagnostics.or_expected);\n            return undefined;\n        }\n        // DECLARATIONS\n        function parseVariableDeclaration() {\n            var node = createNode(183 /* VariableDeclaration */);\n            node.name = parseIdentifier();\n            node.type = parseTypeAnnotation();\n            node.initializer = parseInitializer(false);\n            return finishNode(node);\n        }\n        function setFlag(array, flag) {\n            for (var i = 0, n = array.length; i < n; i++) {\n                array[i].flags |= flag;\n            }\n            return array;\n        }\n        function parseVariableDeclarationList() {\n            return parseDelimitedList(9 /* VariableDeclarations */, parseVariableDeclaration);\n        }\n        function parseVariableStatement(fullStart, modifiers) {\n            var node = createNode(164 /* VariableStatement */, fullStart);\n            setModifiers(node, modifiers);\n            if (token === 102 /* LetKeyword */) {\n                node.flags |= 2048 /* Let */;\n            }\n            else if (token === 68 /* ConstKeyword */) {\n                node.flags |= 4096 /* Const */;\n            }\n            else {\n                ts.Debug.assert(token === 96 /* VarKeyword */);\n            }\n            nextToken();\n            node.declarations = allowInAnd(parseVariableDeclarationList);\n            setFlag(node.declarations, node.flags);\n            parseSemicolon();\n            return finishNode(node);\n        }\n        function parseFunctionDeclaration(fullStart, modifiers) {\n            var node = createNode(184 /* FunctionDeclaration */, fullStart);\n            setModifiers(node, modifiers);\n            parseExpected(81 /* FunctionKeyword */);\n            node.asteriskToken = parseOptionalToken(34 /* AsteriskToken */);\n            node.name = parseIdentifier();\n            fillSignature(50 /* ColonToken */, !!node.asteriskToken, false, node);\n            node.body = parseFunctionBlockOrSemicolon(!!node.asteriskToken);\n            return finishNode(node);\n        }\n        function parseConstructorDeclaration(pos, modifiers) {\n            var node = createNode(126 /* Constructor */, pos);\n            setModifiers(node, modifiers);\n            parseExpected(111 /* ConstructorKeyword */);\n            fillSignature(50 /* ColonToken */, false, false, node);\n            node.body = parseFunctionBlockOrSemicolon(false);\n            return finishNode(node);\n        }\n        function parseMethodDeclaration(fullStart, modifiers, asteriskToken, name, questionToken, requireBlock) {\n            var method = createNode(125 /* Method */, fullStart);\n            setModifiers(method, modifiers);\n            method.asteriskToken = asteriskToken;\n            method.name = name;\n            method.questionToken = questionToken;\n            fillSignature(50 /* ColonToken */, !!asteriskToken, false, method);\n            method.body = requireBlock ? parseFunctionBlock(!!asteriskToken, false) : parseFunctionBlockOrSemicolon(!!asteriskToken);\n            return finishNode(method);\n        }\n        function parsePropertyOrMethodDeclaration(fullStart, modifiers) {\n            var asteriskToken = parseOptionalToken(34 /* AsteriskToken */);\n            var name = parsePropertyName();\n            // Note: this is not legal as per the grammar.  But we allow it in the parser and\n            // report an error in the grammar checker.\n            var questionToken = parseOptionalToken(49 /* QuestionToken */);\n            if (asteriskToken || token === 15 /* OpenParenToken */ || token === 23 /* LessThanToken */) {\n                return parseMethodDeclaration(fullStart, modifiers, asteriskToken, name, questionToken, false);\n            }\n            else {\n                var property = createNode(124 /* Property */, fullStart);\n                setModifiers(property, modifiers);\n                property.name = name;\n                property.questionToken = questionToken;\n                property.type = parseTypeAnnotation();\n                property.initializer = allowInAnd(parseNonParameterInitializer);\n                parseSemicolon();\n                return finishNode(property);\n            }\n        }\n        function parseNonParameterInitializer() {\n            return parseInitializer(false);\n        }\n        function parseAccessorDeclaration(kind, fullStart, modifiers) {\n            var node = createNode(kind, fullStart);\n            setModifiers(node, modifiers);\n            node.name = parsePropertyName();\n            fillSignature(50 /* ColonToken */, false, false, node);\n            node.body = parseFunctionBlockOrSemicolon(false);\n            return finishNode(node);\n        }\n        function isClassMemberStart() {\n            var idToken;\n            while (ts.isModifier(token)) {\n                idToken = token;\n                nextToken();\n            }\n            if (token === 34 /* AsteriskToken */) {\n                return true;\n            }\n            // Try to get the first property-like token following all modifiers.\n            // This can either be an identifier or the 'get' or 'set' keywords.\n            if (isLiteralPropertyName()) {\n                idToken = token;\n                nextToken();\n            }\n            // Index signatures and computed properties are class members; we can parse.\n            if (token === 17 /* OpenBracketToken */) {\n                return true;\n            }\n            // If we were able to get any potential identifier...\n            if (idToken !== undefined) {\n                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.\n                if (!ts.isKeyword(idToken) || idToken === 117 /* SetKeyword */ || idToken === 113 /* GetKeyword */) {\n                    return true;\n                }\n                switch (token) {\n                    case 15 /* OpenParenToken */:\n                    case 23 /* LessThanToken */:\n                    case 50 /* ColonToken */:\n                    case 51 /* EqualsToken */:\n                    case 49 /* QuestionToken */:\n                        return true;\n                    default:\n                        // Covers\n                        //  - Semicolons     (declaration termination)\n                        //  - Closing braces (end-of-class, must be declaration)\n                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)\n                        //  - Line-breaks    (enabling *automatic semicolon insertion*)\n                        return canParseSemicolon();\n                }\n            }\n            return false;\n        }\n        function parseModifiers() {\n            var flags = 0;\n            var modifiers;\n            while (true) {\n                var modifierStart = scanner.getStartPos();\n                var modifierKind = token;\n                if (!parseAnyContextualModifier()) {\n                    break;\n                }\n                if (!modifiers) {\n                    modifiers = [];\n                    modifiers.pos = modifierStart;\n                }\n                flags |= modifierToFlag(modifierKind);\n                modifiers.push(finishNode(createNode(modifierKind, modifierStart)));\n            }\n            if (modifiers) {\n                modifiers.flags = flags;\n                modifiers.end = scanner.getStartPos();\n            }\n            return modifiers;\n        }\n        function parseClassElement() {\n            var fullStart = getNodePos();\n            var modifiers = parseModifiers();\n            if (parseContextualModifier(113 /* GetKeyword */)) {\n                return parseAccessorDeclaration(127 /* GetAccessor */, fullStart, modifiers);\n            }\n            if (parseContextualModifier(117 /* SetKeyword */)) {\n                return parseAccessorDeclaration(128 /* SetAccessor */, fullStart, modifiers);\n            }\n            if (token === 111 /* ConstructorKeyword */) {\n                return parseConstructorDeclaration(fullStart, modifiers);\n            }\n            if (isIndexSignature()) {\n                return parseIndexSignatureDeclaration(fullStart, modifiers);\n            }\n            // It is very important that we check this *after* checking indexers because\n            // the [ token can start an index signature or a computed property name\n            if (isIdentifierOrKeyword() || token === 7 /* StringLiteral */ || token === 6 /* NumericLiteral */ || token === 34 /* AsteriskToken */ || token === 17 /* OpenBracketToken */) {\n                return parsePropertyOrMethodDeclaration(fullStart, modifiers);\n            }\n            // 'isClassMemberStart' should have hinted not to attempt parsing.\n            ts.Debug.fail(\"Should not have attempted to parse class member declaration.\");\n        }\n        function parseClassDeclaration(fullStart, modifiers) {\n            var node = createNode(185 /* ClassDeclaration */, fullStart);\n            setModifiers(node, modifiers);\n            parseExpected(67 /* ClassKeyword */);\n            node.name = parseIdentifier();\n            node.typeParameters = parseTypeParameters();\n            node.heritageClauses = parseHeritageClauses(true);\n            if (parseExpected(13 /* OpenBraceToken */)) {\n                // ClassTail[Yield,GeneratorParameter] : See 14.5\n                //      [~GeneratorParameter]ClassHeritage[?Yield]opt { ClassBody[?Yield]opt }\n                //      [+GeneratorParameter] ClassHeritageopt { ClassBodyopt }\n                node.members = inGeneratorParameterContext() ? doOutsideOfYieldContext(parseClassMembers) : parseClassMembers();\n                parseExpected(14 /* CloseBraceToken */);\n            }\n            else {\n                node.members = createMissingList();\n            }\n            return finishNode(node);\n        }\n        function parseHeritageClauses(isClassHeritageClause) {\n            // ClassTail[Yield,GeneratorParameter] : See 14.5\n            //      [~GeneratorParameter]ClassHeritage[?Yield]opt { ClassBody[?Yield]opt }\n            //      [+GeneratorParameter] ClassHeritageopt { ClassBodyopt }\n            if (isHeritageClause()) {\n                return isClassHeritageClause && inGeneratorParameterContext() ? doOutsideOfYieldContext(parseHeritageClausesWorker) : parseHeritageClausesWorker();\n            }\n            return undefined;\n        }\n        function parseHeritageClausesWorker() {\n            return parseList(17 /* HeritageClauses */, false, parseHeritageClause);\n        }\n        function parseHeritageClause() {\n            if (token === 77 /* ExtendsKeyword */ || token === 100 /* ImplementsKeyword */) {\n                var node = createNode(196 /* HeritageClause */);\n                node.token = token;\n                nextToken();\n                node.types = parseDelimitedList(8 /* TypeReferences */, parseTypeReference);\n                return finishNode(node);\n            }\n            return undefined;\n        }\n        function isHeritageClause() {\n            return token === 77 /* ExtendsKeyword */ || token === 100 /* ImplementsKeyword */;\n        }\n        function parseClassMembers() {\n            return parseList(6 /* ClassMembers */, false, parseClassElement);\n        }\n        function parseInterfaceDeclaration(fullStart, modifiers) {\n            var node = createNode(186 /* InterfaceDeclaration */, fullStart);\n            setModifiers(node, modifiers);\n            parseExpected(101 /* InterfaceKeyword */);\n            node.name = parseIdentifier();\n            node.typeParameters = parseTypeParameters();\n            node.heritageClauses = parseHeritageClauses(false);\n            node.members = parseObjectTypeMembers();\n            return finishNode(node);\n        }\n        function parseTypeAliasDeclaration(fullStart, modifiers) {\n            var node = createNode(187 /* TypeAliasDeclaration */, fullStart);\n            setModifiers(node, modifiers);\n            parseExpected(119 /* TypeKeyword */);\n            node.name = parseIdentifier();\n            parseExpected(51 /* EqualsToken */);\n            node.type = parseType();\n            parseSemicolon();\n            return finishNode(node);\n        }\n        // In an ambient declaration, the grammar only allows integer literals as initializers.\n        // In a non-ambient declaration, the grammar allows uninitialized members only in a\n        // ConstantEnumMemberSection, which starts at the beginning of an enum declaration\n        // or any time an integer literal initializer is encountered.\n        function parseEnumMember() {\n            var node = createNode(200 /* EnumMember */, scanner.getStartPos());\n            node.name = parsePropertyName();\n            node.initializer = allowInAnd(parseNonParameterInitializer);\n            return finishNode(node);\n        }\n        function parseEnumDeclaration(fullStart, modifiers) {\n            var node = createNode(188 /* EnumDeclaration */, fullStart);\n            setModifiers(node, modifiers);\n            parseExpected(75 /* EnumKeyword */);\n            node.name = parseIdentifier();\n            if (parseExpected(13 /* OpenBraceToken */)) {\n                node.members = parseDelimitedList(7 /* EnumMembers */, parseEnumMember);\n                parseExpected(14 /* CloseBraceToken */);\n            }\n            else {\n                node.members = createMissingList();\n            }\n            return finishNode(node);\n        }\n        function parseModuleBlock() {\n            var node = createNode(190 /* ModuleBlock */, scanner.getStartPos());\n            if (parseExpected(13 /* OpenBraceToken */)) {\n                node.statements = parseList(1 /* ModuleElements */, false, parseModuleElement);\n                parseExpected(14 /* CloseBraceToken */);\n            }\n            else {\n                node.statements = createMissingList();\n            }\n            return finishNode(node);\n        }\n        function parseInternalModuleTail(fullStart, modifiers, flags) {\n            var node = createNode(189 /* ModuleDeclaration */, fullStart);\n            setModifiers(node, modifiers);\n            node.flags |= flags;\n            node.name = parseIdentifier();\n            node.body = parseOptional(19 /* DotToken */) ? parseInternalModuleTail(getNodePos(), undefined, 1 /* Export */) : parseModuleBlock();\n            return finishNode(node);\n        }\n        function parseAmbientExternalModuleDeclaration(fullStart, modifiers) {\n            var node = createNode(189 /* ModuleDeclaration */, fullStart);\n            setModifiers(node, modifiers);\n            node.name = parseLiteralNode(true);\n            node.body = parseModuleBlock();\n            return finishNode(node);\n        }\n        function parseModuleDeclaration(fullStart, modifiers) {\n            parseExpected(114 /* ModuleKeyword */);\n            return token === 7 /* StringLiteral */ ? parseAmbientExternalModuleDeclaration(fullStart, modifiers) : parseInternalModuleTail(fullStart, modifiers, modifiers ? modifiers.flags : 0);\n        }\n        function isExternalModuleReference() {\n            return token === 115 /* RequireKeyword */ && lookAhead(nextTokenIsOpenParen);\n        }\n        function nextTokenIsOpenParen() {\n            return nextToken() === 15 /* OpenParenToken */;\n        }\n        function parseImportDeclaration(fullStart, modifiers) {\n            var node = createNode(191 /* ImportDeclaration */, fullStart);\n            setModifiers(node, modifiers);\n            parseExpected(83 /* ImportKeyword */);\n            node.name = parseIdentifier();\n            parseExpected(51 /* EqualsToken */);\n            node.moduleReference = parseModuleReference();\n            parseSemicolon();\n            return finishNode(node);\n        }\n        function parseModuleReference() {\n            return isExternalModuleReference() ? parseExternalModuleReference() : parseEntityName(false);\n        }\n        function parseExternalModuleReference() {\n            var node = createNode(193 /* ExternalModuleReference */);\n            parseExpected(115 /* RequireKeyword */);\n            parseExpected(15 /* OpenParenToken */);\n            // We allow arbitrary expressions here, even though the grammar only allows string \n            // literals.  We check to ensure that it is only a string literal later in the grammar\n            // walker.\n            node.expression = parseExpression();\n            // Ensure the string being required is in our 'identifier' table.  This will ensure \n            // that features like 'find refs' will look inside this file when search for its name.\n            if (node.expression.kind === 7 /* StringLiteral */) {\n                internIdentifier(node.expression.text);\n            }\n            parseExpected(16 /* CloseParenToken */);\n            return finishNode(node);\n        }\n        function parseExportAssignmentTail(fullStart, modifiers) {\n            var node = createNode(192 /* ExportAssignment */, fullStart);\n            setModifiers(node, modifiers);\n            node.exportName = parseIdentifier();\n            parseSemicolon();\n            return finishNode(node);\n        }\n        function isLetDeclaration() {\n            // It is let declaration if in strict mode or next token is identifier on same line.\n            // otherwise it needs to be treated like identifier\n            return inStrictModeContext() || lookAhead(nextTokenIsIdentifierOnSameLine);\n        }\n        function isDeclarationStart() {\n            switch (token) {\n                case 96 /* VarKeyword */:\n                case 68 /* ConstKeyword */:\n                case 81 /* FunctionKeyword */:\n                    return true;\n                case 102 /* LetKeyword */:\n                    return isLetDeclaration();\n                case 67 /* ClassKeyword */:\n                case 101 /* InterfaceKeyword */:\n                case 75 /* EnumKeyword */:\n                case 83 /* ImportKeyword */:\n                case 119 /* TypeKeyword */:\n                    // Not true keywords so ensure an identifier follows\n                    return lookAhead(nextTokenIsIdentifierOrKeyword);\n                case 114 /* ModuleKeyword */:\n                    // Not a true keyword so ensure an identifier or string literal follows\n                    return lookAhead(nextTokenIsIdentifierOrKeywordOrStringLiteral);\n                case 76 /* ExportKeyword */:\n                    // Check for export assignment or modifier on source element\n                    return lookAhead(nextTokenIsEqualsTokenOrDeclarationStart);\n                case 112 /* DeclareKeyword */:\n                case 106 /* PublicKeyword */:\n                case 104 /* PrivateKeyword */:\n                case 105 /* ProtectedKeyword */:\n                case 107 /* StaticKeyword */:\n                    // Check for modifier on source element\n                    return lookAhead(nextTokenIsDeclarationStart);\n            }\n        }\n        function isIdentifierOrKeyword() {\n            return token >= 63 /* Identifier */;\n        }\n        function nextTokenIsIdentifierOrKeyword() {\n            nextToken();\n            return isIdentifierOrKeyword();\n        }\n        function nextTokenIsIdentifierOrKeywordOrStringLiteral() {\n            nextToken();\n            return isIdentifierOrKeyword() || token === 7 /* StringLiteral */;\n        }\n        function nextTokenIsEqualsTokenOrDeclarationStart() {\n            nextToken();\n            return token === 51 /* EqualsToken */ || isDeclarationStart();\n        }\n        function nextTokenIsDeclarationStart() {\n            nextToken();\n            return isDeclarationStart();\n        }\n        function parseDeclaration() {\n            var fullStart = getNodePos();\n            var modifiers = parseModifiers();\n            if (token === 76 /* ExportKeyword */) {\n                nextToken();\n                if (parseOptional(51 /* EqualsToken */)) {\n                    return parseExportAssignmentTail(fullStart, modifiers);\n                }\n            }\n            switch (token) {\n                case 96 /* VarKeyword */:\n                case 102 /* LetKeyword */:\n                case 68 /* ConstKeyword */:\n                    return parseVariableStatement(fullStart, modifiers);\n                case 81 /* FunctionKeyword */:\n                    return parseFunctionDeclaration(fullStart, modifiers);\n                case 67 /* ClassKeyword */:\n                    return parseClassDeclaration(fullStart, modifiers);\n                case 101 /* InterfaceKeyword */:\n                    return parseInterfaceDeclaration(fullStart, modifiers);\n                case 119 /* TypeKeyword */:\n                    return parseTypeAliasDeclaration(fullStart, modifiers);\n                case 75 /* EnumKeyword */:\n                    return parseEnumDeclaration(fullStart, modifiers);\n                case 114 /* ModuleKeyword */:\n                    return parseModuleDeclaration(fullStart, modifiers);\n                case 83 /* ImportKeyword */:\n                    return parseImportDeclaration(fullStart, modifiers);\n                default:\n                    ts.Debug.fail(\"Mismatch between isDeclarationStart and parseDeclaration\");\n            }\n        }\n        function isSourceElement(inErrorRecovery) {\n            return isDeclarationStart() || isStatement(inErrorRecovery);\n        }\n        function parseSourceElement() {\n            return parseSourceElementOrModuleElement();\n        }\n        function parseModuleElement() {\n            return parseSourceElementOrModuleElement();\n        }\n        function parseSourceElementOrModuleElement() {\n            return isDeclarationStart() ? parseDeclaration() : parseStatement();\n        }\n        function processReferenceComments() {\n            var triviaScanner = ts.createScanner(languageVersion, false, sourceText);\n            var referencedFiles = [];\n            var amdDependencies = [];\n            var amdModuleName;\n            while (true) {\n                var kind = triviaScanner.scan();\n                if (kind === 5 /* WhitespaceTrivia */ || kind === 4 /* NewLineTrivia */ || kind === 3 /* MultiLineCommentTrivia */) {\n                    continue;\n                }\n                if (kind !== 2 /* SingleLineCommentTrivia */) {\n                    break;\n                }\n                var range = { pos: triviaScanner.getTokenPos(), end: triviaScanner.getTextPos() };\n                var comment = sourceText.substring(range.pos, range.end);\n                var referencePathMatchResult = ts.getFileReferenceFromReferencePath(comment, range);\n                if (referencePathMatchResult) {\n                    var fileReference = referencePathMatchResult.fileReference;\n                    sourceFile.hasNoDefaultLib = referencePathMatchResult.isNoDefaultLib;\n                    var diagnosticMessage = referencePathMatchResult.diagnosticMessage;\n                    if (fileReference) {\n                        referencedFiles.push(fileReference);\n                    }\n                    if (diagnosticMessage) {\n                        sourceFile.referenceDiagnostics.push(ts.createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, diagnosticMessage));\n                    }\n                }\n                else {\n                    var amdModuleNameRegEx = /^\\/\\/\\/\\s*<amd-module\\s+name\\s*=\\s*('|\")(.+?)\\1/gim;\n                    var amdModuleNameMatchResult = amdModuleNameRegEx.exec(comment);\n                    if (amdModuleNameMatchResult) {\n                        if (amdModuleName) {\n                            sourceFile.referenceDiagnostics.push(ts.createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, ts.Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments));\n                        }\n                        amdModuleName = amdModuleNameMatchResult[2];\n                    }\n                    var amdDependencyRegEx = /^\\/\\/\\/\\s*<amd-dependency\\s+path\\s*=\\s*('|\")(.+?)\\1/gim;\n                    var amdDependencyMatchResult = amdDependencyRegEx.exec(comment);\n                    if (amdDependencyMatchResult) {\n                        amdDependencies.push(amdDependencyMatchResult[2]);\n                    }\n                }\n            }\n            return {\n                referencedFiles: referencedFiles,\n                amdDependencies: amdDependencies,\n                amdModuleName: amdModuleName\n            };\n        }\n        function getExternalModuleIndicator() {\n            return ts.forEach(sourceFile.statements, function (node) { return node.flags & 1 /* Export */ || node.kind === 191 /* ImportDeclaration */ && node.moduleReference.kind === 193 /* ExternalModuleReference */ || node.kind === 192 /* ExportAssignment */ ? node : undefined; });\n        }\n        var syntacticDiagnostics;\n        function getSyntacticDiagnostics() {\n            if (syntacticDiagnostics === undefined) {\n                if (sourceFile.parseDiagnostics.length > 0) {\n                    // Don't bother doing any grammar checks if there are already parser errors.  \n                    // Otherwise we may end up with too many cascading errors.\n                    syntacticDiagnostics = sourceFile.referenceDiagnostics.concat(sourceFile.parseDiagnostics);\n                }\n                else {\n                    // No parser errors were reported.  Perform our stricter grammar checks.\n                    checkGrammar(sourceText, languageVersion, sourceFile);\n                    syntacticDiagnostics = sourceFile.referenceDiagnostics.concat(sourceFile.grammarDiagnostics);\n                }\n            }\n            ts.Debug.assert(syntacticDiagnostics !== undefined);\n            return syntacticDiagnostics;\n        }\n        var rootNodeFlags = 0;\n        if (ts.fileExtensionIs(filename, \".d.ts\")) {\n            rootNodeFlags = 1024 /* DeclarationFile */;\n        }\n        var sourceFile = createRootNode(201 /* SourceFile */, 0, sourceText.length, rootNodeFlags);\n        sourceFile.getLineAndCharacterFromPosition = getLineAndCharacterFromSourcePosition;\n        sourceFile.getPositionFromLineAndCharacter = getPositionFromSourceLineAndCharacter;\n        sourceFile.getLineStarts = getLineStarts;\n        sourceFile.getSyntacticDiagnostics = getSyntacticDiagnostics;\n        sourceFile.filename = ts.normalizePath(filename);\n        sourceFile.text = sourceText;\n        sourceFile.referenceDiagnostics = [];\n        sourceFile.parseDiagnostics = [];\n        sourceFile.grammarDiagnostics = [];\n        sourceFile.semanticDiagnostics = [];\n        var referenceComments = processReferenceComments();\n        sourceFile.referencedFiles = referenceComments.referencedFiles;\n        sourceFile.amdDependencies = referenceComments.amdDependencies;\n        sourceFile.amdModuleName = referenceComments.amdModuleName;\n        // Create and prime the scanner before parsing the source elements.\n        var scanner = ts.createScanner(languageVersion, true, sourceText, scanError);\n        nextToken();\n        sourceFile.statements = parseList(0 /* SourceElements */, true, parseSourceElement);\n        ts.Debug.assert(token === 1 /* EndOfFileToken */);\n        sourceFile.endOfFileToken = parseTokenNode();\n        sourceFile.externalModuleIndicator = getExternalModuleIndicator();\n        sourceFile.nodeCount = nodeCount;\n        sourceFile.identifierCount = identifierCount;\n        sourceFile.version = version;\n        sourceFile.isOpen = isOpen;\n        sourceFile.languageVersion = languageVersion;\n        sourceFile.identifiers = identifiers;\n        return sourceFile;\n    }\n    ts.createSourceFile = createSourceFile;\n    function isLeftHandSideExpression(expr) {\n        if (expr) {\n            switch (expr.kind) {\n                case 143 /* PropertyAccessExpression */:\n                case 144 /* ElementAccessExpression */:\n                case 146 /* NewExpression */:\n                case 145 /* CallExpression */:\n                case 147 /* TaggedTemplateExpression */:\n                case 141 /* ArrayLiteralExpression */:\n                case 149 /* ParenthesizedExpression */:\n                case 142 /* ObjectLiteralExpression */:\n                case 150 /* FunctionExpression */:\n                case 63 /* Identifier */:\n                case 8 /* RegularExpressionLiteral */:\n                case 6 /* NumericLiteral */:\n                case 7 /* StringLiteral */:\n                case 9 /* NoSubstitutionTemplateLiteral */:\n                case 159 /* TemplateExpression */:\n                case 78 /* FalseKeyword */:\n                case 87 /* NullKeyword */:\n                case 91 /* ThisKeyword */:\n                case 93 /* TrueKeyword */:\n                case 89 /* SuperKeyword */:\n                    return true;\n            }\n        }\n        return false;\n    }\n    function isAssignmentOperator(token) {\n        return token >= 51 /* FirstAssignment */ && token <= 62 /* LastAssignment */;\n    }\n    function checkGrammar(sourceText, languageVersion, file) {\n        var grammarDiagnostics = file.grammarDiagnostics;\n        // Create a scanner so we can find the start of tokens to report errors on.\n        var scanner = ts.createScanner(languageVersion, true, sourceText);\n        // We're automatically in an ambient context if this is a .d.ts file.\n        var inAmbientContext = ts.fileExtensionIs(file.filename, \".d.ts\");\n        var inFunctionBlock = false;\n        var parent;\n        visitNode(file);\n        function visitNode(node) {\n            // Store and restore our recursive state here.\n            var savedParent = parent;\n            node.parent = parent;\n            parent = node;\n            if (!checkModifiers(node)) {\n                var savedInFunctionBlock = inFunctionBlock;\n                if (ts.isFunctionBlock(node)) {\n                    inFunctionBlock = true;\n                }\n                var savedInAmbientContext = inAmbientContext;\n                if (node.flags & 2 /* Ambient */) {\n                    inAmbientContext = true;\n                }\n                checkNodeAndChildren(node);\n                inAmbientContext = savedInAmbientContext;\n                inFunctionBlock = savedInFunctionBlock;\n            }\n            parent = savedParent;\n        }\n        function checkNodeAndChildren(node) {\n            var nodeKind = node.kind;\n            // First, check if you have a statement in a place where it is not allowed.  We want \n            // to do this before recursing, because we'd prefer to report these errors at the top\n            // level instead of at some nested level.\n            if (inAmbientContext && checkForStatementInAmbientContext(node, nodeKind)) {\n                return;\n            }\n            // if we got any errors, just stop performing any more checks on this node or higher.\n            if (checkNode(node, nodeKind)) {\n                return;\n            }\n            // Otherwise, recurse and see if we have any errors below us.\n            forEachChild(node, visitNode);\n        }\n        function checkNode(node, nodeKind) {\n            switch (nodeKind) {\n                case 151 /* ArrowFunction */:\n                case 129 /* CallSignature */:\n                case 134 /* ConstructorType */:\n                case 130 /* ConstructSignature */:\n                case 133 /* FunctionType */:\n                    return checkAnySignatureDeclaration(node);\n                case 173 /* BreakStatement */:\n                case 172 /* ContinueStatement */:\n                    return checkBreakOrContinueStatement(node);\n                case 145 /* CallExpression */:\n                case 146 /* NewExpression */:\n                    return checkCallOrNewExpression(node);\n                case 188 /* EnumDeclaration */: return checkEnumDeclaration(node);\n                case 157 /* BinaryExpression */: return checkBinaryExpression(node);\n                case 197 /* CatchClause */: return checkCatchClause(node);\n                case 185 /* ClassDeclaration */: return checkClassDeclaration(node);\n                case 121 /* ComputedPropertyName */: return checkComputedPropertyName(node);\n                case 126 /* Constructor */: return checkConstructor(node);\n                case 152 /* DeleteExpression */: return checkDeleteExpression(node);\n                case 144 /* ElementAccessExpression */: return checkElementAccessExpression(node);\n                case 192 /* ExportAssignment */: return checkExportAssignment(node);\n                case 193 /* ExternalModuleReference */: return checkExternalModuleReference(node);\n                case 171 /* ForInStatement */: return checkForInStatement(node);\n                case 170 /* ForStatement */: return checkForStatement(node);\n                case 184 /* FunctionDeclaration */: return checkFunctionDeclaration(node);\n                case 150 /* FunctionExpression */: return checkFunctionExpression(node);\n                case 127 /* GetAccessor */: return checkGetAccessor(node);\n                case 196 /* HeritageClause */: return checkHeritageClause(node);\n                case 131 /* IndexSignature */: return checkIndexSignature(node);\n                case 186 /* InterfaceDeclaration */: return checkInterfaceDeclaration(node);\n                case 177 /* LabeledStatement */: return checkLabeledStatement(node);\n                case 198 /* PropertyAssignment */: return checkPropertyAssignment(node);\n                case 125 /* Method */: return checkMethod(node);\n                case 189 /* ModuleDeclaration */: return checkModuleDeclaration(node);\n                case 142 /* ObjectLiteralExpression */: return checkObjectLiteralExpression(node);\n                case 6 /* NumericLiteral */: return checkNumericLiteral(node);\n                case 123 /* Parameter */: return checkParameter(node);\n                case 156 /* PostfixUnaryExpression */: return checkPostfixUnaryExpression(node);\n                case 155 /* PrefixUnaryExpression */: return checkPrefixUnaryExpression(node);\n                case 124 /* Property */: return checkProperty(node);\n                case 174 /* ReturnStatement */: return checkReturnStatement(node);\n                case 128 /* SetAccessor */: return checkSetAccessor(node);\n                case 201 /* SourceFile */: return checkSourceFile(node);\n                case 199 /* ShorthandPropertyAssignment */: return checkShorthandPropertyAssignment(node);\n                case 176 /* SwitchStatement */: return checkSwitchStatement(node);\n                case 147 /* TaggedTemplateExpression */: return checkTaggedTemplateExpression(node);\n                case 178 /* ThrowStatement */: return checkThrowStatement(node);\n                case 138 /* TupleType */: return checkTupleType(node);\n                case 122 /* TypeParameter */: return checkTypeParameter(node);\n                case 132 /* TypeReference */: return checkTypeReference(node);\n                case 183 /* VariableDeclaration */: return checkVariableDeclaration(node);\n                case 164 /* VariableStatement */: return checkVariableStatement(node);\n                case 175 /* WithStatement */: return checkWithStatement(node);\n                case 160 /* YieldExpression */: return checkYieldExpression(node);\n            }\n        }\n        function scanToken(pos) {\n            var start = ts.skipTrivia(sourceText, pos);\n            scanner.setTextPos(start);\n            scanner.scan();\n            return start;\n        }\n        function grammarErrorOnFirstToken(node, message, arg0, arg1, arg2) {\n            var start = scanToken(node.pos);\n            grammarDiagnostics.push(ts.createFileDiagnostic(file, start, scanner.getTextPos() - start, message, arg0, arg1, arg2));\n            return true;\n        }\n        function grammarErrorAfterFirstToken(node, message, arg0, arg1, arg2) {\n            scanToken(node.pos);\n            grammarDiagnostics.push(ts.createFileDiagnostic(file, scanner.getTextPos(), 0, message, arg0, arg1, arg2));\n            return true;\n        }\n        function grammarErrorOnNode(node, message, arg0, arg1, arg2) {\n            var span = ts.getErrorSpanForNode(node);\n            var start = span.end > span.pos ? ts.skipTrivia(file.text, span.pos) : span.pos;\n            var length = span.end - start;\n            grammarDiagnostics.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));\n            return true;\n        }\n        function grammarErrorAtPos(start, length, message, arg0, arg1, arg2) {\n            grammarDiagnostics.push(ts.createFileDiagnostic(file, start, length, message, arg0, arg1, arg2));\n            return true;\n        }\n        function reportInvalidUseInStrictMode(node) {\n            // declarationNameToString cannot be used here since it uses a backreference to 'parent' that is not yet set\n            var name = sourceText.substring(ts.skipTrivia(sourceText, node.pos), node.end);\n            return grammarErrorOnNode(node, ts.Diagnostics.Invalid_use_of_0_in_strict_mode, name);\n        }\n        function checkForStatementInAmbientContext(node, kind) {\n            switch (kind) {\n                case 163 /* Block */:\n                case 165 /* EmptyStatement */:\n                case 167 /* IfStatement */:\n                case 168 /* DoStatement */:\n                case 169 /* WhileStatement */:\n                case 170 /* ForStatement */:\n                case 171 /* ForInStatement */:\n                case 172 /* ContinueStatement */:\n                case 173 /* BreakStatement */:\n                case 174 /* ReturnStatement */:\n                case 175 /* WithStatement */:\n                case 176 /* SwitchStatement */:\n                case 178 /* ThrowStatement */:\n                case 179 /* TryStatement */:\n                case 182 /* DebuggerStatement */:\n                case 177 /* LabeledStatement */:\n                case 166 /* ExpressionStatement */:\n                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Statements_are_not_allowed_in_ambient_contexts);\n            }\n        }\n        function checkAnySignatureDeclaration(node) {\n            return checkTypeParameterList(node.typeParameters) || checkParameterList(node.parameters);\n        }\n        function checkBinaryExpression(node) {\n            if (node.parserContextFlags & 1 /* StrictMode */) {\n                if (isLeftHandSideExpression(node.left) && isAssignmentOperator(node.operator)) {\n                    if (isEvalOrArgumentsIdentifier(node.left)) {\n                        // ECMA 262 (Annex C) The identifier eval or arguments may not appear as the LeftHandSideExpression of an \n                        // Assignment operator(11.13) or of a PostfixExpression(11.3)\n                        return reportInvalidUseInStrictMode(node.left);\n                    }\n                }\n            }\n        }\n        function isIterationStatement(node, lookInLabeledStatements) {\n            switch (node.kind) {\n                case 170 /* ForStatement */:\n                case 171 /* ForInStatement */:\n                case 168 /* DoStatement */:\n                case 169 /* WhileStatement */:\n                    return true;\n                case 177 /* LabeledStatement */:\n                    return lookInLabeledStatements && isIterationStatement(node.statement, lookInLabeledStatements);\n            }\n            return false;\n        }\n        function checkLabeledStatement(node) {\n            // ensure that label is unique\n            var current = node.parent;\n            while (current) {\n                if (ts.isAnyFunction(current)) {\n                    break;\n                }\n                if (current.kind === 177 /* LabeledStatement */ && current.label.text === node.label.text) {\n                    return grammarErrorOnNode(node.label, ts.Diagnostics.Duplicate_label_0, ts.getTextOfNodeFromSourceText(sourceText, node.label));\n                }\n                current = current.parent;\n            }\n        }\n        function checkBreakOrContinueStatement(node) {\n            var current = node;\n            while (current) {\n                if (ts.isAnyFunction(current)) {\n                    return grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);\n                }\n                switch (current.kind) {\n                    case 177 /* LabeledStatement */:\n                        if (node.label && current.label.text === node.label.text) {\n                            // found matching label - verify that label usage is correct\n                            // continue can only target labels that are on iteration statements\n                            var isMisplacedContinueLabel = node.kind === 172 /* ContinueStatement */ && !isIterationStatement(current.statement, true);\n                            if (isMisplacedContinueLabel) {\n                                return grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);\n                            }\n                            return false;\n                        }\n                        break;\n                    case 176 /* SwitchStatement */:\n                        if (node.kind === 173 /* BreakStatement */ && !node.label) {\n                            // unlabeled break within switch statement - ok\n                            return false;\n                        }\n                        break;\n                    default:\n                        if (isIterationStatement(current, false) && !node.label) {\n                            // unlabeled break or continue within iteration statement - ok\n                            return false;\n                        }\n                        break;\n                }\n                current = current.parent;\n            }\n            if (node.label) {\n                var message = node.kind === 173 /* BreakStatement */ ? ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement : ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;\n                return grammarErrorOnNode(node, message);\n            }\n            else {\n                var message = node.kind === 173 /* BreakStatement */ ? ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement : ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;\n                return grammarErrorOnNode(node, message);\n            }\n        }\n        function checkCallOrNewExpression(node) {\n            return checkTypeArguments(node.typeArguments) || checkArguments(node.arguments);\n        }\n        function checkArguments(arguments) {\n            return checkForDisallowedTrailingComma(arguments) || checkForOmittedArgument(arguments);\n        }\n        function checkTypeArguments(typeArguments) {\n            return checkForDisallowedTrailingComma(typeArguments) || checkForAtLeastOneTypeArgument(typeArguments);\n        }\n        function checkForOmittedArgument(arguments) {\n            if (arguments) {\n                for (var i = 0, n = arguments.length; i < n; i++) {\n                    var arg = arguments[i];\n                    if (arg.kind === 161 /* OmittedExpression */) {\n                        return grammarErrorAtPos(arg.pos, 0, ts.Diagnostics.Argument_expression_expected);\n                    }\n                }\n            }\n        }\n        function checkForAtLeastOneTypeArgument(typeArguments) {\n            if (typeArguments && typeArguments.length === 0) {\n                var start = typeArguments.pos - \"<\".length;\n                var end = ts.skipTrivia(sourceText, typeArguments.end) + \">\".length;\n                return grammarErrorAtPos(start, end - start, ts.Diagnostics.Type_argument_list_cannot_be_empty);\n            }\n        }\n        function checkForDisallowedTrailingComma(list) {\n            if (list && list.hasTrailingComma) {\n                var start = list.end - \",\".length;\n                var end = list.end;\n                return grammarErrorAtPos(start, end - start, ts.Diagnostics.Trailing_comma_not_allowed);\n            }\n        }\n        function checkCatchClause(node) {\n            if (node.type) {\n                var colonStart = ts.skipTrivia(sourceText, node.name.end);\n                return grammarErrorAtPos(colonStart, \":\".length, ts.Diagnostics.Catch_clause_parameter_cannot_have_a_type_annotation);\n            }\n            if (node.parserContextFlags & 1 /* StrictMode */ && isEvalOrArgumentsIdentifier(node.name)) {\n                // It is a SyntaxError if a TryStatement with a Catch occurs within strict code and the Identifier of the \n                // Catch production is eval or arguments\n                return reportInvalidUseInStrictMode(node.name);\n            }\n        }\n        function checkClassDeclaration(node) {\n            return checkClassDeclarationHeritageClauses(node);\n        }\n        function checkClassDeclarationHeritageClauses(node) {\n            var seenExtendsClause = false;\n            var seenImplementsClause = false;\n            if (node.heritageClauses) {\n                for (var i = 0, n = node.heritageClauses.length; i < n; i++) {\n                    ts.Debug.assert(i <= 2);\n                    var heritageClause = node.heritageClauses[i];\n                    if (heritageClause.token === 77 /* ExtendsKeyword */) {\n                        if (seenExtendsClause) {\n                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);\n                        }\n                        if (seenImplementsClause) {\n                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_must_precede_implements_clause);\n                        }\n                        if (heritageClause.types.length > 1) {\n                            return grammarErrorOnFirstToken(heritageClause.types[1], ts.Diagnostics.Classes_can_only_extend_a_single_class);\n                        }\n                        seenExtendsClause = true;\n                    }\n                    else {\n                        ts.Debug.assert(heritageClause.token === 100 /* ImplementsKeyword */);\n                        if (seenImplementsClause) {\n                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.implements_clause_already_seen);\n                        }\n                        seenImplementsClause = true;\n                    }\n                }\n            }\n            return false;\n        }\n        function checkForAtLeastOneHeritageClause(types, listType) {\n            if (types && types.length === 0) {\n                return grammarErrorAtPos(types.pos, 0, ts.Diagnostics._0_list_cannot_be_empty, listType);\n            }\n        }\n        function checkConstructor(node) {\n            return checkAnySignatureDeclaration(node) || checkConstructorTypeParameters(node) || checkConstructorTypeAnnotation(node) || checkForBodyInAmbientContext(node.body, true);\n        }\n        function checkConstructorTypeParameters(node) {\n            if (node.typeParameters) {\n                return grammarErrorAtPos(node.typeParameters.pos, node.typeParameters.end - node.typeParameters.pos, ts.Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);\n            }\n        }\n        function checkConstructorTypeAnnotation(node) {\n            if (node.type) {\n                return grammarErrorOnNode(node.type, ts.Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);\n            }\n        }\n        function checkDeleteExpression(node) {\n            if (node.parserContextFlags & 1 /* StrictMode */ && node.expression.kind === 63 /* Identifier */) {\n                // When a delete operator occurs within strict mode code, a SyntaxError is thrown if its \n                // UnaryExpression is a direct reference to a variable, function argument, or function name\n                return grammarErrorOnNode(node.expression, ts.Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode);\n            }\n        }\n        function checkEnumDeclaration(enumDecl) {\n            var enumIsConst = (enumDecl.flags & 4096 /* Const */) !== 0;\n            var hasError = false;\n            // skip checks below for const enums  - they allow arbitrary initializers as long as they can be evaluated to constant expressions.\n            // since all values are known in compile time - it is not necessary to check that constant enum section precedes computed enum members.\n            if (!enumIsConst) {\n                var inConstantEnumMemberSection = true;\n                for (var i = 0, n = enumDecl.members.length; i < n; i++) {\n                    var node = enumDecl.members[i];\n                    if (node.name.kind === 121 /* ComputedPropertyName */) {\n                        hasError = grammarErrorOnNode(node.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_enums);\n                    }\n                    else if (inAmbientContext) {\n                        if (node.initializer && !isIntegerLiteral(node.initializer)) {\n                            hasError = grammarErrorOnNode(node.name, ts.Diagnostics.Ambient_enum_elements_can_only_have_integer_literal_initializers) || hasError;\n                        }\n                    }\n                    else if (node.initializer) {\n                        inConstantEnumMemberSection = isIntegerLiteral(node.initializer);\n                    }\n                    else if (!inConstantEnumMemberSection) {\n                        hasError = grammarErrorOnNode(node.name, ts.Diagnostics.Enum_member_must_have_initializer) || hasError;\n                    }\n                }\n            }\n            return hasError;\n        }\n        function isIntegerLiteral(expression) {\n            function isInteger(literalExpression) {\n                // Allows for scientific notation since literalExpression.text was formed by\n                // coercing a number to a string. Sometimes this coercion can yield a string\n                // in scientific notation.\n                // We also don't need special logic for hex because a hex integer is converted\n                // to decimal when it is coerced.\n                return /^[0-9]+([eE]\\+?[0-9]+)?$/.test(literalExpression.text);\n            }\n            if (expression.kind === 155 /* PrefixUnaryExpression */) {\n                var unaryExpression = expression;\n                if (unaryExpression.operator === 32 /* PlusToken */ || unaryExpression.operator === 33 /* MinusToken */) {\n                    expression = unaryExpression.operand;\n                }\n            }\n            if (expression.kind === 6 /* NumericLiteral */) {\n                return isInteger(expression);\n            }\n            return false;\n        }\n        function checkExportAssignment(node) {\n            if (node.flags & 243 /* Modifier */) {\n                return grammarErrorOnFirstToken(node, ts.Diagnostics.An_export_assignment_cannot_have_modifiers);\n            }\n        }\n        function checkExternalModuleReference(node) {\n            if (node.expression.kind !== 7 /* StringLiteral */) {\n                return grammarErrorOnNode(node.expression, ts.Diagnostics.String_literal_expected);\n            }\n        }\n        function checkForInStatement(node) {\n            return checkVariableDeclarations(node.declarations) || checkForMoreThanOneDeclaration(node.declarations);\n        }\n        function checkForStatement(node) {\n            return checkVariableDeclarations(node.declarations);\n        }\n        function checkForMoreThanOneDeclaration(declarations) {\n            if (declarations && declarations.length > 1) {\n                return grammarErrorOnFirstToken(declarations[1], ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement);\n            }\n        }\n        function checkFunctionDeclaration(node) {\n            return checkAnySignatureDeclaration(node) || checkFunctionName(node.name) || checkForBodyInAmbientContext(node.body, false) || checkForGenerator(node);\n        }\n        function checkForGenerator(node) {\n            if (node.asteriskToken) {\n                return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.Generators_are_not_currently_supported);\n            }\n        }\n        function checkFunctionExpression(node) {\n            return checkAnySignatureDeclaration(node) || checkFunctionName(node.name) || checkForGenerator(node);\n        }\n        function checkFunctionName(name) {\n            if (name && name.parserContextFlags & 1 /* StrictMode */ && isEvalOrArgumentsIdentifier(name)) {\n                // It is a SyntaxError to use within strict mode code the identifiers eval or arguments as the \n                // Identifier of a FunctionLikeDeclaration or FunctionExpression or as a formal parameter name(13.1)\n                return reportInvalidUseInStrictMode(name);\n            }\n        }\n        function checkGetAccessor(node) {\n            return checkAnySignatureDeclaration(node) || checkAccessor(node);\n        }\n        function checkElementAccessExpression(node) {\n            if (!node.argumentExpression) {\n                if (node.parent.kind === 146 /* NewExpression */ && node.parent.expression === node) {\n                    var start = ts.skipTrivia(sourceText, node.expression.end);\n                    var end = node.end;\n                    return grammarErrorAtPos(start, end - start, ts.Diagnostics.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);\n                }\n                else {\n                    var start = node.end - \"]\".length;\n                    var end = node.end;\n                    return grammarErrorAtPos(start, end - start, ts.Diagnostics.Expression_expected);\n                }\n            }\n        }\n        function checkHeritageClause(node) {\n            return checkForDisallowedTrailingComma(node.types) || checkForAtLeastOneHeritageClause(node.types, ts.tokenToString(node.token));\n        }\n        function checkIndexSignature(node) {\n            return checkIndexSignatureParameters(node) || checkForIndexSignatureModifiers(node);\n        }\n        function checkForIndexSignatureModifiers(node) {\n            if (node.flags & 243 /* Modifier */) {\n                return grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_not_permitted_on_index_signature_members);\n            }\n        }\n        function checkIndexSignatureParameters(node) {\n            var parameter = node.parameters[0];\n            if (node.parameters.length !== 1) {\n                if (parameter) {\n                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);\n                }\n                else {\n                    return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);\n                }\n            }\n            else if (parameter.dotDotDotToken) {\n                return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.An_index_signature_cannot_have_a_rest_parameter);\n            }\n            else if (parameter.flags & 243 /* Modifier */) {\n                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);\n            }\n            else if (parameter.questionToken) {\n                return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);\n            }\n            else if (parameter.initializer) {\n                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);\n            }\n            else if (!parameter.type) {\n                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);\n            }\n            else if (parameter.type.kind !== 118 /* StringKeyword */ && parameter.type.kind !== 116 /* NumberKeyword */) {\n                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_must_be_string_or_number);\n            }\n            else if (!node.type) {\n                return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_a_type_annotation);\n            }\n        }\n        function checkInterfaceDeclaration(node) {\n            return checkInterfaceDeclarationHeritageClauses(node);\n        }\n        function checkInterfaceDeclarationHeritageClauses(node) {\n            var seenExtendsClause = false;\n            if (node.heritageClauses) {\n                for (var i = 0, n = node.heritageClauses.length; i < n; i++) {\n                    ts.Debug.assert(i <= 1);\n                    var heritageClause = node.heritageClauses[i];\n                    if (heritageClause.token === 77 /* ExtendsKeyword */) {\n                        if (seenExtendsClause) {\n                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);\n                        }\n                        seenExtendsClause = true;\n                    }\n                    else {\n                        ts.Debug.assert(heritageClause.token === 100 /* ImplementsKeyword */);\n                        return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.Interface_declaration_cannot_have_implements_clause);\n                    }\n                }\n            }\n            return false;\n        }\n        function checkMethod(node) {\n            if (checkAnySignatureDeclaration(node) || checkForBodyInAmbientContext(node.body, false) || checkForGenerator(node)) {\n                return true;\n            }\n            if (node.parent.kind === 185 /* ClassDeclaration */) {\n                if (checkForInvalidQuestionMark(node, node.questionToken, ts.Diagnostics.A_class_member_cannot_be_declared_optional)) {\n                    return true;\n                }\n                // Technically, computed properties in ambient contexts is disallowed \n                // for property declarations and accessors too, not just methods.\n                // However, property declarations disallow computed names in general,\n                // and accessors are not allowed in ambient contexts in general,\n                // so this error only really matters for methods.\n                if (inAmbientContext) {\n                    return checkForDisallowedComputedProperty(node.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_an_ambient_context);\n                }\n                else if (!node.body) {\n                    return checkForDisallowedComputedProperty(node.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_method_overloads);\n                }\n            }\n            else if (node.parent.kind === 186 /* InterfaceDeclaration */) {\n                return checkForDisallowedComputedProperty(node.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_interfaces);\n            }\n            else if (node.parent.kind === 136 /* TypeLiteral */) {\n                return checkForDisallowedComputedProperty(node.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_type_literals);\n            }\n        }\n        function checkForBodyInAmbientContext(body, isConstructor) {\n            if (inAmbientContext && body && body.kind === 163 /* Block */) {\n                var diagnostic = isConstructor ? ts.Diagnostics.A_constructor_implementation_cannot_be_declared_in_an_ambient_context : ts.Diagnostics.A_function_implementation_cannot_be_declared_in_an_ambient_context;\n                return grammarErrorOnFirstToken(body, diagnostic);\n            }\n        }\n        function checkModuleDeclaration(node) {\n            return checkModuleDeclarationName(node) || checkModuleDeclarationStatements(node);\n        }\n        function checkModuleDeclarationName(node) {\n            if (!inAmbientContext && node.name.kind === 7 /* StringLiteral */) {\n                return grammarErrorOnNode(node.name, ts.Diagnostics.Only_ambient_modules_can_use_quoted_names);\n            }\n        }\n        function checkModuleDeclarationStatements(node) {\n            if (node.name.kind === 63 /* Identifier */ && node.body.kind === 190 /* ModuleBlock */) {\n                var statements = node.body.statements;\n                for (var i = 0, n = statements.length; i < n; i++) {\n                    var statement = statements[i];\n                    if (statement.kind === 192 /* ExportAssignment */) {\n                        // Export assignments are not allowed in an internal module\n                        return grammarErrorOnNode(statement, ts.Diagnostics.An_export_assignment_cannot_be_used_in_an_internal_module);\n                    }\n                    else if (ts.isExternalModuleImportDeclaration(statement)) {\n                        return grammarErrorOnNode(ts.getExternalModuleImportDeclarationExpression(statement), ts.Diagnostics.Import_declarations_in_an_internal_module_cannot_reference_an_external_module);\n                    }\n                }\n            }\n        }\n        function checkObjectLiteralExpression(node) {\n            var seen = {};\n            var Property = 1;\n            var GetAccessor = 2;\n            var SetAccesor = 4;\n            var GetOrSetAccessor = GetAccessor | SetAccesor;\n            var inStrictMode = (node.parserContextFlags & 1 /* StrictMode */) !== 0;\n            for (var i = 0, n = node.properties.length; i < n; i++) {\n                var prop = node.properties[i];\n                var name = prop.name;\n                if (prop.kind === 161 /* OmittedExpression */ || name.kind === 121 /* ComputedPropertyName */) {\n                    continue;\n                }\n                // ECMA-262 11.1.5 Object Initialiser \n                // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true\n                // a.This production is contained in strict code and IsDataDescriptor(previous) is true and \n                // IsDataDescriptor(propId.descriptor) is true.\n                //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.\n                //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.\n                //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true \n                // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields \n                var currentKind;\n                if (prop.kind === 198 /* PropertyAssignment */ || prop.kind === 199 /* ShorthandPropertyAssignment */ || prop.kind === 125 /* Method */) {\n                    currentKind = Property;\n                }\n                else if (prop.kind === 127 /* GetAccessor */) {\n                    currentKind = GetAccessor;\n                }\n                else if (prop.kind === 128 /* SetAccessor */) {\n                    currentKind = SetAccesor;\n                }\n                else {\n                    ts.Debug.fail(\"Unexpected syntax kind:\" + prop.kind);\n                }\n                if (!ts.hasProperty(seen, name.text)) {\n                    seen[name.text] = currentKind;\n                }\n                else {\n                    var existingKind = seen[name.text];\n                    if (currentKind === Property && existingKind === Property) {\n                        if (inStrictMode) {\n                            grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode);\n                        }\n                    }\n                    else if ((currentKind & GetOrSetAccessor) && (existingKind & GetOrSetAccessor)) {\n                        if (existingKind !== GetOrSetAccessor && currentKind !== existingKind) {\n                            seen[name.text] = currentKind | existingKind;\n                        }\n                        else {\n                            return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);\n                        }\n                    }\n                    else {\n                        return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);\n                    }\n                }\n            }\n        }\n        function checkNumericLiteral(node) {\n            if (node.flags & 8192 /* OctalLiteral */) {\n                if (node.parserContextFlags & 1 /* StrictMode */) {\n                    return grammarErrorOnNode(node, ts.Diagnostics.Octal_literals_are_not_allowed_in_strict_mode);\n                }\n                else if (languageVersion >= 1 /* ES5 */) {\n                    return grammarErrorOnNode(node, ts.Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher);\n                }\n            }\n        }\n        function checkModifiers(node) {\n            switch (node.kind) {\n                case 127 /* GetAccessor */:\n                case 128 /* SetAccessor */:\n                case 126 /* Constructor */:\n                case 124 /* Property */:\n                case 125 /* Method */:\n                case 131 /* IndexSignature */:\n                case 185 /* ClassDeclaration */:\n                case 186 /* InterfaceDeclaration */:\n                case 189 /* ModuleDeclaration */:\n                case 188 /* EnumDeclaration */:\n                case 192 /* ExportAssignment */:\n                case 164 /* VariableStatement */:\n                case 184 /* FunctionDeclaration */:\n                case 187 /* TypeAliasDeclaration */:\n                case 191 /* ImportDeclaration */:\n                case 123 /* Parameter */:\n                    break;\n                default:\n                    return false;\n            }\n            if (!node.modifiers) {\n                return;\n            }\n            var lastStatic, lastPrivate, lastProtected, lastDeclare;\n            var flags = 0;\n            for (var i = 0, n = node.modifiers.length; i < n; i++) {\n                var modifier = node.modifiers[i];\n                switch (modifier.kind) {\n                    case 106 /* PublicKeyword */:\n                    case 105 /* ProtectedKeyword */:\n                    case 104 /* PrivateKeyword */:\n                        var text;\n                        if (modifier.kind === 106 /* PublicKeyword */) {\n                            text = \"public\";\n                        }\n                        else if (modifier.kind === 105 /* ProtectedKeyword */) {\n                            text = \"protected\";\n                            lastProtected = modifier;\n                        }\n                        else {\n                            text = \"private\";\n                            lastPrivate = modifier;\n                        }\n                        if (flags & 112 /* AccessibilityModifier */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics.Accessibility_modifier_already_seen);\n                        }\n                        else if (flags & 128 /* Static */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, \"static\");\n                        }\n                        else if (node.parent.kind === 190 /* ModuleBlock */ || node.parent.kind === 201 /* SourceFile */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, text);\n                        }\n                        flags |= modifierToFlag(modifier.kind);\n                        break;\n                    case 107 /* StaticKeyword */:\n                        if (flags & 128 /* Static */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, \"static\");\n                        }\n                        else if (node.parent.kind === 190 /* ModuleBlock */ || node.parent.kind === 201 /* SourceFile */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_element, \"static\");\n                        }\n                        else if (node.kind === 123 /* Parameter */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, \"static\");\n                        }\n                        flags |= 128 /* Static */;\n                        lastStatic = modifier;\n                        break;\n                    case 76 /* ExportKeyword */:\n                        if (flags & 1 /* Export */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, \"export\");\n                        }\n                        else if (flags & 2 /* Ambient */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, \"export\", \"declare\");\n                        }\n                        else if (node.parent.kind === 185 /* ClassDeclaration */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, \"export\");\n                        }\n                        else if (node.kind === 123 /* Parameter */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, \"export\");\n                        }\n                        flags |= 1 /* Export */;\n                        break;\n                    case 112 /* DeclareKeyword */:\n                        if (flags & 2 /* Ambient */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, \"declare\");\n                        }\n                        else if (node.parent.kind === 185 /* ClassDeclaration */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, \"declare\");\n                        }\n                        else if (node.kind === 123 /* Parameter */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, \"declare\");\n                        }\n                        else if (inAmbientContext && node.parent.kind === 190 /* ModuleBlock */) {\n                            return grammarErrorOnNode(modifier, ts.Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);\n                        }\n                        flags |= 2 /* Ambient */;\n                        lastDeclare = modifier;\n                        break;\n                }\n            }\n            if (node.kind === 126 /* Constructor */) {\n                if (flags & 128 /* Static */) {\n                    return grammarErrorOnNode(lastStatic, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, \"static\");\n                }\n                else if (flags & 64 /* Protected */) {\n                    return grammarErrorOnNode(lastProtected, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, \"protected\");\n                }\n                else if (flags & 32 /* Private */) {\n                    return grammarErrorOnNode(lastPrivate, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, \"private\");\n                }\n            }\n            else if (node.kind === 191 /* ImportDeclaration */ && flags & 2 /* Ambient */) {\n                return grammarErrorOnNode(lastDeclare, ts.Diagnostics.A_declare_modifier_cannot_be_used_with_an_import_declaration, \"declare\");\n            }\n            else if (node.kind === 186 /* InterfaceDeclaration */ && flags & 2 /* Ambient */) {\n                return grammarErrorOnNode(lastDeclare, ts.Diagnostics.A_declare_modifier_cannot_be_used_with_an_interface_declaration, \"declare\");\n            }\n        }\n        function checkParameter(node) {\n            // It is a SyntaxError if the Identifier \"eval\" or the Identifier \"arguments\" occurs as the \n            // Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code \n            // or if its FunctionBody is strict code(11.1.5).\n            // It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a \n            // strict mode FunctionLikeDeclaration or FunctionExpression(13.1) \n            if (node.parserContextFlags & 1 /* StrictMode */ && isEvalOrArgumentsIdentifier(node.name)) {\n                return reportInvalidUseInStrictMode(node.name);\n            }\n        }\n        function checkTypeParameterList(typeParameters) {\n            if (checkForDisallowedTrailingComma(typeParameters)) {\n                return true;\n            }\n            if (typeParameters && typeParameters.length === 0) {\n                var start = typeParameters.pos - \"<\".length;\n                var end = ts.skipTrivia(sourceText, typeParameters.end) + \">\".length;\n                return grammarErrorAtPos(start, end - start, ts.Diagnostics.Type_parameter_list_cannot_be_empty);\n            }\n        }\n        function checkParameterList(parameters) {\n            if (checkForDisallowedTrailingComma(parameters)) {\n                return true;\n            }\n            var seenOptionalParameter = false;\n            var parameterCount = parameters.length;\n            for (var i = 0; i < parameterCount; i++) {\n                var parameter = parameters[i];\n                if (parameter.dotDotDotToken) {\n                    if (i !== (parameterCount - 1)) {\n                        return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);\n                    }\n                    if (parameter.questionToken) {\n                        return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_rest_parameter_cannot_be_optional);\n                    }\n                    if (parameter.initializer) {\n                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer);\n                    }\n                }\n                else if (parameter.questionToken || parameter.initializer) {\n                    seenOptionalParameter = true;\n                    if (parameter.questionToken && parameter.initializer) {\n                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.Parameter_cannot_have_question_mark_and_initializer);\n                    }\n                }\n                else {\n                    if (seenOptionalParameter) {\n                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);\n                    }\n                }\n            }\n        }\n        function checkPostfixUnaryExpression(node) {\n            // The identifier eval or arguments may not appear as the LeftHandSideExpression of an \n            // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression \n            // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator. \n            if (node.parserContextFlags & 1 /* StrictMode */ && isEvalOrArgumentsIdentifier(node.operand)) {\n                return reportInvalidUseInStrictMode(node.operand);\n            }\n        }\n        function checkPrefixUnaryExpression(node) {\n            if (node.parserContextFlags & 1 /* StrictMode */) {\n                // The identifier eval or arguments may not appear as the LeftHandSideExpression of an \n                // Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression \n                // operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator\n                if ((node.operator === 37 /* PlusPlusToken */ || node.operator === 38 /* MinusMinusToken */) && isEvalOrArgumentsIdentifier(node.operand)) {\n                    return reportInvalidUseInStrictMode(node.operand);\n                }\n            }\n        }\n        function checkProperty(node) {\n            if (node.parent.kind === 185 /* ClassDeclaration */) {\n                if (checkForInvalidQuestionMark(node, node.questionToken, ts.Diagnostics.A_class_member_cannot_be_declared_optional) || checkForDisallowedComputedProperty(node.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_class_property_declarations)) {\n                    return true;\n                }\n            }\n            else if (node.parent.kind === 186 /* InterfaceDeclaration */) {\n                if (checkForDisallowedComputedProperty(node.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_interfaces)) {\n                    return true;\n                }\n            }\n            else if (node.parent.kind === 136 /* TypeLiteral */) {\n                if (checkForDisallowedComputedProperty(node.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_type_literals)) {\n                    return true;\n                }\n            }\n            return checkForInitializerInAmbientContext(node);\n        }\n        function checkComputedPropertyName(node) {\n            // Since computed properties are not supported in the type checker, disallow them in TypeScript 1.4\n            // Once full support is added, remove this error.\n            return grammarErrorOnNode(node, ts.Diagnostics.Computed_property_names_are_not_currently_supported);\n            if (languageVersion < 2 /* ES6 */) {\n                return grammarErrorOnNode(node, ts.Diagnostics.Computed_property_names_are_only_available_when_targeting_ECMAScript_6_and_higher);\n            }\n            else if (node.expression.kind === 157 /* BinaryExpression */ && node.expression.operator === 22 /* CommaToken */) {\n                return grammarErrorOnNode(node.expression, ts.Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name);\n            }\n        }\n        function checkForDisallowedComputedProperty(node, message) {\n            if (node.kind === 121 /* ComputedPropertyName */) {\n                return grammarErrorOnNode(node, message);\n            }\n        }\n        function checkForInitializerInAmbientContext(node) {\n            if (inAmbientContext && node.initializer) {\n                return grammarErrorOnFirstToken(node.initializer, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);\n            }\n        }\n        function checkPropertyAssignment(node) {\n            return checkForInvalidQuestionMark(node, node.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional);\n        }\n        function checkForInvalidQuestionMark(node, questionToken, message) {\n            if (questionToken) {\n                return grammarErrorOnNode(questionToken, message);\n            }\n        }\n        function checkReturnStatement(node) {\n            if (!inFunctionBlock) {\n                return grammarErrorOnFirstToken(node, ts.Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);\n            }\n        }\n        function checkSetAccessor(node) {\n            return checkAnySignatureDeclaration(node) || checkAccessor(node);\n        }\n        function checkAccessor(accessor) {\n            var kind = accessor.kind;\n            if (languageVersion < 1 /* ES5 */) {\n                return grammarErrorOnNode(accessor.name, ts.Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);\n            }\n            else if (inAmbientContext) {\n                return grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_be_declared_in_an_ambient_context);\n            }\n            else if (accessor.body === undefined) {\n                return grammarErrorAtPos(accessor.end - 1, \";\".length, ts.Diagnostics._0_expected, \"{\");\n            }\n            else if (accessor.typeParameters) {\n                return grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_have_type_parameters);\n            }\n            else if (kind === 127 /* GetAccessor */ && accessor.parameters.length) {\n                return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_get_accessor_cannot_have_parameters);\n            }\n            else if (kind === 128 /* SetAccessor */) {\n                if (accessor.type) {\n                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);\n                }\n                else if (accessor.parameters.length !== 1) {\n                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter);\n                }\n                else {\n                    var parameter = accessor.parameters[0];\n                    if (parameter.dotDotDotToken) {\n                        return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter);\n                    }\n                    else if (parameter.flags & 243 /* Modifier */) {\n                        return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);\n                    }\n                    else if (parameter.questionToken) {\n                        return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);\n                    }\n                    else if (parameter.initializer) {\n                        return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);\n                    }\n                }\n            }\n        }\n        function checkSourceFile(node) {\n            return inAmbientContext && checkTopLevelElementsForRequiredDeclareModifier(file);\n        }\n        function checkTopLevelElementsForRequiredDeclareModifier(file) {\n            for (var i = 0, n = file.statements.length; i < n; i++) {\n                var decl = file.statements[i];\n                if (ts.isDeclaration(decl) || decl.kind === 164 /* VariableStatement */) {\n                    if (checkTopLevelElementForRequiredDeclareModifier(decl)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        function checkTopLevelElementForRequiredDeclareModifier(node) {\n            // A declare modifier is required for any top level .d.ts declaration except export=, interfaces and imports:\n            // categories:\n            //\n            //  DeclarationElement:\n            //     ExportAssignment\n            //     export_opt   InterfaceDeclaration\n            //     export_opt   ImportDeclaration\n            //     export_opt   ExternalImportDeclaration\n            //     export_opt   AmbientDeclaration\n            //\n            if (node.kind === 186 /* InterfaceDeclaration */ || node.kind === 191 /* ImportDeclaration */ || node.kind === 192 /* ExportAssignment */ || (node.flags & 2 /* Ambient */)) {\n                return false;\n            }\n            return grammarErrorOnFirstToken(node, ts.Diagnostics.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);\n        }\n        function checkShorthandPropertyAssignment(node) {\n            return checkForInvalidQuestionMark(node, node.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional);\n        }\n        function checkSwitchStatement(node) {\n            var firstDefaultClause;\n            for (var i = 0, n = node.clauses.length; i < n; i++) {\n                var clause = node.clauses[i];\n                if (clause.kind === 195 /* DefaultClause */) {\n                    if (firstDefaultClause === undefined) {\n                        firstDefaultClause = clause;\n                    }\n                    else {\n                        var start = ts.skipTrivia(file.text, clause.pos);\n                        var end = clause.statements.length > 0 ? clause.statements[0].pos : clause.end;\n                        return grammarErrorAtPos(start, end - start, ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);\n                    }\n                }\n            }\n        }\n        function checkTaggedTemplateExpression(node) {\n            if (languageVersion < 2 /* ES6 */) {\n                return grammarErrorOnFirstToken(node.template, ts.Diagnostics.Tagged_templates_are_only_available_when_targeting_ECMAScript_6_and_higher);\n            }\n        }\n        function checkThrowStatement(node) {\n            if (node.expression === undefined) {\n                return grammarErrorAfterFirstToken(node, ts.Diagnostics.Line_break_not_permitted_here);\n            }\n        }\n        function checkTupleType(node) {\n            return checkForDisallowedTrailingComma(node.elementTypes) || checkForAtLeastOneType(node);\n        }\n        function checkForAtLeastOneType(node) {\n            if (node.elementTypes.length === 0) {\n                return grammarErrorOnNode(node, ts.Diagnostics.A_tuple_type_element_list_cannot_be_empty);\n            }\n        }\n        function checkTypeParameter(node) {\n            if (node.expression) {\n                return grammarErrorOnFirstToken(node.expression, ts.Diagnostics.Type_expected);\n            }\n        }\n        function checkTypeReference(node) {\n            return checkTypeArguments(node.typeArguments);\n        }\n        function checkVariableDeclaration(node) {\n            if (inAmbientContext && node.initializer) {\n                var equalsPos = node.type ? ts.skipTrivia(sourceText, node.type.end) : ts.skipTrivia(sourceText, node.name.end);\n                return grammarErrorAtPos(equalsPos, \"=\".length, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);\n            }\n            if (!inAmbientContext && !node.initializer && ts.isConst(node)) {\n                return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_must_be_initialized);\n            }\n            if (node.parserContextFlags & 1 /* StrictMode */ && isEvalOrArgumentsIdentifier(node.name)) {\n                // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code \n                // and its Identifier is eval or arguments \n                return reportInvalidUseInStrictMode(node.name);\n            }\n        }\n        function checkVariableDeclarations(declarations) {\n            if (declarations) {\n                if (checkForDisallowedTrailingComma(declarations)) {\n                    return true;\n                }\n                if (!declarations.length) {\n                    return grammarErrorAtPos(declarations.pos, declarations.end - declarations.pos, ts.Diagnostics.Variable_declaration_list_cannot_be_empty);\n                }\n                var decl = declarations[0];\n                if (languageVersion < 2 /* ES6 */) {\n                    if (ts.isLet(decl)) {\n                        return grammarErrorOnFirstToken(decl, ts.Diagnostics.let_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher);\n                    }\n                    else if (ts.isConst(decl)) {\n                        return grammarErrorOnFirstToken(decl, ts.Diagnostics.const_declarations_are_only_available_when_targeting_ECMAScript_6_and_higher);\n                    }\n                }\n            }\n        }\n        function checkVariableStatement(node) {\n            return checkVariableDeclarations(node.declarations) || checkForDisallowedLetOrConstStatement(node);\n        }\n        function checkForDisallowedLetOrConstStatement(node) {\n            if (!allowLetAndConstDeclarations(node.parent)) {\n                if (ts.isLet(node)) {\n                    return grammarErrorOnNode(node, ts.Diagnostics.let_declarations_can_only_be_declared_inside_a_block);\n                }\n                else if (ts.isConst(node)) {\n                    return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_can_only_be_declared_inside_a_block);\n                }\n            }\n        }\n        function allowLetAndConstDeclarations(parent) {\n            switch (parent.kind) {\n                case 167 /* IfStatement */:\n                case 168 /* DoStatement */:\n                case 169 /* WhileStatement */:\n                case 175 /* WithStatement */:\n                case 170 /* ForStatement */:\n                case 171 /* ForInStatement */:\n                    return false;\n                case 177 /* LabeledStatement */:\n                    return allowLetAndConstDeclarations(parent.parent);\n            }\n            return true;\n        }\n        function checkWithStatement(node) {\n            if (node.parserContextFlags & 1 /* StrictMode */) {\n                // Strict mode code may not include a WithStatement. The occurrence of a WithStatement in such \n                // a context is an \n                return grammarErrorOnFirstToken(node, ts.Diagnostics.with_statements_are_not_allowed_in_strict_mode);\n            }\n        }\n        function checkYieldExpression(node) {\n            if (!(node.parserContextFlags & 4 /* Yield */)) {\n                return grammarErrorOnFirstToken(node, ts.Diagnostics.yield_expression_must_be_contained_within_a_generator_declaration);\n            }\n            return grammarErrorOnFirstToken(node, ts.Diagnostics.yield_expressions_are_not_currently_supported);\n        }\n    }\n    function createProgram(rootNames, options, host) {\n        var program;\n        var files = [];\n        var filesByName = {};\n        var errors = [];\n        var seenNoDefaultLib = options.noLib;\n        var commonSourceDirectory;\n        ts.forEach(rootNames, function (name) { return processRootFile(name, false); });\n        if (!seenNoDefaultLib) {\n            processRootFile(host.getDefaultLibFilename(options), true);\n        }\n        verifyCompilerOptions();\n        errors.sort(ts.compareDiagnostics);\n        program = {\n            getSourceFile: getSourceFile,\n            getSourceFiles: function () { return files; },\n            getCompilerOptions: function () { return options; },\n            getCompilerHost: function () { return host; },\n            getDiagnostics: getDiagnostics,\n            getGlobalDiagnostics: getGlobalDiagnostics,\n            getTypeChecker: function (fullTypeCheckMode) { return ts.createTypeChecker(program, fullTypeCheckMode); },\n            getCommonSourceDirectory: function () { return commonSourceDirectory; },\n        };\n        return program;\n        function getSourceFile(filename) {\n            filename = host.getCanonicalFileName(filename);\n            return ts.hasProperty(filesByName, filename) ? filesByName[filename] : undefined;\n        }\n        function getDiagnostics(sourceFile) {\n            return sourceFile ? ts.filter(errors, function (e) { return e.file === sourceFile; }) : errors;\n        }\n        function getGlobalDiagnostics() {\n            return ts.filter(errors, function (e) { return !e.file; });\n        }\n        function hasExtension(filename) {\n            return ts.getBaseFilename(filename).indexOf(\".\") >= 0;\n        }\n        function processRootFile(filename, isDefaultLib) {\n            processSourceFile(ts.normalizePath(filename), isDefaultLib);\n        }\n        function processSourceFile(filename, isDefaultLib, refFile, refPos, refEnd) {\n            if (refEnd !== undefined && refPos !== undefined) {\n                var start = refPos;\n                var length = refEnd - refPos;\n            }\n            var diagnostic;\n            if (hasExtension(filename)) {\n                if (!options.allowNonTsExtensions && !ts.fileExtensionIs(filename, \".ts\")) {\n                    diagnostic = ts.Diagnostics.File_0_must_have_extension_ts_or_d_ts;\n                }\n                else if (!findSourceFile(filename, isDefaultLib, refFile, refPos, refEnd)) {\n                    diagnostic = ts.Diagnostics.File_0_not_found;\n                }\n                else if (refFile && host.getCanonicalFileName(filename) === host.getCanonicalFileName(refFile.filename)) {\n                    diagnostic = ts.Diagnostics.A_file_cannot_have_a_reference_to_itself;\n                }\n            }\n            else {\n                if (options.allowNonTsExtensions && !findSourceFile(filename, isDefaultLib, refFile, refPos, refEnd)) {\n                    diagnostic = ts.Diagnostics.File_0_not_found;\n                }\n                else if (!findSourceFile(filename + \".ts\", isDefaultLib, refFile, refPos, refEnd) && !findSourceFile(filename + \".d.ts\", isDefaultLib, refFile, refPos, refEnd)) {\n                    diagnostic = ts.Diagnostics.File_0_not_found;\n                    filename += \".ts\";\n                }\n            }\n            if (diagnostic) {\n                if (refFile) {\n                    errors.push(ts.createFileDiagnostic(refFile, start, length, diagnostic, filename));\n                }\n                else {\n                    errors.push(ts.createCompilerDiagnostic(diagnostic, filename));\n                }\n            }\n        }\n        // Get source file from normalized filename\n        function findSourceFile(filename, isDefaultLib, refFile, refStart, refLength) {\n            var canonicalName = host.getCanonicalFileName(filename);\n            if (ts.hasProperty(filesByName, canonicalName)) {\n                // We've already looked for this file, use cached result\n                return getSourceFileFromCache(filename, canonicalName, false);\n            }\n            else {\n                var normalizedAbsolutePath = ts.getNormalizedAbsolutePath(filename, host.getCurrentDirectory());\n                var canonicalAbsolutePath = host.getCanonicalFileName(normalizedAbsolutePath);\n                if (ts.hasProperty(filesByName, canonicalAbsolutePath)) {\n                    return getSourceFileFromCache(normalizedAbsolutePath, canonicalAbsolutePath, true);\n                }\n                // We haven't looked for this file, do so now and cache result\n                var file = filesByName[canonicalName] = host.getSourceFile(filename, options.target, function (hostErrorMessage) {\n                    errors.push(ts.createFileDiagnostic(refFile, refStart, refLength, ts.Diagnostics.Cannot_read_file_0_Colon_1, filename, hostErrorMessage));\n                });\n                if (file) {\n                    seenNoDefaultLib = seenNoDefaultLib || file.hasNoDefaultLib;\n                    // Set the source file for normalized absolute path\n                    filesByName[canonicalAbsolutePath] = file;\n                    if (!options.noResolve) {\n                        var basePath = ts.getDirectoryPath(filename);\n                        processReferencedFiles(file, basePath);\n                        processImportedModules(file, basePath);\n                    }\n                    if (isDefaultLib) {\n                        files.unshift(file);\n                    }\n                    else {\n                        files.push(file);\n                    }\n                    ts.forEach(file.getSyntacticDiagnostics(), function (e) {\n                        errors.push(e);\n                    });\n                }\n            }\n            return file;\n            function getSourceFileFromCache(filename, canonicalName, useAbsolutePath) {\n                var file = filesByName[canonicalName];\n                if (file && host.useCaseSensitiveFileNames()) {\n                    var sourceFileName = useAbsolutePath ? ts.getNormalizedAbsolutePath(file.filename, host.getCurrentDirectory()) : file.filename;\n                    if (canonicalName !== sourceFileName) {\n                        errors.push(ts.createFileDiagnostic(refFile, refStart, refLength, ts.Diagnostics.Filename_0_differs_from_already_included_filename_1_only_in_casing, filename, sourceFileName));\n                    }\n                }\n                return file;\n            }\n        }\n        function processReferencedFiles(file, basePath) {\n            ts.forEach(file.referencedFiles, function (ref) {\n                var referencedFilename = ts.isRootedDiskPath(ref.filename) ? ref.filename : ts.combinePaths(basePath, ref.filename);\n                processSourceFile(ts.normalizePath(referencedFilename), false, file, ref.pos, ref.end);\n            });\n        }\n        function processImportedModules(file, basePath) {\n            ts.forEach(file.statements, function (node) {\n                if (ts.isExternalModuleImportDeclaration(node) && ts.getExternalModuleImportDeclarationExpression(node).kind === 7 /* StringLiteral */) {\n                    var nameLiteral = ts.getExternalModuleImportDeclarationExpression(node);\n                    var moduleName = nameLiteral.text;\n                    if (moduleName) {\n                        var searchPath = basePath;\n                        while (true) {\n                            var searchName = ts.normalizePath(ts.combinePaths(searchPath, moduleName));\n                            if (findModuleSourceFile(searchName + \".ts\", nameLiteral) || findModuleSourceFile(searchName + \".d.ts\", nameLiteral)) {\n                                break;\n                            }\n                            var parentPath = ts.getDirectoryPath(searchPath);\n                            if (parentPath === searchPath) {\n                                break;\n                            }\n                            searchPath = parentPath;\n                        }\n                    }\n                }\n                else if (node.kind === 189 /* ModuleDeclaration */ && node.name.kind === 7 /* StringLiteral */ && (node.flags & 2 /* Ambient */ || ts.isDeclarationFile(file))) {\n                    // TypeScript 1.0 spec (April 2014): 12.1.6\n                    // An AmbientExternalModuleDeclaration declares an external module. \n                    // This type of declaration is permitted only in the global module.\n                    // The StringLiteral must specify a top - level external module name.\n                    // Relative external module names are not permitted\n                    forEachChild(node.body, function (node) {\n                        if (ts.isExternalModuleImportDeclaration(node) && ts.getExternalModuleImportDeclarationExpression(node).kind === 7 /* StringLiteral */) {\n                            var nameLiteral = ts.getExternalModuleImportDeclarationExpression(node);\n                            var moduleName = nameLiteral.text;\n                            if (moduleName) {\n                                // TypeScript 1.0 spec (April 2014): 12.1.6\n                                // An ExternalImportDeclaration in anAmbientExternalModuleDeclaration may reference other external modules \n                                // only through top - level external module names. Relative external module names are not permitted.\n                                var searchName = ts.normalizePath(ts.combinePaths(basePath, moduleName));\n                                var tsFile = findModuleSourceFile(searchName + \".ts\", nameLiteral);\n                                if (!tsFile) {\n                                    findModuleSourceFile(searchName + \".d.ts\", nameLiteral);\n                                }\n                            }\n                        }\n                    });\n                }\n            });\n            function findModuleSourceFile(filename, nameLiteral) {\n                return findSourceFile(filename, false, file, nameLiteral.pos, nameLiteral.end - nameLiteral.pos);\n            }\n        }\n        function verifyCompilerOptions() {\n            if (!options.sourceMap && (options.mapRoot || options.sourceRoot)) {\n                // Error to specify --mapRoot or --sourceRoot without mapSourceFiles\n                if (options.mapRoot) {\n                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option));\n                }\n                if (options.sourceRoot) {\n                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option));\n                }\n                return;\n            }\n            var firstExternalModule = ts.forEach(files, function (f) { return ts.isExternalModule(f) ? f : undefined; });\n            if (firstExternalModule && options.module === 0 /* None */) {\n                // We cannot use createDiagnosticFromNode because nodes do not have parents yet\n                var externalModuleErrorSpan = ts.getErrorSpanForNode(firstExternalModule.externalModuleIndicator);\n                var errorStart = ts.skipTrivia(firstExternalModule.text, externalModuleErrorSpan.pos);\n                var errorLength = externalModuleErrorSpan.end - errorStart;\n                errors.push(ts.createFileDiagnostic(firstExternalModule, errorStart, errorLength, ts.Diagnostics.Cannot_compile_external_modules_unless_the_module_flag_is_provided));\n            }\n            // there has to be common source directory if user specified --outdir || --sourcRoot\n            // if user specified --mapRoot, there needs to be common source directory if there would be multiple files being emitted\n            if (options.outDir || options.sourceRoot || (options.mapRoot && (!options.out || firstExternalModule !== undefined))) {\n                var commonPathComponents;\n                ts.forEach(files, function (sourceFile) {\n                    // Each file contributes into common source file path\n                    if (!(sourceFile.flags & 1024 /* DeclarationFile */) && !ts.fileExtensionIs(sourceFile.filename, \".js\")) {\n                        var sourcePathComponents = ts.getNormalizedPathComponents(sourceFile.filename, host.getCurrentDirectory());\n                        sourcePathComponents.pop(); // FileName is not part of directory\n                        if (commonPathComponents) {\n                            for (var i = 0; i < Math.min(commonPathComponents.length, sourcePathComponents.length); i++) {\n                                if (commonPathComponents[i] !== sourcePathComponents[i]) {\n                                    if (i === 0) {\n                                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_find_the_common_subdirectory_path_for_the_input_files));\n                                        return;\n                                    }\n                                    // New common path found that is 0 -> i-1\n                                    commonPathComponents.length = i;\n                                    break;\n                                }\n                            }\n                            // If the fileComponent path completely matched and less than already found update the length\n                            if (sourcePathComponents.length < commonPathComponents.length) {\n                                commonPathComponents.length = sourcePathComponents.length;\n                            }\n                        }\n                        else {\n                            // first file\n                            commonPathComponents = sourcePathComponents;\n                        }\n                    }\n                });\n                commonSourceDirectory = ts.getNormalizedPathFromPathComponents(commonPathComponents);\n                if (commonSourceDirectory) {\n                    // Make sure directory path ends with directory separator so this string can directly \n                    // used to replace with \"\" to get the relative path of the source file and the relative path doesn't\n                    // start with / making it rooted path\n                    commonSourceDirectory += ts.directorySeparator;\n                }\n            }\n        }\n    }\n    ts.createProgram = createProgram;\n})(ts || (ts = {}));\n/// <reference path=\"types.ts\"/>\n/// <reference path=\"core.ts\"/>\n/// <reference path=\"scanner.ts\"/>\n/// <reference path=\"parser.ts\"/>\nvar ts;\n(function (ts) {\n    function getModuleInstanceState(node) {\n        // A module is uninstantiated if it contains only \n        // 1. interface declarations\n        if (node.kind === 186 /* InterfaceDeclaration */) {\n            return 0 /* NonInstantiated */;\n        }\n        else if (ts.isConstEnumDeclaration(node)) {\n            return 2 /* ConstEnumOnly */;\n        }\n        else if (node.kind === 191 /* ImportDeclaration */ && !(node.flags & 1 /* Export */)) {\n            return 0 /* NonInstantiated */;\n        }\n        else if (node.kind === 190 /* ModuleBlock */) {\n            var state = 0 /* NonInstantiated */;\n            ts.forEachChild(node, function (n) {\n                switch (getModuleInstanceState(n)) {\n                    case 0 /* NonInstantiated */:\n                        // child is non-instantiated - continue searching\n                        return false;\n                    case 2 /* ConstEnumOnly */:\n                        // child is const enum only - record state and continue searching\n                        state = 2 /* ConstEnumOnly */;\n                        return false;\n                    case 1 /* Instantiated */:\n                        // child is instantiated - record state and stop\n                        state = 1 /* Instantiated */;\n                        return true;\n                }\n            });\n            return state;\n        }\n        else if (node.kind === 189 /* ModuleDeclaration */) {\n            return getModuleInstanceState(node.body);\n        }\n        else {\n            return 1 /* Instantiated */;\n        }\n    }\n    ts.getModuleInstanceState = getModuleInstanceState;\n    /**\n     * Returns false if any of the following are true:\n     *   1. declaration has no name\n     *   2. declaration has a literal name (not computed)\n     *   3. declaration has a computed property name that is a known symbol\n     */\n    function hasComputedNameButNotSymbol(declaration) {\n        return declaration.name && declaration.name.kind === 121 /* ComputedPropertyName */;\n    }\n    ts.hasComputedNameButNotSymbol = hasComputedNameButNotSymbol;\n    function bindSourceFile(file) {\n        var parent;\n        var container;\n        var blockScopeContainer;\n        var lastContainer;\n        var symbolCount = 0;\n        var Symbol = ts.objectAllocator.getSymbolConstructor();\n        if (!file.locals) {\n            file.locals = {};\n            container = blockScopeContainer = file;\n            bind(file);\n            file.symbolCount = symbolCount;\n        }\n        function createSymbol(flags, name) {\n            symbolCount++;\n            return new Symbol(flags, name);\n        }\n        function addDeclarationToSymbol(symbol, node, symbolKind) {\n            symbol.flags |= symbolKind;\n            if (!symbol.declarations)\n                symbol.declarations = [];\n            symbol.declarations.push(node);\n            if (symbolKind & 1952 /* HasExports */ && !symbol.exports)\n                symbol.exports = {};\n            if (symbolKind & 6240 /* HasMembers */ && !symbol.members)\n                symbol.members = {};\n            node.symbol = symbol;\n            if (symbolKind & 107455 /* Value */ && !symbol.valueDeclaration)\n                symbol.valueDeclaration = node;\n        }\n        // Should not be called on a declaration with a computed property name.\n        function getDeclarationName(node) {\n            if (node.name) {\n                if (node.kind === 189 /* ModuleDeclaration */ && node.name.kind === 7 /* StringLiteral */) {\n                    return '\"' + node.name.text + '\"';\n                }\n                ts.Debug.assert(!hasComputedNameButNotSymbol(node));\n                return node.name.text;\n            }\n            switch (node.kind) {\n                case 134 /* ConstructorType */:\n                case 126 /* Constructor */:\n                    return \"__constructor\";\n                case 133 /* FunctionType */:\n                case 129 /* CallSignature */:\n                    return \"__call\";\n                case 130 /* ConstructSignature */:\n                    return \"__new\";\n                case 131 /* IndexSignature */:\n                    return \"__index\";\n            }\n        }\n        function getDisplayName(node) {\n            return node.name ? ts.declarationNameToString(node.name) : getDeclarationName(node);\n        }\n        function declareSymbol(symbols, parent, node, includes, excludes) {\n            // Nodes with computed property names will not get symbols, because the type checker\n            // does not make properties for them.\n            if (hasComputedNameButNotSymbol(node)) {\n                return undefined;\n            }\n            var name = getDeclarationName(node);\n            if (name !== undefined) {\n                var symbol = ts.hasProperty(symbols, name) ? symbols[name] : (symbols[name] = createSymbol(0, name));\n                if (symbol.flags & excludes) {\n                    if (node.name) {\n                        node.name.parent = node;\n                    }\n                    // Report errors every position with duplicate declaration\n                    // Report errors on previous encountered declarations\n                    var message = symbol.flags & 2 /* BlockScopedVariable */ ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0 : ts.Diagnostics.Duplicate_identifier_0;\n                    ts.forEach(symbol.declarations, function (declaration) {\n                        file.semanticDiagnostics.push(ts.createDiagnosticForNode(declaration.name, message, getDisplayName(declaration)));\n                    });\n                    file.semanticDiagnostics.push(ts.createDiagnosticForNode(node.name, message, getDisplayName(node)));\n                    symbol = createSymbol(0, name);\n                }\n            }\n            else {\n                symbol = createSymbol(0, \"__missing\");\n            }\n            addDeclarationToSymbol(symbol, node, includes);\n            symbol.parent = parent;\n            if (node.kind === 185 /* ClassDeclaration */ && symbol.exports) {\n                // TypeScript 1.0 spec (April 2014): 8.4\n                // Every class automatically contains a static property member named 'prototype', \n                // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.\n                // It is an error to explicitly declare a static property member with the name 'prototype'.\n                var prototypeSymbol = createSymbol(4 /* Property */ | 536870912 /* Prototype */, \"prototype\");\n                if (ts.hasProperty(symbol.exports, prototypeSymbol.name)) {\n                    if (node.name) {\n                        node.name.parent = node;\n                    }\n                    file.semanticDiagnostics.push(ts.createDiagnosticForNode(symbol.exports[prototypeSymbol.name].declarations[0], ts.Diagnostics.Duplicate_identifier_0, prototypeSymbol.name));\n                }\n                symbol.exports[prototypeSymbol.name] = prototypeSymbol;\n                prototypeSymbol.parent = symbol;\n            }\n            return symbol;\n        }\n        function isAmbientContext(node) {\n            while (node) {\n                if (node.flags & 2 /* Ambient */)\n                    return true;\n                node = node.parent;\n            }\n            return false;\n        }\n        function declareModuleMember(node, symbolKind, symbolExcludes) {\n            // Exported module members are given 2 symbols: A local symbol that is classified with an ExportValue,\n            // ExportType, or ExportContainer flag, and an associated export symbol with all the correct flags set\n            // on it. There are 2 main reasons:\n            //\n            //   1. We treat locals and exports of the same name as mutually exclusive within a container. \n            //      That means the binder will issue a Duplicate Identifier error if you mix locals and exports\n            //      with the same name in the same container.\n            //      TODO: Make this a more specific error and decouple it from the exclusion logic.\n            //   2. When we checkIdentifier in the checker, we set its resolved symbol to the local symbol,\n            //      but return the export symbol (by calling getExportSymbolOfValueSymbolIfExported). That way\n            //      when the emitter comes back to it, it knows not to qualify the name if it was found in a containing scope.\n            var exportKind = 0;\n            if (symbolKind & 107455 /* Value */) {\n                exportKind |= 4194304 /* ExportValue */;\n            }\n            if (symbolKind & 3152352 /* Type */) {\n                exportKind |= 8388608 /* ExportType */;\n            }\n            if (symbolKind & 1536 /* Namespace */) {\n                exportKind |= 16777216 /* ExportNamespace */;\n            }\n            if (node.flags & 1 /* Export */ || (node.kind !== 191 /* ImportDeclaration */ && isAmbientContext(container))) {\n                if (exportKind) {\n                    var local = declareSymbol(container.locals, undefined, node, exportKind, symbolExcludes);\n                    local.exportSymbol = declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);\n                    node.localSymbol = local;\n                }\n                else {\n                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);\n                }\n            }\n            else {\n                declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);\n            }\n        }\n        // All container nodes are kept on a linked list in declaration order. This list is used by the getLocalNameOfContainer function\n        // in the type checker to validate that the local name used for a container is unique.\n        function bindChildren(node, symbolKind, isBlockScopeContainer) {\n            if (symbolKind & 1041936 /* HasLocals */) {\n                node.locals = {};\n            }\n            var saveParent = parent;\n            var saveContainer = container;\n            var savedBlockScopeContainer = blockScopeContainer;\n            parent = node;\n            if (symbolKind & 1048560 /* IsContainer */) {\n                container = node;\n                // If container is not on container list, add it to the list\n                if (lastContainer !== container && !container.nextContainer) {\n                    if (lastContainer) {\n                        lastContainer.nextContainer = container;\n                    }\n                    lastContainer = container;\n                }\n            }\n            if (isBlockScopeContainer) {\n                blockScopeContainer = node;\n            }\n            ts.forEachChild(node, bind);\n            container = saveContainer;\n            parent = saveParent;\n            blockScopeContainer = savedBlockScopeContainer;\n        }\n        function bindDeclaration(node, symbolKind, symbolExcludes, isBlockScopeContainer) {\n            switch (container.kind) {\n                case 189 /* ModuleDeclaration */:\n                    declareModuleMember(node, symbolKind, symbolExcludes);\n                    break;\n                case 201 /* SourceFile */:\n                    if (ts.isExternalModule(container)) {\n                        declareModuleMember(node, symbolKind, symbolExcludes);\n                        break;\n                    }\n                case 133 /* FunctionType */:\n                case 134 /* ConstructorType */:\n                case 129 /* CallSignature */:\n                case 130 /* ConstructSignature */:\n                case 131 /* IndexSignature */:\n                case 125 /* Method */:\n                case 126 /* Constructor */:\n                case 127 /* GetAccessor */:\n                case 128 /* SetAccessor */:\n                case 184 /* FunctionDeclaration */:\n                case 150 /* FunctionExpression */:\n                case 151 /* ArrowFunction */:\n                    declareSymbol(container.locals, undefined, node, symbolKind, symbolExcludes);\n                    break;\n                case 185 /* ClassDeclaration */:\n                    if (node.flags & 128 /* Static */) {\n                        declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);\n                        break;\n                    }\n                case 136 /* TypeLiteral */:\n                case 142 /* ObjectLiteralExpression */:\n                case 186 /* InterfaceDeclaration */:\n                    declareSymbol(container.symbol.members, container.symbol, node, symbolKind, symbolExcludes);\n                    break;\n                case 188 /* EnumDeclaration */:\n                    declareSymbol(container.symbol.exports, container.symbol, node, symbolKind, symbolExcludes);\n                    break;\n            }\n            bindChildren(node, symbolKind, isBlockScopeContainer);\n        }\n        function bindConstructorDeclaration(node) {\n            bindDeclaration(node, 16384 /* Constructor */, 0, true);\n            ts.forEach(node.parameters, function (p) {\n                if (p.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */)) {\n                    bindDeclaration(p, 4 /* Property */, 107455 /* PropertyExcludes */, false);\n                }\n            });\n        }\n        function bindModuleDeclaration(node) {\n            if (node.name.kind === 7 /* StringLiteral */) {\n                bindDeclaration(node, 512 /* ValueModule */, 106639 /* ValueModuleExcludes */, true);\n            }\n            else {\n                var state = getModuleInstanceState(node);\n                if (state === 0 /* NonInstantiated */) {\n                    bindDeclaration(node, 1024 /* NamespaceModule */, 0 /* NamespaceModuleExcludes */, true);\n                }\n                else {\n                    bindDeclaration(node, 512 /* ValueModule */, 106639 /* ValueModuleExcludes */, true);\n                    if (state === 2 /* ConstEnumOnly */) {\n                        // mark value module as module that contains only enums\n                        node.symbol.constEnumOnlyModule = true;\n                    }\n                    else if (node.symbol.constEnumOnlyModule) {\n                        // const only value module was merged with instantiated module - reset flag\n                        node.symbol.constEnumOnlyModule = false;\n                    }\n                }\n            }\n        }\n        function bindFunctionOrConstructorType(node) {\n            // For a given function symbol \"<...>(...) => T\" we want to generate a symbol identical\n            // to the one we would get for: { <...>(...): T }\n            //\n            // We do that by making an anonymous type literal symbol, and then setting the function \n            // symbol as its sole member. To the rest of the system, this symbol will be  indistinguishable \n            // from an actual type literal symbol you would have gotten had you used the long form.\n            var symbolKind = node.kind === 133 /* FunctionType */ ? 131072 /* CallSignature */ : 262144 /* ConstructSignature */;\n            var symbol = createSymbol(symbolKind, getDeclarationName(node));\n            addDeclarationToSymbol(symbol, node, symbolKind);\n            bindChildren(node, symbolKind, false);\n            var typeLiteralSymbol = createSymbol(2048 /* TypeLiteral */, \"__type\");\n            addDeclarationToSymbol(typeLiteralSymbol, node, 2048 /* TypeLiteral */);\n            typeLiteralSymbol.members = {};\n            typeLiteralSymbol.members[node.kind === 133 /* FunctionType */ ? \"__call\" : \"__new\"] = symbol;\n        }\n        function bindAnonymousDeclaration(node, symbolKind, name, isBlockScopeContainer) {\n            var symbol = createSymbol(symbolKind, name);\n            addDeclarationToSymbol(symbol, node, symbolKind);\n            bindChildren(node, symbolKind, isBlockScopeContainer);\n        }\n        function bindCatchVariableDeclaration(node) {\n            var symbol = createSymbol(1 /* FunctionScopedVariable */, node.name.text || \"__missing\");\n            addDeclarationToSymbol(symbol, node, 1 /* FunctionScopedVariable */);\n            var saveParent = parent;\n            var savedBlockScopeContainer = blockScopeContainer;\n            parent = blockScopeContainer = node;\n            ts.forEachChild(node, bind);\n            parent = saveParent;\n            blockScopeContainer = savedBlockScopeContainer;\n        }\n        function bindBlockScopedVariableDeclaration(node) {\n            switch (blockScopeContainer.kind) {\n                case 189 /* ModuleDeclaration */:\n                    declareModuleMember(node, 2 /* BlockScopedVariable */, 107455 /* BlockScopedVariableExcludes */);\n                    break;\n                case 201 /* SourceFile */:\n                    if (ts.isExternalModule(container)) {\n                        declareModuleMember(node, 2 /* BlockScopedVariable */, 107455 /* BlockScopedVariableExcludes */);\n                        break;\n                    }\n                default:\n                    if (!blockScopeContainer.locals) {\n                        blockScopeContainer.locals = {};\n                    }\n                    declareSymbol(blockScopeContainer.locals, undefined, node, 2 /* BlockScopedVariable */, 107455 /* BlockScopedVariableExcludes */);\n            }\n            bindChildren(node, 2 /* BlockScopedVariable */, false);\n        }\n        function bind(node) {\n            node.parent = parent;\n            switch (node.kind) {\n                case 122 /* TypeParameter */:\n                    bindDeclaration(node, 1048576 /* TypeParameter */, 2103776 /* TypeParameterExcludes */, false);\n                    break;\n                case 123 /* Parameter */:\n                    bindDeclaration(node, 1 /* FunctionScopedVariable */, 107455 /* ParameterExcludes */, false);\n                    break;\n                case 183 /* VariableDeclaration */:\n                    if (node.flags & 6144 /* BlockScoped */) {\n                        bindBlockScopedVariableDeclaration(node);\n                    }\n                    else {\n                        bindDeclaration(node, 1 /* FunctionScopedVariable */, 107454 /* FunctionScopedVariableExcludes */, false);\n                    }\n                    break;\n                case 124 /* Property */:\n                case 198 /* PropertyAssignment */:\n                case 199 /* ShorthandPropertyAssignment */:\n                    bindDeclaration(node, 4 /* Property */, 107455 /* PropertyExcludes */, false);\n                    break;\n                case 200 /* EnumMember */:\n                    bindDeclaration(node, 8 /* EnumMember */, 107455 /* EnumMemberExcludes */, false);\n                    break;\n                case 129 /* CallSignature */:\n                    bindDeclaration(node, 131072 /* CallSignature */, 0, false);\n                    break;\n                case 130 /* ConstructSignature */:\n                    bindDeclaration(node, 262144 /* ConstructSignature */, 0, true);\n                    break;\n                case 125 /* Method */:\n                    // If this is an ObjectLiteralExpression method, then it sits in the same space\n                    // as other properties in the object literal.  So we use SymbolFlags.PropertyExcludes\n                    // so that it will conflict with any other object literal members with the same\n                    // name.\n                    bindDeclaration(node, 8192 /* Method */, ts.isObjectLiteralMethod(node) ? 107455 /* PropertyExcludes */ : 99263 /* MethodExcludes */, true);\n                    break;\n                case 131 /* IndexSignature */:\n                    bindDeclaration(node, 524288 /* IndexSignature */, 0, false);\n                    break;\n                case 184 /* FunctionDeclaration */:\n                    bindDeclaration(node, 16 /* Function */, 106927 /* FunctionExcludes */, true);\n                    break;\n                case 126 /* Constructor */:\n                    bindConstructorDeclaration(node);\n                    break;\n                case 127 /* GetAccessor */:\n                    bindDeclaration(node, 32768 /* GetAccessor */, 41919 /* GetAccessorExcludes */, true);\n                    break;\n                case 128 /* SetAccessor */:\n                    bindDeclaration(node, 65536 /* SetAccessor */, 74687 /* SetAccessorExcludes */, true);\n                    break;\n                case 133 /* FunctionType */:\n                case 134 /* ConstructorType */:\n                    bindFunctionOrConstructorType(node);\n                    break;\n                case 136 /* TypeLiteral */:\n                    bindAnonymousDeclaration(node, 2048 /* TypeLiteral */, \"__type\", false);\n                    break;\n                case 142 /* ObjectLiteralExpression */:\n                    bindAnonymousDeclaration(node, 4096 /* ObjectLiteral */, \"__object\", false);\n                    break;\n                case 150 /* FunctionExpression */:\n                case 151 /* ArrowFunction */:\n                    bindAnonymousDeclaration(node, 16 /* Function */, \"__function\", true);\n                    break;\n                case 197 /* CatchClause */:\n                    bindCatchVariableDeclaration(node);\n                    break;\n                case 185 /* ClassDeclaration */:\n                    bindDeclaration(node, 32 /* Class */, 3258879 /* ClassExcludes */, false);\n                    break;\n                case 186 /* InterfaceDeclaration */:\n                    bindDeclaration(node, 64 /* Interface */, 3152288 /* InterfaceExcludes */, false);\n                    break;\n                case 187 /* TypeAliasDeclaration */:\n                    bindDeclaration(node, 2097152 /* TypeAlias */, 3152352 /* TypeAliasExcludes */, false);\n                    break;\n                case 188 /* EnumDeclaration */:\n                    if (ts.isConst(node)) {\n                        bindDeclaration(node, 128 /* ConstEnum */, 3259263 /* ConstEnumExcludes */, false);\n                    }\n                    else {\n                        bindDeclaration(node, 256 /* RegularEnum */, 3258623 /* RegularEnumExcludes */, false);\n                    }\n                    break;\n                case 189 /* ModuleDeclaration */:\n                    bindModuleDeclaration(node);\n                    break;\n                case 191 /* ImportDeclaration */:\n                    bindDeclaration(node, 33554432 /* Import */, 33554432 /* ImportExcludes */, false);\n                    break;\n                case 201 /* SourceFile */:\n                    if (ts.isExternalModule(node)) {\n                        bindAnonymousDeclaration(node, 512 /* ValueModule */, '\"' + ts.removeFileExtension(node.filename) + '\"', true);\n                        break;\n                    }\n                case 163 /* Block */:\n                case 180 /* TryBlock */:\n                case 197 /* CatchClause */:\n                case 181 /* FinallyBlock */:\n                case 170 /* ForStatement */:\n                case 171 /* ForInStatement */:\n                case 176 /* SwitchStatement */:\n                    bindChildren(node, 0, true);\n                    break;\n                default:\n                    var saveParent = parent;\n                    parent = node;\n                    ts.forEachChild(node, bind);\n                    parent = saveParent;\n            }\n        }\n    }\n    ts.bindSourceFile = bindSourceFile;\n})(ts || (ts = {}));\n/// <reference path=\"types.ts\"/>\n/// <reference path=\"core.ts\"/>\n/// <reference path=\"scanner.ts\"/>\n/// <reference path=\"parser.ts\"/>\n/// <reference path=\"binder.ts\"/>\nvar ts;\n(function (ts) {\n    var indentStrings = [\"\", \"    \"];\n    function getIndentString(level) {\n        if (indentStrings[level] === undefined) {\n            indentStrings[level] = getIndentString(level - 1) + indentStrings[1];\n        }\n        return indentStrings[level];\n    }\n    ts.getIndentString = getIndentString;\n    function getIndentSize() {\n        return indentStrings[1].length;\n    }\n    function shouldEmitToOwnFile(sourceFile, compilerOptions) {\n        if (!ts.isDeclarationFile(sourceFile)) {\n            if ((ts.isExternalModule(sourceFile) || !compilerOptions.out) && !ts.fileExtensionIs(sourceFile.filename, \".js\")) {\n                return true;\n            }\n            return false;\n        }\n        return false;\n    }\n    ts.shouldEmitToOwnFile = shouldEmitToOwnFile;\n    function isExternalModuleOrDeclarationFile(sourceFile) {\n        return ts.isExternalModule(sourceFile) || ts.isDeclarationFile(sourceFile);\n    }\n    ts.isExternalModuleOrDeclarationFile = isExternalModuleOrDeclarationFile;\n    function createTextWriter(newLine) {\n        var output = \"\";\n        var indent = 0;\n        var lineStart = true;\n        var lineCount = 0;\n        var linePos = 0;\n        function write(s) {\n            if (s && s.length) {\n                if (lineStart) {\n                    output += getIndentString(indent);\n                    lineStart = false;\n                }\n                output += s;\n            }\n        }\n        function rawWrite(s) {\n            if (s !== undefined) {\n                if (lineStart) {\n                    lineStart = false;\n                }\n                output += s;\n            }\n        }\n        function writeLiteral(s) {\n            if (s && s.length) {\n                write(s);\n                var lineStartsOfS = ts.computeLineStarts(s);\n                if (lineStartsOfS.length > 1) {\n                    lineCount = lineCount + lineStartsOfS.length - 1;\n                    linePos = output.length - s.length + lineStartsOfS[lineStartsOfS.length - 1];\n                }\n            }\n        }\n        function writeLine() {\n            if (!lineStart) {\n                output += newLine;\n                lineCount++;\n                linePos = output.length;\n                lineStart = true;\n            }\n        }\n        function writeTextOfNode(sourceFile, node) {\n            write(ts.getSourceTextOfNodeFromSourceFile(sourceFile, node));\n        }\n        return {\n            write: write,\n            rawWrite: rawWrite,\n            writeTextOfNode: writeTextOfNode,\n            writeLiteral: writeLiteral,\n            writeLine: writeLine,\n            increaseIndent: function () { return indent++; },\n            decreaseIndent: function () { return indent--; },\n            getIndent: function () { return indent; },\n            getTextPos: function () { return output.length; },\n            getLine: function () { return lineCount + 1; },\n            getColumn: function () { return lineStart ? indent * getIndentSize() + 1 : output.length - linePos + 1; },\n            getText: function () { return output; },\n        };\n    }\n    function getLineOfLocalPosition(currentSourceFile, pos) {\n        return currentSourceFile.getLineAndCharacterFromPosition(pos).line;\n    }\n    function emitNewLineBeforeLeadingComments(currentSourceFile, writer, node, leadingComments) {\n        // If the leading comments start on different line than the start of node, write new line\n        if (leadingComments && leadingComments.length && node.pos !== leadingComments[0].pos && getLineOfLocalPosition(currentSourceFile, node.pos) !== getLineOfLocalPosition(currentSourceFile, leadingComments[0].pos)) {\n            writer.writeLine();\n        }\n    }\n    function emitComments(currentSourceFile, writer, comments, trailingSeparator, newLine, writeComment) {\n        var emitLeadingSpace = !trailingSeparator;\n        ts.forEach(comments, function (comment) {\n            if (emitLeadingSpace) {\n                writer.write(\" \");\n                emitLeadingSpace = false;\n            }\n            writeComment(currentSourceFile, writer, comment, newLine);\n            if (comment.hasTrailingNewLine) {\n                writer.writeLine();\n            }\n            else if (trailingSeparator) {\n                writer.write(\" \");\n            }\n            else {\n                // Emit leading space to separate comment during next comment emit\n                emitLeadingSpace = true;\n            }\n        });\n    }\n    function writeCommentRange(currentSourceFile, writer, comment, newLine) {\n        if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */) {\n            var firstCommentLineAndCharacter = currentSourceFile.getLineAndCharacterFromPosition(comment.pos);\n            var firstCommentLineIndent;\n            for (var pos = comment.pos, currentLine = firstCommentLineAndCharacter.line; pos < comment.end; currentLine++) {\n                var nextLineStart = currentSourceFile.getPositionFromLineAndCharacter(currentLine + 1, 1);\n                if (pos !== comment.pos) {\n                    // If we are not emitting first line, we need to write the spaces to adjust the alignment\n                    if (firstCommentLineIndent === undefined) {\n                        firstCommentLineIndent = calculateIndent(currentSourceFile.getPositionFromLineAndCharacter(firstCommentLineAndCharacter.line, 1), comment.pos);\n                    }\n                    // These are number of spaces writer is going to write at current indent\n                    var currentWriterIndentSpacing = writer.getIndent() * getIndentSize();\n                    // Number of spaces we want to be writing\n                    // eg: Assume writer indent\n                    // module m {\n                    //         /* starts at character 9 this is line 1\n                    //    * starts at character pos 4 line                        --1  = 8 - 8 + 3\n                    //   More left indented comment */                            --2  = 8 - 8 + 2\n                    //     class c { }\n                    // }\n                    // module m {\n                    //     /* this is line 1 -- Assume current writer indent 8\n                    //      * line                                                --3 = 8 - 4 + 5 \n                    //            More right indented comment */                  --4 = 8 - 4 + 11\n                    //     class c { }\n                    // }\n                    var spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(pos, nextLineStart);\n                    if (spacesToEmit > 0) {\n                        var numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();\n                        var indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());\n                        // Write indent size string ( in eg 1: = \"\", 2: \"\" , 3: string with 8 spaces 4: string with 12 spaces\n                        writer.rawWrite(indentSizeSpaceString);\n                        while (numberOfSingleSpacesToEmit) {\n                            writer.rawWrite(\" \");\n                            numberOfSingleSpacesToEmit--;\n                        }\n                    }\n                    else {\n                        // No spaces to emit write empty string\n                        writer.rawWrite(\"\");\n                    }\n                }\n                // Write the comment line text\n                writeTrimmedCurrentLine(pos, nextLineStart);\n                pos = nextLineStart;\n            }\n        }\n        else {\n            // Single line comment of style //....\n            writer.write(currentSourceFile.text.substring(comment.pos, comment.end));\n        }\n        function writeTrimmedCurrentLine(pos, nextLineStart) {\n            var end = Math.min(comment.end, nextLineStart - 1);\n            var currentLineText = currentSourceFile.text.substring(pos, end).replace(/^\\s+|\\s+$/g, '');\n            if (currentLineText) {\n                // trimmed forward and ending spaces text\n                writer.write(currentLineText);\n                if (end !== comment.end) {\n                    writer.writeLine();\n                }\n            }\n            else {\n                // Empty string - make sure we write empty line\n                writer.writeLiteral(newLine);\n            }\n        }\n        function calculateIndent(pos, end) {\n            var currentLineIndent = 0;\n            for (; pos < end && ts.isWhiteSpace(currentSourceFile.text.charCodeAt(pos)); pos++) {\n                if (currentSourceFile.text.charCodeAt(pos) === 9 /* tab */) {\n                    // Tabs = TabSize = indent size and go to next tabStop\n                    currentLineIndent += getIndentSize() - (currentLineIndent % getIndentSize());\n                }\n                else {\n                    // Single space\n                    currentLineIndent++;\n                }\n            }\n            return currentLineIndent;\n        }\n    }\n    function getFirstConstructorWithBody(node) {\n        return ts.forEach(node.members, function (member) {\n            if (member.kind === 126 /* Constructor */ && member.body) {\n                return member;\n            }\n        });\n    }\n    function getAllAccessorDeclarations(node, accessor) {\n        var firstAccessor;\n        var getAccessor;\n        var setAccessor;\n        if (accessor.name.kind === 121 /* ComputedPropertyName */) {\n            firstAccessor = accessor;\n            if (accessor.kind === 127 /* GetAccessor */) {\n                getAccessor = accessor;\n            }\n            else if (accessor.kind === 128 /* SetAccessor */) {\n                setAccessor = accessor;\n            }\n            else {\n                ts.Debug.fail(\"Accessor has wrong kind\");\n            }\n        }\n        else {\n            ts.forEach(node.members, function (member) {\n                if ((member.kind === 127 /* GetAccessor */ || member.kind === 128 /* SetAccessor */) && member.name.text === accessor.name.text && (member.flags & 128 /* Static */) === (accessor.flags & 128 /* Static */)) {\n                    if (!firstAccessor) {\n                        firstAccessor = member;\n                    }\n                    if (member.kind === 127 /* GetAccessor */ && !getAccessor) {\n                        getAccessor = member;\n                    }\n                    if (member.kind === 128 /* SetAccessor */ && !setAccessor) {\n                        setAccessor = member;\n                    }\n                }\n            });\n        }\n        return {\n            firstAccessor: firstAccessor,\n            getAccessor: getAccessor,\n            setAccessor: setAccessor\n        };\n    }\n    function getSourceFilePathInNewDir(sourceFile, program, newDirPath) {\n        var compilerHost = program.getCompilerHost();\n        var sourceFilePath = ts.getNormalizedAbsolutePath(sourceFile.filename, compilerHost.getCurrentDirectory());\n        sourceFilePath = sourceFilePath.replace(program.getCommonSourceDirectory(), \"\");\n        return ts.combinePaths(newDirPath, sourceFilePath);\n    }\n    function getOwnEmitOutputFilePath(sourceFile, program, extension) {\n        var compilerOptions = program.getCompilerOptions();\n        if (compilerOptions.outDir) {\n            var emitOutputFilePathWithoutExtension = ts.removeFileExtension(getSourceFilePathInNewDir(sourceFile, program, compilerOptions.outDir));\n        }\n        else {\n            var emitOutputFilePathWithoutExtension = ts.removeFileExtension(sourceFile.filename);\n        }\n        return emitOutputFilePathWithoutExtension + extension;\n    }\n    function writeFile(compilerHost, diagnostics, filename, data, writeByteOrderMark) {\n        compilerHost.writeFile(filename, data, writeByteOrderMark, function (hostErrorMessage) {\n            diagnostics.push(ts.createCompilerDiagnostic(ts.Diagnostics.Could_not_write_file_0_Colon_1, filename, hostErrorMessage));\n        });\n    }\n    function emitDeclarations(program, resolver, diagnostics, jsFilePath, root) {\n        var newLine = program.getCompilerHost().getNewLine();\n        var compilerOptions = program.getCompilerOptions();\n        var compilerHost = program.getCompilerHost();\n        var write;\n        var writeLine;\n        var increaseIndent;\n        var decreaseIndent;\n        var writeTextOfNode;\n        var writer = createAndSetNewTextWriterWithSymbolWriter();\n        var enclosingDeclaration;\n        var currentSourceFile;\n        var reportedDeclarationError = false;\n        var emitJsDocComments = compilerOptions.removeComments ? function (declaration) {\n        } : writeJsDocComments;\n        var aliasDeclarationEmitInfo = [];\n        function createAndSetNewTextWriterWithSymbolWriter() {\n            var writer = createTextWriter(newLine);\n            writer.trackSymbol = trackSymbol;\n            writer.writeKeyword = writer.write;\n            writer.writeOperator = writer.write;\n            writer.writePunctuation = writer.write;\n            writer.writeSpace = writer.write;\n            writer.writeStringLiteral = writer.writeLiteral;\n            writer.writeParameter = writer.write;\n            writer.writeSymbol = writer.write;\n            setWriter(writer);\n            return writer;\n        }\n        function setWriter(newWriter) {\n            writer = newWriter;\n            write = newWriter.write;\n            writeTextOfNode = newWriter.writeTextOfNode;\n            writeLine = newWriter.writeLine;\n            increaseIndent = newWriter.increaseIndent;\n            decreaseIndent = newWriter.decreaseIndent;\n        }\n        function writeAsychronousImportDeclarations(importDeclarations) {\n            var oldWriter = writer;\n            ts.forEach(importDeclarations, function (aliasToWrite) {\n                var aliasEmitInfo = ts.forEach(aliasDeclarationEmitInfo, function (declEmitInfo) { return declEmitInfo.declaration === aliasToWrite ? declEmitInfo : undefined; });\n                // If the alias was marked as not visible when we saw its declaration, we would have saved the aliasEmitInfo, but if we haven't yet visited the alias declaration\n                // then we don't need to write it at this point. We will write it when we actually see its declaration\n                // Eg.\n                // export function bar(a: foo.Foo) { }\n                // import foo = require(\"foo\");\n                // Writing of function bar would mark alias declaration foo as visible but we haven't yet visited that declaration so do nothing, \n                // we would write alias foo declaration when we visit it since it would now be marked as visible\n                if (aliasEmitInfo) {\n                    createAndSetNewTextWriterWithSymbolWriter();\n                    for (var declarationIndent = aliasEmitInfo.indent; declarationIndent; declarationIndent--) {\n                        increaseIndent();\n                    }\n                    writeImportDeclaration(aliasToWrite);\n                    aliasEmitInfo.asynchronousOutput = writer.getText();\n                }\n            });\n            setWriter(oldWriter);\n        }\n        function handleSymbolAccessibilityError(symbolAccesibilityResult) {\n            if (symbolAccesibilityResult.accessibility === 0 /* Accessible */) {\n                // write the aliases\n                if (symbolAccesibilityResult && symbolAccesibilityResult.aliasesToMakeVisible) {\n                    writeAsychronousImportDeclarations(symbolAccesibilityResult.aliasesToMakeVisible);\n                }\n            }\n            else {\n                // Report error\n                reportedDeclarationError = true;\n                var errorInfo = writer.getSymbolAccessibilityDiagnostic(symbolAccesibilityResult);\n                if (errorInfo) {\n                    if (errorInfo.typeName) {\n                        diagnostics.push(ts.createDiagnosticForNode(symbolAccesibilityResult.errorNode || errorInfo.errorNode, errorInfo.diagnosticMessage, ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, errorInfo.typeName), symbolAccesibilityResult.errorSymbolName, symbolAccesibilityResult.errorModuleName));\n                    }\n                    else {\n                        diagnostics.push(ts.createDiagnosticForNode(symbolAccesibilityResult.errorNode || errorInfo.errorNode, errorInfo.diagnosticMessage, symbolAccesibilityResult.errorSymbolName, symbolAccesibilityResult.errorModuleName));\n                    }\n                }\n            }\n        }\n        function trackSymbol(symbol, enclosingDeclaration, meaning) {\n            handleSymbolAccessibilityError(resolver.isSymbolAccessible(symbol, enclosingDeclaration, meaning));\n        }\n        function writeTypeOfDeclaration(declaration, type, getSymbolAccessibilityDiagnostic) {\n            writer.getSymbolAccessibilityDiagnostic = getSymbolAccessibilityDiagnostic;\n            write(\": \");\n            if (type) {\n                // Write the type\n                emitType(type);\n            }\n            else {\n                resolver.writeTypeOfDeclaration(declaration, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);\n            }\n        }\n        function writeReturnTypeAtSignature(signature, getSymbolAccessibilityDiagnostic) {\n            writer.getSymbolAccessibilityDiagnostic = getSymbolAccessibilityDiagnostic;\n            write(\": \");\n            if (signature.type) {\n                // Write the type\n                emitType(signature.type);\n            }\n            else {\n                resolver.writeReturnTypeOfSignatureDeclaration(signature, enclosingDeclaration, 2 /* UseTypeOfFunction */, writer);\n            }\n        }\n        function emitLines(nodes) {\n            for (var i = 0, n = nodes.length; i < n; i++) {\n                emitNode(nodes[i]);\n            }\n        }\n        function emitSeparatedList(nodes, separator, eachNodeEmitFn) {\n            var currentWriterPos = writer.getTextPos();\n            for (var i = 0, n = nodes.length; i < n; i++) {\n                if (currentWriterPos !== writer.getTextPos()) {\n                    write(separator);\n                }\n                currentWriterPos = writer.getTextPos();\n                eachNodeEmitFn(nodes[i]);\n            }\n        }\n        function emitCommaList(nodes, eachNodeEmitFn) {\n            emitSeparatedList(nodes, \", \", eachNodeEmitFn);\n        }\n        function writeJsDocComments(declaration) {\n            if (declaration) {\n                var jsDocComments = ts.getJsDocComments(declaration, currentSourceFile);\n                emitNewLineBeforeLeadingComments(currentSourceFile, writer, declaration, jsDocComments);\n                // jsDoc comments are emitted at /*leading comment1 */space/*leading comment*/space\n                emitComments(currentSourceFile, writer, jsDocComments, true, newLine, writeCommentRange);\n            }\n        }\n        function emitTypeWithNewGetSymbolAccessibilityDiagnostic(type, getSymbolAccessibilityDiagnostic) {\n            writer.getSymbolAccessibilityDiagnostic = getSymbolAccessibilityDiagnostic;\n            emitType(type);\n        }\n        function emitType(type) {\n            switch (type.kind) {\n                case 109 /* AnyKeyword */:\n                case 118 /* StringKeyword */:\n                case 116 /* NumberKeyword */:\n                case 110 /* BooleanKeyword */:\n                case 97 /* VoidKeyword */:\n                case 7 /* StringLiteral */:\n                    return writeTextOfNode(currentSourceFile, type);\n                case 132 /* TypeReference */:\n                    return emitTypeReference(type);\n                case 135 /* TypeQuery */:\n                    return emitTypeQuery(type);\n                case 137 /* ArrayType */:\n                    return emitArrayType(type);\n                case 138 /* TupleType */:\n                    return emitTupleType(type);\n                case 139 /* UnionType */:\n                    return emitUnionType(type);\n                case 140 /* ParenthesizedType */:\n                    return emitParenType(type);\n                case 133 /* FunctionType */:\n                case 134 /* ConstructorType */:\n                    return emitSignatureDeclarationWithJsDocComments(type);\n                case 136 /* TypeLiteral */:\n                    return emitTypeLiteral(type);\n                case 63 /* Identifier */:\n                    return emitEntityName(type);\n                case 120 /* QualifiedName */:\n                    return emitEntityName(type);\n                default:\n                    ts.Debug.fail(\"Unknown type annotation: \" + type.kind);\n            }\n            function emitEntityName(entityName) {\n                var visibilityResult = resolver.isEntityNameVisible(entityName, entityName.parent.kind === 191 /* ImportDeclaration */ ? entityName.parent : enclosingDeclaration);\n                handleSymbolAccessibilityError(visibilityResult);\n                writeEntityName(entityName);\n                function writeEntityName(entityName) {\n                    if (entityName.kind === 63 /* Identifier */) {\n                        writeTextOfNode(currentSourceFile, entityName);\n                    }\n                    else {\n                        var qualifiedName = entityName;\n                        writeEntityName(qualifiedName.left);\n                        write(\".\");\n                        writeTextOfNode(currentSourceFile, qualifiedName.right);\n                    }\n                }\n            }\n            function emitTypeReference(type) {\n                emitEntityName(type.typeName);\n                if (type.typeArguments) {\n                    write(\"<\");\n                    emitCommaList(type.typeArguments, emitType);\n                    write(\">\");\n                }\n            }\n            function emitTypeQuery(type) {\n                write(\"typeof \");\n                emitEntityName(type.exprName);\n            }\n            function emitArrayType(type) {\n                emitType(type.elementType);\n                write(\"[]\");\n            }\n            function emitTupleType(type) {\n                write(\"[\");\n                emitCommaList(type.elementTypes, emitType);\n                write(\"]\");\n            }\n            function emitUnionType(type) {\n                emitSeparatedList(type.types, \" | \", emitType);\n            }\n            function emitParenType(type) {\n                write(\"(\");\n                emitType(type.type);\n                write(\")\");\n            }\n            function emitTypeLiteral(type) {\n                write(\"{\");\n                if (type.members.length) {\n                    writeLine();\n                    increaseIndent();\n                    // write members\n                    emitLines(type.members);\n                    decreaseIndent();\n                }\n                write(\"}\");\n            }\n        }\n        function emitSourceFile(node) {\n            currentSourceFile = node;\n            enclosingDeclaration = node;\n            emitLines(node.statements);\n        }\n        function emitExportAssignment(node) {\n            write(\"export = \");\n            writeTextOfNode(currentSourceFile, node.exportName);\n            write(\";\");\n            writeLine();\n        }\n        function emitModuleElementDeclarationFlags(node) {\n            // If the node is parented in the current source file we need to emit export declare or just export\n            if (node.parent === currentSourceFile) {\n                // If the node is exported \n                if (node.flags & 1 /* Export */) {\n                    write(\"export \");\n                }\n                if (node.kind !== 186 /* InterfaceDeclaration */) {\n                    write(\"declare \");\n                }\n            }\n        }\n        function emitClassMemberDeclarationFlags(node) {\n            if (node.flags & 32 /* Private */) {\n                write(\"private \");\n            }\n            else if (node.flags & 64 /* Protected */) {\n                write(\"protected \");\n            }\n            if (node.flags & 128 /* Static */) {\n                write(\"static \");\n            }\n        }\n        function emitImportDeclaration(node) {\n            var nodeEmitInfo = {\n                declaration: node,\n                outputPos: writer.getTextPos(),\n                indent: writer.getIndent(),\n                hasWritten: resolver.isDeclarationVisible(node)\n            };\n            aliasDeclarationEmitInfo.push(nodeEmitInfo);\n            if (nodeEmitInfo.hasWritten) {\n                writeImportDeclaration(node);\n            }\n        }\n        function writeImportDeclaration(node) {\n            // note usage of writer. methods instead of aliases created, just to make sure we are using \n            // correct writer especially to handle asynchronous alias writing\n            emitJsDocComments(node);\n            if (node.flags & 1 /* Export */) {\n                write(\"export \");\n            }\n            write(\"import \");\n            writeTextOfNode(currentSourceFile, node.name);\n            write(\" = \");\n            if (ts.isInternalModuleImportDeclaration(node)) {\n                emitTypeWithNewGetSymbolAccessibilityDiagnostic(node.moduleReference, getImportEntityNameVisibilityError);\n                write(\";\");\n            }\n            else {\n                write(\"require(\");\n                writeTextOfNode(currentSourceFile, ts.getExternalModuleImportDeclarationExpression(node));\n                write(\");\");\n            }\n            writer.writeLine();\n            function getImportEntityNameVisibilityError(symbolAccesibilityResult) {\n                return {\n                    diagnosticMessage: ts.Diagnostics.Import_declaration_0_is_using_private_name_1,\n                    errorNode: node,\n                    typeName: node.name\n                };\n            }\n        }\n        function emitModuleDeclaration(node) {\n            if (resolver.isDeclarationVisible(node)) {\n                emitJsDocComments(node);\n                emitModuleElementDeclarationFlags(node);\n                write(\"module \");\n                writeTextOfNode(currentSourceFile, node.name);\n                while (node.body.kind !== 190 /* ModuleBlock */) {\n                    node = node.body;\n                    write(\".\");\n                    writeTextOfNode(currentSourceFile, node.name);\n                }\n                var prevEnclosingDeclaration = enclosingDeclaration;\n                enclosingDeclaration = node;\n                write(\" {\");\n                writeLine();\n                increaseIndent();\n                emitLines(node.body.statements);\n                decreaseIndent();\n                write(\"}\");\n                writeLine();\n                enclosingDeclaration = prevEnclosingDeclaration;\n            }\n        }\n        function emitTypeAliasDeclaration(node) {\n            if (resolver.isDeclarationVisible(node)) {\n                emitJsDocComments(node);\n                emitModuleElementDeclarationFlags(node);\n                write(\"type \");\n                writeTextOfNode(currentSourceFile, node.name);\n                write(\" = \");\n                emitTypeWithNewGetSymbolAccessibilityDiagnostic(node.type, getTypeAliasDeclarationVisibilityError);\n                write(\";\");\n                writeLine();\n            }\n            function getTypeAliasDeclarationVisibilityError(symbolAccesibilityResult) {\n                return {\n                    diagnosticMessage: ts.Diagnostics.Exported_type_alias_0_has_or_is_using_private_name_1,\n                    errorNode: node.type,\n                    typeName: node.name\n                };\n            }\n        }\n        function emitEnumDeclaration(node) {\n            if (resolver.isDeclarationVisible(node)) {\n                emitJsDocComments(node);\n                emitModuleElementDeclarationFlags(node);\n                if (ts.isConst(node)) {\n                    write(\"const \");\n                }\n                write(\"enum \");\n                writeTextOfNode(currentSourceFile, node.name);\n                write(\" {\");\n                writeLine();\n                increaseIndent();\n                emitLines(node.members);\n                decreaseIndent();\n                write(\"}\");\n                writeLine();\n            }\n        }\n        function emitEnumMemberDeclaration(node) {\n            emitJsDocComments(node);\n            writeTextOfNode(currentSourceFile, node.name);\n            var enumMemberValue = resolver.getEnumMemberValue(node);\n            if (enumMemberValue !== undefined) {\n                write(\" = \");\n                write(enumMemberValue.toString());\n            }\n            write(\",\");\n            writeLine();\n        }\n        function emitTypeParameters(typeParameters) {\n            function emitTypeParameter(node) {\n                increaseIndent();\n                emitJsDocComments(node);\n                decreaseIndent();\n                writeTextOfNode(currentSourceFile, node.name);\n                // If there is constraint present and this is not a type parameter of the private method emit the constraint\n                if (node.constraint && (node.parent.kind !== 125 /* Method */ || !(node.parent.flags & 32 /* Private */))) {\n                    write(\" extends \");\n                    if (node.parent.kind === 133 /* FunctionType */ || node.parent.kind === 134 /* ConstructorType */ || (node.parent.parent && node.parent.parent.kind === 136 /* TypeLiteral */)) {\n                        ts.Debug.assert(node.parent.kind === 125 /* Method */ || node.parent.kind === 133 /* FunctionType */ || node.parent.kind === 134 /* ConstructorType */ || node.parent.kind === 129 /* CallSignature */ || node.parent.kind === 130 /* ConstructSignature */);\n                        emitType(node.constraint);\n                    }\n                    else {\n                        emitTypeWithNewGetSymbolAccessibilityDiagnostic(node.constraint, getTypeParameterConstraintVisibilityError);\n                    }\n                }\n                function getTypeParameterConstraintVisibilityError(symbolAccesibilityResult) {\n                    // Type parameter constraints are named by user so we should always be able to name it\n                    var diagnosticMessage;\n                    switch (node.parent.kind) {\n                        case 185 /* ClassDeclaration */:\n                            diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_private_name_1;\n                            break;\n                        case 186 /* InterfaceDeclaration */:\n                            diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1;\n                            break;\n                        case 130 /* ConstructSignature */:\n                            diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;\n                            break;\n                        case 129 /* CallSignature */:\n                            diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;\n                            break;\n                        case 125 /* Method */:\n                            if (node.parent.flags & 128 /* Static */) {\n                                diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;\n                            }\n                            else if (node.parent.parent.kind === 185 /* ClassDeclaration */) {\n                                diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;\n                            }\n                            else {\n                                diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;\n                            }\n                            break;\n                        case 184 /* FunctionDeclaration */:\n                            diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_private_name_1;\n                            break;\n                        default:\n                            ts.Debug.fail(\"This is unknown parent for type parameter: \" + node.parent.kind);\n                    }\n                    return {\n                        diagnosticMessage: diagnosticMessage,\n                        errorNode: node,\n                        typeName: node.name\n                    };\n                }\n            }\n            if (typeParameters) {\n                write(\"<\");\n                emitCommaList(typeParameters, emitTypeParameter);\n                write(\">\");\n            }\n        }\n        function emitHeritageClause(typeReferences, isImplementsList) {\n            if (typeReferences) {\n                write(isImplementsList ? \" implements \" : \" extends \");\n                emitCommaList(typeReferences, emitTypeOfTypeReference);\n            }\n            function emitTypeOfTypeReference(node) {\n                emitTypeWithNewGetSymbolAccessibilityDiagnostic(node, getHeritageClauseVisibilityError);\n                function getHeritageClauseVisibilityError(symbolAccesibilityResult) {\n                    var diagnosticMessage;\n                    // Heritage clause is written by user so it can always be named\n                    if (node.parent.parent.kind === 185 /* ClassDeclaration */) {\n                        // Class or Interface implemented/extended is inaccessible\n                        diagnosticMessage = isImplementsList ? ts.Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_private_name_1 : ts.Diagnostics.Extends_clause_of_exported_class_0_has_or_is_using_private_name_1;\n                    }\n                    else {\n                        // interface is inaccessible\n                        diagnosticMessage = ts.Diagnostics.Extends_clause_of_exported_interface_0_has_or_is_using_private_name_1;\n                    }\n                    return {\n                        diagnosticMessage: diagnosticMessage,\n                        errorNode: node,\n                        typeName: node.parent.parent.name\n                    };\n                }\n            }\n        }\n        function emitClassDeclaration(node) {\n            function emitParameterProperties(constructorDeclaration) {\n                if (constructorDeclaration) {\n                    ts.forEach(constructorDeclaration.parameters, function (param) {\n                        if (param.flags & 112 /* AccessibilityModifier */) {\n                            emitPropertyDeclaration(param);\n                        }\n                    });\n                }\n            }\n            if (resolver.isDeclarationVisible(node)) {\n                emitJsDocComments(node);\n                emitModuleElementDeclarationFlags(node);\n                write(\"class \");\n                writeTextOfNode(currentSourceFile, node.name);\n                var prevEnclosingDeclaration = enclosingDeclaration;\n                enclosingDeclaration = node;\n                emitTypeParameters(node.typeParameters);\n                var baseTypeNode = ts.getClassBaseTypeNode(node);\n                if (baseTypeNode) {\n                    emitHeritageClause([baseTypeNode], false);\n                }\n                emitHeritageClause(ts.getClassImplementedTypeNodes(node), true);\n                write(\" {\");\n                writeLine();\n                increaseIndent();\n                emitParameterProperties(getFirstConstructorWithBody(node));\n                emitLines(node.members);\n                decreaseIndent();\n                write(\"}\");\n                writeLine();\n                enclosingDeclaration = prevEnclosingDeclaration;\n            }\n        }\n        function emitInterfaceDeclaration(node) {\n            if (resolver.isDeclarationVisible(node)) {\n                emitJsDocComments(node);\n                emitModuleElementDeclarationFlags(node);\n                write(\"interface \");\n                writeTextOfNode(currentSourceFile, node.name);\n                var prevEnclosingDeclaration = enclosingDeclaration;\n                enclosingDeclaration = node;\n                emitTypeParameters(node.typeParameters);\n                emitHeritageClause(ts.getInterfaceBaseTypeNodes(node), false);\n                write(\" {\");\n                writeLine();\n                increaseIndent();\n                emitLines(node.members);\n                decreaseIndent();\n                write(\"}\");\n                writeLine();\n                enclosingDeclaration = prevEnclosingDeclaration;\n            }\n        }\n        function emitPropertyDeclaration(node) {\n            emitJsDocComments(node);\n            emitClassMemberDeclarationFlags(node);\n            emitVariableDeclaration(node);\n            write(\";\");\n            writeLine();\n        }\n        // TODO(jfreeman): Factor out common part of property definition, but treat name differently\n        function emitVariableDeclaration(node) {\n            // If we are emitting property it isn't moduleElement and hence we already know it needs to be emitted\n            // so there is no check needed to see if declaration is visible\n            if (node.kind !== 183 /* VariableDeclaration */ || resolver.isDeclarationVisible(node)) {\n                writeTextOfNode(currentSourceFile, node.name);\n                // If optional property emit ?\n                if (node.kind === 124 /* Property */ && ts.hasQuestionToken(node)) {\n                    write(\"?\");\n                }\n                if (node.kind === 124 /* Property */ && node.parent.kind === 136 /* TypeLiteral */) {\n                    emitTypeOfVariableDeclarationFromTypeLiteral(node);\n                }\n                else if (!(node.flags & 32 /* Private */)) {\n                    writeTypeOfDeclaration(node, node.type, getVariableDeclarationTypeVisibilityError);\n                }\n            }\n            function getVariableDeclarationTypeVisibilityError(symbolAccesibilityResult) {\n                var diagnosticMessage;\n                if (node.kind === 183 /* VariableDeclaration */) {\n                    diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Exported_variable_0_has_or_is_using_private_name_1;\n                }\n                else if (node.kind === 124 /* Property */) {\n                    // TODO(jfreeman): Deal with computed properties in error reporting.\n                    if (node.flags & 128 /* Static */) {\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_private_name_1;\n                    }\n                    else if (node.parent.kind === 185 /* ClassDeclaration */) {\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_private_name_1;\n                    }\n                    else {\n                        // Interfaces cannot have types that cannot be named\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_private_name_1;\n                    }\n                }\n                return diagnosticMessage !== undefined ? {\n                    diagnosticMessage: diagnosticMessage,\n                    errorNode: node,\n                    typeName: node.name\n                } : undefined;\n            }\n        }\n        function emitTypeOfVariableDeclarationFromTypeLiteral(node) {\n            // if this is property of type literal, \n            // or is parameter of method/call/construct/index signature of type literal\n            // emit only if type is specified\n            if (node.type) {\n                write(\": \");\n                emitType(node.type);\n            }\n        }\n        function emitVariableStatement(node) {\n            var hasDeclarationWithEmit = ts.forEach(node.declarations, function (varDeclaration) { return resolver.isDeclarationVisible(varDeclaration); });\n            if (hasDeclarationWithEmit) {\n                emitJsDocComments(node);\n                emitModuleElementDeclarationFlags(node);\n                if (ts.isLet(node)) {\n                    write(\"let \");\n                }\n                else if (ts.isConst(node)) {\n                    write(\"const \");\n                }\n                else {\n                    write(\"var \");\n                }\n                emitCommaList(node.declarations, emitVariableDeclaration);\n                write(\";\");\n                writeLine();\n            }\n        }\n        function emitAccessorDeclaration(node) {\n            var accessors = getAllAccessorDeclarations(node.parent, node);\n            if (node === accessors.firstAccessor) {\n                emitJsDocComments(accessors.getAccessor);\n                emitJsDocComments(accessors.setAccessor);\n                emitClassMemberDeclarationFlags(node);\n                writeTextOfNode(currentSourceFile, node.name);\n                if (!(node.flags & 32 /* Private */)) {\n                    var accessorWithTypeAnnotation = node;\n                    var type = getTypeAnnotationFromAccessor(node);\n                    if (!type) {\n                        // couldn't get type for the first accessor, try the another one\n                        var anotherAccessor = node.kind === 127 /* GetAccessor */ ? accessors.setAccessor : accessors.getAccessor;\n                        type = getTypeAnnotationFromAccessor(anotherAccessor);\n                        if (type) {\n                            accessorWithTypeAnnotation = anotherAccessor;\n                        }\n                    }\n                    writeTypeOfDeclaration(node, type, getAccessorDeclarationTypeVisibilityError);\n                }\n                write(\";\");\n                writeLine();\n            }\n            function getTypeAnnotationFromAccessor(accessor) {\n                if (accessor) {\n                    return accessor.kind === 127 /* GetAccessor */ ? accessor.type : accessor.parameters[0].type; // Setter parameter type\n                }\n            }\n            function getAccessorDeclarationTypeVisibilityError(symbolAccesibilityResult) {\n                var diagnosticMessage;\n                if (accessorWithTypeAnnotation.kind === 128 /* SetAccessor */) {\n                    // Setters have to have type named and cannot infer it so, the type should always be named\n                    if (accessorWithTypeAnnotation.parent.flags & 128 /* Static */) {\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_name_1;\n                    }\n                    else {\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_name_1;\n                    }\n                    return {\n                        diagnosticMessage: diagnosticMessage,\n                        errorNode: accessorWithTypeAnnotation.parameters[0],\n                        // TODO(jfreeman): Investigate why we are passing node.name instead of node.parameters[0].name\n                        typeName: accessorWithTypeAnnotation.name\n                    };\n                }\n                else {\n                    if (accessorWithTypeAnnotation.flags & 128 /* Static */) {\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_name_0;\n                    }\n                    else {\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_name_0;\n                    }\n                    return {\n                        diagnosticMessage: diagnosticMessage,\n                        errorNode: accessorWithTypeAnnotation.name,\n                        typeName: undefined\n                    };\n                }\n            }\n        }\n        function emitFunctionDeclaration(node) {\n            // If we are emitting Method/Constructor it isn't moduleElement and hence already determined to be emitting\n            // so no need to verify if the declaration is visible\n            if ((node.kind !== 184 /* FunctionDeclaration */ || resolver.isDeclarationVisible(node)) && !resolver.isImplementationOfOverload(node)) {\n                emitJsDocComments(node);\n                if (node.kind === 184 /* FunctionDeclaration */) {\n                    emitModuleElementDeclarationFlags(node);\n                }\n                else if (node.kind === 125 /* Method */) {\n                    emitClassMemberDeclarationFlags(node);\n                }\n                if (node.kind === 184 /* FunctionDeclaration */) {\n                    write(\"function \");\n                    writeTextOfNode(currentSourceFile, node.name);\n                }\n                else if (node.kind === 126 /* Constructor */) {\n                    write(\"constructor\");\n                }\n                else {\n                    writeTextOfNode(currentSourceFile, node.name);\n                    if (ts.hasQuestionToken(node)) {\n                        write(\"?\");\n                    }\n                }\n                emitSignatureDeclaration(node);\n            }\n        }\n        function emitSignatureDeclarationWithJsDocComments(node) {\n            emitJsDocComments(node);\n            emitSignatureDeclaration(node);\n        }\n        function emitSignatureDeclaration(node) {\n            // Construct signature or constructor type write new Signature\n            if (node.kind === 130 /* ConstructSignature */ || node.kind === 134 /* ConstructorType */) {\n                write(\"new \");\n            }\n            emitTypeParameters(node.typeParameters);\n            if (node.kind === 131 /* IndexSignature */) {\n                write(\"[\");\n            }\n            else {\n                write(\"(\");\n            }\n            var prevEnclosingDeclaration = enclosingDeclaration;\n            enclosingDeclaration = node;\n            // Parameters\n            emitCommaList(node.parameters, emitParameterDeclaration);\n            if (node.kind === 131 /* IndexSignature */) {\n                write(\"]\");\n            }\n            else {\n                write(\")\");\n            }\n            // If this is not a constructor and is not private, emit the return type\n            var isFunctionTypeOrConstructorType = node.kind === 133 /* FunctionType */ || node.kind === 134 /* ConstructorType */;\n            if (isFunctionTypeOrConstructorType || node.parent.kind === 136 /* TypeLiteral */) {\n                // Emit type literal signature return type only if specified\n                if (node.type) {\n                    write(isFunctionTypeOrConstructorType ? \" => \" : \": \");\n                    emitType(node.type);\n                }\n            }\n            else if (node.kind !== 126 /* Constructor */ && !(node.flags & 32 /* Private */)) {\n                writeReturnTypeAtSignature(node, getReturnTypeVisibilityError);\n            }\n            enclosingDeclaration = prevEnclosingDeclaration;\n            if (!isFunctionTypeOrConstructorType) {\n                write(\";\");\n                writeLine();\n            }\n            function getReturnTypeVisibilityError(symbolAccesibilityResult) {\n                var diagnosticMessage;\n                switch (node.kind) {\n                    case 130 /* ConstructSignature */:\n                        // Interfaces cannot have return types that cannot be named\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0;\n                        break;\n                    case 129 /* CallSignature */:\n                        // Interfaces cannot have return types that cannot be named\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0;\n                        break;\n                    case 131 /* IndexSignature */:\n                        // Interfaces cannot have return types that cannot be named\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0;\n                        break;\n                    case 125 /* Method */:\n                        if (node.flags & 128 /* Static */) {\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0;\n                        }\n                        else if (node.parent.kind === 185 /* ClassDeclaration */) {\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0;\n                        }\n                        else {\n                            // Interfaces cannot have return types that cannot be named\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0;\n                        }\n                        break;\n                    case 184 /* FunctionDeclaration */:\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named : ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1 : ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_private_name_0;\n                        break;\n                    default:\n                        ts.Debug.fail(\"This is unknown kind for signature: \" + node.kind);\n                }\n                return {\n                    diagnosticMessage: diagnosticMessage,\n                    errorNode: node.name || node,\n                };\n            }\n        }\n        function emitParameterDeclaration(node) {\n            increaseIndent();\n            emitJsDocComments(node);\n            if (node.dotDotDotToken) {\n                write(\"...\");\n            }\n            writeTextOfNode(currentSourceFile, node.name);\n            if (node.initializer || ts.hasQuestionToken(node)) {\n                write(\"?\");\n            }\n            decreaseIndent();\n            if (node.parent.kind === 133 /* FunctionType */ || node.parent.kind === 134 /* ConstructorType */ || node.parent.parent.kind === 136 /* TypeLiteral */) {\n                emitTypeOfVariableDeclarationFromTypeLiteral(node);\n            }\n            else if (!(node.parent.flags & 32 /* Private */)) {\n                writeTypeOfDeclaration(node, node.type, getParameterDeclarationTypeVisibilityError);\n            }\n            function getParameterDeclarationTypeVisibilityError(symbolAccesibilityResult) {\n                var diagnosticMessage;\n                switch (node.parent.kind) {\n                    case 126 /* Constructor */:\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1;\n                        break;\n                    case 130 /* ConstructSignature */:\n                        // Interfaces cannot have parameter types that cannot be named\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;\n                        break;\n                    case 129 /* CallSignature */:\n                        // Interfaces cannot have parameter types that cannot be named\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;\n                        break;\n                    case 125 /* Method */:\n                        if (node.parent.flags & 128 /* Static */) {\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;\n                        }\n                        else if (node.parent.parent.kind === 185 /* ClassDeclaration */) {\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;\n                        }\n                        else {\n                            // Interfaces cannot have parameter types that cannot be named\n                            diagnosticMessage = symbolAccesibilityResult.errorModuleName ? ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;\n                        }\n                        break;\n                    case 184 /* FunctionDeclaration */:\n                        diagnosticMessage = symbolAccesibilityResult.errorModuleName ? symbolAccesibilityResult.accessibility === 2 /* CannotBeNamed */ ? ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named : ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 : ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_private_name_1;\n                        break;\n                    default:\n                        ts.Debug.fail(\"This is unknown parent for parameter: \" + node.parent.kind);\n                }\n                return {\n                    diagnosticMessage: diagnosticMessage,\n                    errorNode: node,\n                    typeName: node.name\n                };\n            }\n        }\n        function emitNode(node) {\n            switch (node.kind) {\n                case 126 /* Constructor */:\n                case 184 /* FunctionDeclaration */:\n                case 125 /* Method */:\n                    return emitFunctionDeclaration(node);\n                case 130 /* ConstructSignature */:\n                case 129 /* CallSignature */:\n                case 131 /* IndexSignature */:\n                    return emitSignatureDeclarationWithJsDocComments(node);\n                case 127 /* GetAccessor */:\n                case 128 /* SetAccessor */:\n                    return emitAccessorDeclaration(node);\n                case 164 /* VariableStatement */:\n                    return emitVariableStatement(node);\n                case 124 /* Property */:\n                    return emitPropertyDeclaration(node);\n                case 186 /* InterfaceDeclaration */:\n                    return emitInterfaceDeclaration(node);\n                case 185 /* ClassDeclaration */:\n                    return emitClassDeclaration(node);\n                case 187 /* TypeAliasDeclaration */:\n                    return emitTypeAliasDeclaration(node);\n                case 200 /* EnumMember */:\n                    return emitEnumMemberDeclaration(node);\n                case 188 /* EnumDeclaration */:\n                    return emitEnumDeclaration(node);\n                case 189 /* ModuleDeclaration */:\n                    return emitModuleDeclaration(node);\n                case 191 /* ImportDeclaration */:\n                    return emitImportDeclaration(node);\n                case 192 /* ExportAssignment */:\n                    return emitExportAssignment(node);\n                case 201 /* SourceFile */:\n                    return emitSourceFile(node);\n            }\n        }\n        // Contains the reference paths that needs to go in the declaration file. \n        // Collecting this separately because reference paths need to be first thing in the declaration file \n        // and we could be collecting these paths from multiple files into single one with --out option\n        var referencePathsOutput = \"\";\n        function writeReferencePath(referencedFile) {\n            var declFileName = referencedFile.flags & 1024 /* DeclarationFile */ ? referencedFile.filename : shouldEmitToOwnFile(referencedFile, compilerOptions) ? getOwnEmitOutputFilePath(referencedFile, program, \".d.ts\") : ts.removeFileExtension(compilerOptions.out) + \".d.ts\"; // Global out file\n            declFileName = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizeSlashes(jsFilePath)), declFileName, compilerHost.getCurrentDirectory(), compilerHost.getCanonicalFileName, false);\n            referencePathsOutput += \"/// <reference path=\\\"\" + declFileName + \"\\\" />\" + newLine;\n        }\n        if (root) {\n            // Emitting just a single file, so emit references in this file only\n            if (!compilerOptions.noResolve) {\n                var addedGlobalFileReference = false;\n                ts.forEach(root.referencedFiles, function (fileReference) {\n                    var referencedFile = ts.tryResolveScriptReference(program, root, fileReference);\n                    // All the references that are not going to be part of same file\n                    if (referencedFile && ((referencedFile.flags & 1024 /* DeclarationFile */) || shouldEmitToOwnFile(referencedFile, compilerOptions) || !addedGlobalFileReference)) {\n                        writeReferencePath(referencedFile);\n                        if (!isExternalModuleOrDeclarationFile(referencedFile)) {\n                            addedGlobalFileReference = true;\n                        }\n                    }\n                });\n            }\n            emitNode(root);\n        }\n        else {\n            // Emit references corresponding to this file\n            var emittedReferencedFiles = [];\n            ts.forEach(program.getSourceFiles(), function (sourceFile) {\n                if (!isExternalModuleOrDeclarationFile(sourceFile)) {\n                    // Check what references need to be added\n                    if (!compilerOptions.noResolve) {\n                        ts.forEach(sourceFile.referencedFiles, function (fileReference) {\n                            var referencedFile = ts.tryResolveScriptReference(program, sourceFile, fileReference);\n                            // If the reference file is a declaration file or an external module, emit that reference\n                            if (referencedFile && (isExternalModuleOrDeclarationFile(referencedFile) && !ts.contains(emittedReferencedFiles, referencedFile))) {\n                                writeReferencePath(referencedFile);\n                                emittedReferencedFiles.push(referencedFile);\n                            }\n                        });\n                    }\n                    emitNode(sourceFile);\n                }\n            });\n        }\n        return {\n            reportedDeclarationError: reportedDeclarationError,\n            aliasDeclarationEmitInfo: aliasDeclarationEmitInfo,\n            synchronousDeclarationOutput: writer.getText(),\n            referencePathsOutput: referencePathsOutput,\n        };\n    }\n    function getDeclarationDiagnostics(program, resolver, targetSourceFile) {\n        var diagnostics = [];\n        var jsFilePath = getOwnEmitOutputFilePath(targetSourceFile, program, \".js\");\n        emitDeclarations(program, resolver, diagnostics, jsFilePath, targetSourceFile);\n        return diagnostics;\n    }\n    ts.getDeclarationDiagnostics = getDeclarationDiagnostics;\n    // targetSourceFile is when users only want one file in entire project to be emitted. This is used in compilerOnSave feature\n    function emitFiles(resolver, targetSourceFile) {\n        var program = resolver.getProgram();\n        var compilerHost = program.getCompilerHost();\n        var compilerOptions = program.getCompilerOptions();\n        var sourceMapDataList = compilerOptions.sourceMap ? [] : undefined;\n        var diagnostics = [];\n        var newLine = program.getCompilerHost().getNewLine();\n        function emitJavaScript(jsFilePath, root) {\n            var writer = createTextWriter(newLine);\n            var write = writer.write;\n            var writeTextOfNode = writer.writeTextOfNode;\n            var writeLine = writer.writeLine;\n            var increaseIndent = writer.increaseIndent;\n            var decreaseIndent = writer.decreaseIndent;\n            var currentSourceFile;\n            var extendsEmitted = false;\n            /** write emitted output to disk*/\n            var writeEmittedFiles = writeJavaScriptFile;\n            /** Emit leading comments of the node */\n            var emitLeadingComments = compilerOptions.removeComments ? function (node) {\n            } : emitLeadingDeclarationComments;\n            /** Emit Trailing comments of the node */\n            var emitTrailingComments = compilerOptions.removeComments ? function (node) {\n            } : emitTrailingDeclarationComments;\n            var emitLeadingCommentsOfPosition = compilerOptions.removeComments ? function (pos) {\n            } : emitLeadingCommentsOfLocalPosition;\n            var detachedCommentsInfo;\n            /** Emit detached comments of the node */\n            var emitDetachedComments = compilerOptions.removeComments ? function (node) {\n            } : emitDetachedCommentsAtPosition;\n            /** Emits /// or pinned which is comment starting with /*! comments */\n            var emitPinnedOrTripleSlashComments = compilerOptions.removeComments ? function (node) {\n            } : emitPinnedOrTripleSlashCommentsOfNode;\n            var writeComment = writeCommentRange;\n            /** Emit a node */\n            var emit = emitNode;\n            /** Called just before starting emit of a node */\n            var emitStart = function (node) {\n            };\n            /** Called once the emit of the node is done */\n            var emitEnd = function (node) {\n            };\n            /** Emit the text for the given token that comes after startPos\n              * This by default writes the text provided with the given tokenKind\n              * but if optional emitFn callback is provided the text is emitted using the callback instead of default text\n              * @param tokenKind the kind of the token to search and emit\n              * @param startPos the position in the source to start searching for the token\n              * @param emitFn if given will be invoked to emit the text instead of actual token emit */\n            var emitToken = emitTokenText;\n            /** Called to before starting the lexical scopes as in function/class in the emitted code because of node\n              * @param scopeDeclaration node that starts the lexical scope\n              * @param scopeName Optional name of this scope instead of deducing one from the declaration node */\n            var scopeEmitStart = function (scopeDeclaration, scopeName) {\n            };\n            /** Called after coming out of the scope */\n            var scopeEmitEnd = function () {\n            };\n            /** Sourcemap data that will get encoded */\n            var sourceMapData;\n            function initializeEmitterWithSourceMaps() {\n                var sourceMapDir; // The directory in which sourcemap will be\n                // Current source map file and its index in the sources list\n                var sourceMapSourceIndex = -1;\n                // Names and its index map\n                var sourceMapNameIndexMap = {};\n                var sourceMapNameIndices = [];\n                function getSourceMapNameIndex() {\n                    return sourceMapNameIndices.length ? sourceMapNameIndices[sourceMapNameIndices.length - 1] : -1;\n                }\n                // Last recorded and encoded spans\n                var lastRecordedSourceMapSpan;\n                var lastEncodedSourceMapSpan = {\n                    emittedLine: 1,\n                    emittedColumn: 1,\n                    sourceLine: 1,\n                    sourceColumn: 1,\n                    sourceIndex: 0\n                };\n                var lastEncodedNameIndex = 0;\n                // Encoding for sourcemap span\n                function encodeLastRecordedSourceMapSpan() {\n                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan === lastEncodedSourceMapSpan) {\n                        return;\n                    }\n                    var prevEncodedEmittedColumn = lastEncodedSourceMapSpan.emittedColumn;\n                    // Line/Comma delimiters\n                    if (lastEncodedSourceMapSpan.emittedLine == lastRecordedSourceMapSpan.emittedLine) {\n                        // Emit comma to separate the entry\n                        if (sourceMapData.sourceMapMappings) {\n                            sourceMapData.sourceMapMappings += \",\";\n                        }\n                    }\n                    else {\n                        for (var encodedLine = lastEncodedSourceMapSpan.emittedLine; encodedLine < lastRecordedSourceMapSpan.emittedLine; encodedLine++) {\n                            sourceMapData.sourceMapMappings += \";\";\n                        }\n                        prevEncodedEmittedColumn = 1;\n                    }\n                    // 1. Relative Column 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.emittedColumn - prevEncodedEmittedColumn);\n                    // 2. Relative sourceIndex \n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceIndex - lastEncodedSourceMapSpan.sourceIndex);\n                    // 3. Relative sourceLine 0 based\n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceLine - lastEncodedSourceMapSpan.sourceLine);\n                    // 4. Relative sourceColumn 0 based \n                    sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.sourceColumn - lastEncodedSourceMapSpan.sourceColumn);\n                    // 5. Relative namePosition 0 based\n                    if (lastRecordedSourceMapSpan.nameIndex >= 0) {\n                        sourceMapData.sourceMapMappings += base64VLQFormatEncode(lastRecordedSourceMapSpan.nameIndex - lastEncodedNameIndex);\n                        lastEncodedNameIndex = lastRecordedSourceMapSpan.nameIndex;\n                    }\n                    lastEncodedSourceMapSpan = lastRecordedSourceMapSpan;\n                    sourceMapData.sourceMapDecodedMappings.push(lastEncodedSourceMapSpan);\n                    function base64VLQFormatEncode(inValue) {\n                        function base64FormatEncode(inValue) {\n                            if (inValue < 64) {\n                                return 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.charAt(inValue);\n                            }\n                            throw TypeError(inValue + \": not a 64 based value\");\n                        }\n                        // Add a new least significant bit that has the sign of the value.\n                        // if negative number the least significant bit that gets added to the number has value 1\n                        // else least significant bit value that gets added is 0\n                        // eg. -1 changes to binary : 01 [1] => 3\n                        //     +1 changes to binary : 01 [0] => 2\n                        if (inValue < 0) {\n                            inValue = ((-inValue) << 1) + 1;\n                        }\n                        else {\n                            inValue = inValue << 1;\n                        }\n                        // Encode 5 bits at a time starting from least significant bits\n                        var encodedStr = \"\";\n                        do {\n                            var currentDigit = inValue & 31; // 11111\n                            inValue = inValue >> 5;\n                            if (inValue > 0) {\n                                // There are still more digits to decode, set the msb (6th bit)\n                                currentDigit = currentDigit | 32;\n                            }\n                            encodedStr = encodedStr + base64FormatEncode(currentDigit);\n                        } while (inValue > 0);\n                        return encodedStr;\n                    }\n                }\n                function recordSourceMapSpan(pos) {\n                    var sourceLinePos = currentSourceFile.getLineAndCharacterFromPosition(pos);\n                    var emittedLine = writer.getLine();\n                    var emittedColumn = writer.getColumn();\n                    // If this location wasn't recorded or the location in source is going backwards, record the span\n                    if (!lastRecordedSourceMapSpan || lastRecordedSourceMapSpan.emittedLine != emittedLine || lastRecordedSourceMapSpan.emittedColumn != emittedColumn || (lastRecordedSourceMapSpan.sourceIndex === sourceMapSourceIndex && (lastRecordedSourceMapSpan.sourceLine > sourceLinePos.line || (lastRecordedSourceMapSpan.sourceLine === sourceLinePos.line && lastRecordedSourceMapSpan.sourceColumn > sourceLinePos.character)))) {\n                        // Encode the last recordedSpan before assigning new\n                        encodeLastRecordedSourceMapSpan();\n                        // New span\n                        lastRecordedSourceMapSpan = {\n                            emittedLine: emittedLine,\n                            emittedColumn: emittedColumn,\n                            sourceLine: sourceLinePos.line,\n                            sourceColumn: sourceLinePos.character,\n                            nameIndex: getSourceMapNameIndex(),\n                            sourceIndex: sourceMapSourceIndex\n                        };\n                    }\n                    else {\n                        // Take the new pos instead since there is no change in emittedLine and column since last location\n                        lastRecordedSourceMapSpan.sourceLine = sourceLinePos.line;\n                        lastRecordedSourceMapSpan.sourceColumn = sourceLinePos.character;\n                        lastRecordedSourceMapSpan.sourceIndex = sourceMapSourceIndex;\n                    }\n                }\n                function recordEmitNodeStartSpan(node) {\n                    // Get the token pos after skipping to the token (ignoring the leading trivia)\n                    recordSourceMapSpan(ts.skipTrivia(currentSourceFile.text, node.pos));\n                }\n                function recordEmitNodeEndSpan(node) {\n                    recordSourceMapSpan(node.end);\n                }\n                function writeTextWithSpanRecord(tokenKind, startPos, emitFn) {\n                    var tokenStartPos = ts.skipTrivia(currentSourceFile.text, startPos);\n                    recordSourceMapSpan(tokenStartPos);\n                    var tokenEndPos = emitTokenText(tokenKind, tokenStartPos, emitFn);\n                    recordSourceMapSpan(tokenEndPos);\n                    return tokenEndPos;\n                }\n                function recordNewSourceFileStart(node) {\n                    // Add the file to tsFilePaths\n                    // If sourceroot option: Use the relative path corresponding to the common directory path \n                    // otherwise source locations relative to map file location\n                    var sourcesDirectoryPath = compilerOptions.sourceRoot ? program.getCommonSourceDirectory() : sourceMapDir;\n                    sourceMapData.sourceMapSources.push(ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, node.filename, compilerHost.getCurrentDirectory(), compilerHost.getCanonicalFileName, true));\n                    sourceMapSourceIndex = sourceMapData.sourceMapSources.length - 1;\n                    // The one that can be used from program to get the actual source file\n                    sourceMapData.inputSourceFileNames.push(node.filename);\n                }\n                function recordScopeNameOfNode(node, scopeName) {\n                    function recordScopeNameIndex(scopeNameIndex) {\n                        sourceMapNameIndices.push(scopeNameIndex);\n                    }\n                    function recordScopeNameStart(scopeName) {\n                        var scopeNameIndex = -1;\n                        if (scopeName) {\n                            var parentIndex = getSourceMapNameIndex();\n                            if (parentIndex !== -1) {\n                                scopeName = sourceMapData.sourceMapNames[parentIndex] + \".\" + scopeName;\n                            }\n                            scopeNameIndex = ts.getProperty(sourceMapNameIndexMap, scopeName);\n                            if (scopeNameIndex === undefined) {\n                                scopeNameIndex = sourceMapData.sourceMapNames.length;\n                                sourceMapData.sourceMapNames.push(scopeName);\n                                sourceMapNameIndexMap[scopeName] = scopeNameIndex;\n                            }\n                        }\n                        recordScopeNameIndex(scopeNameIndex);\n                    }\n                    if (scopeName) {\n                        // The scope was already given a name  use it\n                        recordScopeNameStart(scopeName);\n                    }\n                    else if (node.kind === 184 /* FunctionDeclaration */ || node.kind === 150 /* FunctionExpression */ || node.kind === 125 /* Method */ || node.kind === 127 /* GetAccessor */ || node.kind === 128 /* SetAccessor */ || node.kind === 189 /* ModuleDeclaration */ || node.kind === 185 /* ClassDeclaration */ || node.kind === 188 /* EnumDeclaration */) {\n                        // Declaration and has associated name use it\n                        if (node.name) {\n                            // TODO(jfreeman): Ask shkamat about what this name should be for source maps\n                            scopeName = node.name.text;\n                        }\n                        recordScopeNameStart(scopeName);\n                    }\n                    else {\n                        // Block just use the name from upper level scope\n                        recordScopeNameIndex(getSourceMapNameIndex());\n                    }\n                }\n                function recordScopeNameEnd() {\n                    sourceMapNameIndices.pop();\n                }\n                ;\n                function writeCommentRangeWithMap(curentSourceFile, writer, comment, newLine) {\n                    recordSourceMapSpan(comment.pos);\n                    writeCommentRange(currentSourceFile, writer, comment, newLine);\n                    recordSourceMapSpan(comment.end);\n                }\n                function serializeSourceMapContents(version, file, sourceRoot, sources, names, mappings) {\n                    if (typeof JSON !== \"undefined\") {\n                        return JSON.stringify({\n                            version: version,\n                            file: file,\n                            sourceRoot: sourceRoot,\n                            sources: sources,\n                            names: names,\n                            mappings: mappings\n                        });\n                    }\n                    return \"{\\\"version\\\":\" + version + \",\\\"file\\\":\\\"\" + ts.escapeString(file) + \"\\\",\\\"sourceRoot\\\":\\\"\" + ts.escapeString(sourceRoot) + \"\\\",\\\"sources\\\":[\" + serializeStringArray(sources) + \"],\\\"names\\\":[\" + serializeStringArray(names) + \"],\\\"mappings\\\":\\\"\" + ts.escapeString(mappings) + \"\\\"}\";\n                    function serializeStringArray(list) {\n                        var output = \"\";\n                        for (var i = 0, n = list.length; i < n; i++) {\n                            if (i) {\n                                output += \",\";\n                            }\n                            output += \"\\\"\" + ts.escapeString(list[i]) + \"\\\"\";\n                        }\n                        return output;\n                    }\n                }\n                function writeJavaScriptAndSourceMapFile(emitOutput, writeByteOrderMark) {\n                    // Write source map file\n                    encodeLastRecordedSourceMapSpan();\n                    writeFile(compilerHost, diagnostics, sourceMapData.sourceMapFilePath, serializeSourceMapContents(3, sourceMapData.sourceMapFile, sourceMapData.sourceMapSourceRoot, sourceMapData.sourceMapSources, sourceMapData.sourceMapNames, sourceMapData.sourceMapMappings), false);\n                    sourceMapDataList.push(sourceMapData);\n                    // Write sourcemap url to the js file and write the js file\n                    writeJavaScriptFile(emitOutput + \"//# sourceMappingURL=\" + sourceMapData.jsSourceMappingURL, writeByteOrderMark);\n                }\n                // Initialize source map data\n                var sourceMapJsFile = ts.getBaseFilename(ts.normalizeSlashes(jsFilePath));\n                sourceMapData = {\n                    sourceMapFilePath: jsFilePath + \".map\",\n                    jsSourceMappingURL: sourceMapJsFile + \".map\",\n                    sourceMapFile: sourceMapJsFile,\n                    sourceMapSourceRoot: compilerOptions.sourceRoot || \"\",\n                    sourceMapSources: [],\n                    inputSourceFileNames: [],\n                    sourceMapNames: [],\n                    sourceMapMappings: \"\",\n                    sourceMapDecodedMappings: []\n                };\n                // Normalize source root and make sure it has trailing \"/\" so that it can be used to combine paths with the \n                // relative paths of the sources list in the sourcemap\n                sourceMapData.sourceMapSourceRoot = ts.normalizeSlashes(sourceMapData.sourceMapSourceRoot);\n                if (sourceMapData.sourceMapSourceRoot.length && sourceMapData.sourceMapSourceRoot.charCodeAt(sourceMapData.sourceMapSourceRoot.length - 1) !== 47 /* slash */) {\n                    sourceMapData.sourceMapSourceRoot += ts.directorySeparator;\n                }\n                if (compilerOptions.mapRoot) {\n                    sourceMapDir = ts.normalizeSlashes(compilerOptions.mapRoot);\n                    if (root) {\n                        // For modules or multiple emit files the mapRoot will have directory structure like the sources\n                        // So if src\\a.ts and src\\lib\\b.ts are compiled together user would be moving the maps into mapRoot\\a.js.map and mapRoot\\lib\\b.js.map\n                        sourceMapDir = ts.getDirectoryPath(getSourceFilePathInNewDir(root, program, sourceMapDir));\n                    }\n                    if (!ts.isRootedDiskPath(sourceMapDir) && !ts.isUrl(sourceMapDir)) {\n                        // The relative paths are relative to the common directory\n                        sourceMapDir = ts.combinePaths(program.getCommonSourceDirectory(), sourceMapDir);\n                        sourceMapData.jsSourceMappingURL = ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(jsFilePath)), ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL), compilerHost.getCurrentDirectory(), compilerHost.getCanonicalFileName, true);\n                    }\n                    else {\n                        sourceMapData.jsSourceMappingURL = ts.combinePaths(sourceMapDir, sourceMapData.jsSourceMappingURL);\n                    }\n                }\n                else {\n                    sourceMapDir = ts.getDirectoryPath(ts.normalizePath(jsFilePath));\n                }\n                function emitNodeWithMap(node) {\n                    if (node) {\n                        if (node.kind != 201 /* SourceFile */) {\n                            recordEmitNodeStartSpan(node);\n                            emitNode(node);\n                            recordEmitNodeEndSpan(node);\n                        }\n                        else {\n                            recordNewSourceFileStart(node);\n                            emitNode(node);\n                        }\n                    }\n                }\n                writeEmittedFiles = writeJavaScriptAndSourceMapFile;\n                emit = emitNodeWithMap;\n                emitStart = recordEmitNodeStartSpan;\n                emitEnd = recordEmitNodeEndSpan;\n                emitToken = writeTextWithSpanRecord;\n                scopeEmitStart = recordScopeNameOfNode;\n                scopeEmitEnd = recordScopeNameEnd;\n                writeComment = writeCommentRangeWithMap;\n            }\n            function writeJavaScriptFile(emitOutput, writeByteOrderMark) {\n                writeFile(compilerHost, diagnostics, jsFilePath, emitOutput, writeByteOrderMark);\n            }\n            function emitTokenText(tokenKind, startPos, emitFn) {\n                var tokenString = ts.tokenToString(tokenKind);\n                if (emitFn) {\n                    emitFn();\n                }\n                else {\n                    write(tokenString);\n                }\n                return startPos + tokenString.length;\n            }\n            function emitOptional(prefix, node) {\n                if (node) {\n                    write(prefix);\n                    emit(node);\n                }\n            }\n            function emitTrailingCommaIfPresent(nodeList, isMultiline) {\n                if (nodeList.hasTrailingComma) {\n                    write(\",\");\n                    if (isMultiline) {\n                        writeLine();\n                    }\n                }\n            }\n            function emitCommaList(nodes, includeTrailingComma, count) {\n                if (!(count >= 0)) {\n                    count = nodes.length;\n                }\n                if (nodes) {\n                    for (var i = 0; i < count; i++) {\n                        if (i) {\n                            write(\", \");\n                        }\n                        emit(nodes[i]);\n                    }\n                    if (includeTrailingComma) {\n                        emitTrailingCommaIfPresent(nodes, false);\n                    }\n                }\n            }\n            function emitMultiLineList(nodes, includeTrailingComma) {\n                if (nodes) {\n                    for (var i = 0; i < nodes.length; i++) {\n                        if (i) {\n                            write(\",\");\n                        }\n                        writeLine();\n                        emit(nodes[i]);\n                    }\n                    if (includeTrailingComma) {\n                        emitTrailingCommaIfPresent(nodes, true);\n                    }\n                }\n            }\n            function emitLines(nodes) {\n                emitLinesStartingAt(nodes, 0);\n            }\n            function emitLinesStartingAt(nodes, startIndex) {\n                for (var i = startIndex; i < nodes.length; i++) {\n                    writeLine();\n                    emit(nodes[i]);\n                }\n            }\n            function isBinaryOrOctalIntegerLiteral(text) {\n                if (text.length <= 0) {\n                    return false;\n                }\n                if (text.charCodeAt(1) === 66 /* B */ || text.charCodeAt(1) === 98 /* b */ || text.charCodeAt(1) === 79 /* O */ || text.charCodeAt(1) === 111 /* o */) {\n                    return true;\n                }\n                return false;\n            }\n            function emitLiteral(node) {\n                var text = getLiteralText();\n                if (compilerOptions.sourceMap && (node.kind === 7 /* StringLiteral */ || ts.isTemplateLiteralKind(node.kind))) {\n                    writer.writeLiteral(text);\n                }\n                else if (compilerOptions.target < 2 /* ES6 */ && node.kind === 6 /* NumericLiteral */ && isBinaryOrOctalIntegerLiteral(text)) {\n                    write(node.text);\n                }\n                else {\n                    write(text);\n                }\n                function getLiteralText() {\n                    if (compilerOptions.target < 2 /* ES6 */ && ts.isTemplateLiteralKind(node.kind)) {\n                        return getTemplateLiteralAsStringLiteral(node);\n                    }\n                    return ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);\n                }\n            }\n            function getTemplateLiteralAsStringLiteral(node) {\n                return '\"' + ts.escapeString(node.text) + '\"';\n            }\n            function emitTemplateExpression(node) {\n                // In ES6 mode and above, we can simply emit each portion of a template in order, but in\n                // ES3 & ES5 we must convert the template expression into a series of string concatenations.\n                if (compilerOptions.target >= 2 /* ES6 */) {\n                    ts.forEachChild(node, emit);\n                    return;\n                }\n                ts.Debug.assert(node.parent.kind !== 147 /* TaggedTemplateExpression */);\n                var emitOuterParens = ts.isExpression(node.parent) && templateNeedsParens(node, node.parent);\n                if (emitOuterParens) {\n                    write(\"(\");\n                }\n                emitLiteral(node.head);\n                ts.forEach(node.templateSpans, function (templateSpan) {\n                    // Check if the expression has operands and binds its operands less closely than binary '+'.\n                    // If it does, we need to wrap the expression in parentheses. Otherwise, something like\n                    //    `abc${ 1 << 2 }`\n                    // becomes\n                    //    \"abc\" + 1 << 2 + \"\"\n                    // which is really\n                    //    (\"abc\" + 1) << (2 + \"\")\n                    // rather than\n                    //    \"abc\" + (1 << 2) + \"\"\n                    var needsParens = templateSpan.expression.kind !== 149 /* ParenthesizedExpression */ && comparePrecedenceToBinaryPlus(templateSpan.expression) !== 1 /* GreaterThan */;\n                    write(\" + \");\n                    if (needsParens) {\n                        write(\"(\");\n                    }\n                    emit(templateSpan.expression);\n                    if (needsParens) {\n                        write(\")\");\n                    }\n                    // Only emit if the literal is non-empty.\n                    // The binary '+' operator is left-associative, so the first string concatenation\n                    // with the head will force the result up to this point to be a string.\n                    // Emitting a '+ \"\"' has no semantic effect for middles and tails.\n                    if (templateSpan.literal.text.length !== 0) {\n                        write(\" + \");\n                        emitLiteral(templateSpan.literal);\n                    }\n                });\n                if (emitOuterParens) {\n                    write(\")\");\n                }\n                function templateNeedsParens(template, parent) {\n                    switch (parent.kind) {\n                        case 145 /* CallExpression */:\n                        case 146 /* NewExpression */:\n                            return parent.expression === template;\n                        case 149 /* ParenthesizedExpression */:\n                            return false;\n                        case 147 /* TaggedTemplateExpression */:\n                            ts.Debug.fail(\"Path should be unreachable; tagged templates not supported pre-ES6.\");\n                        default:\n                            return comparePrecedenceToBinaryPlus(parent) !== -1 /* LessThan */;\n                    }\n                }\n                /**\n                 * Returns whether the expression has lesser, greater,\n                 * or equal precedence to the binary '+' operator\n                 */\n                function comparePrecedenceToBinaryPlus(expression) {\n                    // All binary expressions have lower precedence than '+' apart from '*', '/', and '%'.\n                    // All unary operators have a higher precedence apart from yield.\n                    // Arrow functions and conditionals have a lower precedence, \n                    // although we convert the former into regular function expressions in ES5 mode,\n                    // and in ES6 mode this function won't get called anyway.\n                    // \n                    // TODO (drosen): Note that we need to account for the upcoming 'yield' and\n                    //                spread ('...') unary operators that are anticipated for ES6.\n                    ts.Debug.assert(compilerOptions.target <= 1 /* ES5 */);\n                    switch (expression.kind) {\n                        case 157 /* BinaryExpression */:\n                            switch (expression.operator) {\n                                case 34 /* AsteriskToken */:\n                                case 35 /* SlashToken */:\n                                case 36 /* PercentToken */:\n                                    return 1 /* GreaterThan */;\n                                case 32 /* PlusToken */:\n                                    return 0 /* EqualTo */;\n                                default:\n                                    return -1 /* LessThan */;\n                            }\n                        case 158 /* ConditionalExpression */:\n                            return -1 /* LessThan */;\n                        default:\n                            return 1 /* GreaterThan */;\n                    }\n                }\n            }\n            function emitTemplateSpan(span) {\n                emit(span.expression);\n                emit(span.literal);\n            }\n            // This function specifically handles numeric/string literals for enum and accessor 'identifiers'.\n            // In a sense, it does not actually emit identifiers as much as it declares a name for a specific property.\n            function emitExpressionForPropertyName(node) {\n                if (node.kind === 7 /* StringLiteral */) {\n                    emitLiteral(node);\n                }\n                else if (node.kind === 121 /* ComputedPropertyName */) {\n                    emit(node.expression);\n                }\n                else {\n                    write(\"\\\"\");\n                    if (node.kind === 6 /* NumericLiteral */) {\n                        write(node.text);\n                    }\n                    else {\n                        writeTextOfNode(currentSourceFile, node);\n                    }\n                    write(\"\\\"\");\n                }\n            }\n            function isNotExpressionIdentifier(node) {\n                var parent = node.parent;\n                switch (parent.kind) {\n                    case 123 /* Parameter */:\n                    case 183 /* VariableDeclaration */:\n                    case 124 /* Property */:\n                    case 198 /* PropertyAssignment */:\n                    case 199 /* ShorthandPropertyAssignment */:\n                    case 200 /* EnumMember */:\n                    case 125 /* Method */:\n                    case 184 /* FunctionDeclaration */:\n                    case 127 /* GetAccessor */:\n                    case 128 /* SetAccessor */:\n                    case 150 /* FunctionExpression */:\n                    case 185 /* ClassDeclaration */:\n                    case 186 /* InterfaceDeclaration */:\n                    case 188 /* EnumDeclaration */:\n                    case 189 /* ModuleDeclaration */:\n                    case 191 /* ImportDeclaration */:\n                        return parent.name === node;\n                    case 173 /* BreakStatement */:\n                    case 172 /* ContinueStatement */:\n                    case 192 /* ExportAssignment */:\n                        return false;\n                    case 177 /* LabeledStatement */:\n                        return node.parent.label === node;\n                    case 197 /* CatchClause */:\n                        return node.parent.name === node;\n                }\n            }\n            function emitExpressionIdentifier(node) {\n                var prefix = resolver.getExpressionNamePrefix(node);\n                if (prefix) {\n                    write(prefix);\n                    write(\".\");\n                }\n                writeTextOfNode(currentSourceFile, node);\n            }\n            function emitIdentifier(node) {\n                if (!isNotExpressionIdentifier(node)) {\n                    emitExpressionIdentifier(node);\n                }\n                else {\n                    writeTextOfNode(currentSourceFile, node);\n                }\n            }\n            function emitThis(node) {\n                if (resolver.getNodeCheckFlags(node) & 2 /* LexicalThis */) {\n                    write(\"_this\");\n                }\n                else {\n                    write(\"this\");\n                }\n            }\n            function emitSuper(node) {\n                var flags = resolver.getNodeCheckFlags(node);\n                if (flags & 16 /* SuperInstance */) {\n                    write(\"_super.prototype\");\n                }\n                else if (flags & 32 /* SuperStatic */) {\n                    write(\"_super\");\n                }\n                else {\n                    write(\"super\");\n                }\n            }\n            function emitArrayLiteral(node) {\n                if (node.flags & 256 /* MultiLine */) {\n                    write(\"[\");\n                    increaseIndent();\n                    emitMultiLineList(node.elements, true);\n                    decreaseIndent();\n                    writeLine();\n                    write(\"]\");\n                }\n                else {\n                    write(\"[\");\n                    emitCommaList(node.elements, true);\n                    write(\"]\");\n                }\n            }\n            function emitObjectLiteral(node) {\n                if (!node.properties.length) {\n                    write(\"{}\");\n                }\n                else if (node.flags & 256 /* MultiLine */) {\n                    write(\"{\");\n                    increaseIndent();\n                    emitMultiLineList(node.properties, compilerOptions.target >= 1 /* ES5 */);\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                }\n                else {\n                    write(\"{ \");\n                    emitCommaList(node.properties, compilerOptions.target >= 1 /* ES5 */);\n                    write(\" }\");\n                }\n            }\n            function emitComputedPropertyName(node) {\n                write(\"[\");\n                emit(node.expression);\n                write(\"]\");\n            }\n            function emitDownlevelMethod(node) {\n                if (!ts.isObjectLiteralMethod(node)) {\n                    return;\n                }\n                emitLeadingComments(node);\n                emit(node.name);\n                write(\": \");\n                write(\"function \");\n                emitSignatureAndBody(node);\n                emitTrailingComments(node);\n            }\n            function emitMethod(node) {\n                if (!ts.isObjectLiteralMethod(node)) {\n                    return;\n                }\n                emitLeadingComments(node);\n                emit(node.name);\n                emitSignatureAndBody(node);\n                emitTrailingComments(node);\n            }\n            function emitPropertyAssignment(node) {\n                emitLeadingComments(node);\n                emit(node.name);\n                write(\": \");\n                emit(node.initializer);\n                emitTrailingComments(node);\n            }\n            function emitDownlevelShorthandPropertyAssignment(node) {\n                emitLeadingComments(node);\n                // Emit identifier as an identifier\n                emit(node.name);\n                write(\": \");\n                // Even though this is stored as identifier treat it as an expression\n                // Short-hand, { x }, is equivalent of normal form { x: x }\n                emitExpressionIdentifier(node.name);\n                emitTrailingComments(node);\n            }\n            function emitShorthandPropertyAssignment(node) {\n                // If short-hand property has a prefix, then regardless of the target version, we will emit it as normal property assignment. For example:\n                //  module m {\n                //      export var y;\n                //  }\n                //  module m {\n                //      export var obj = { y };\n                //  }\n                //  The short-hand property in obj need to emit as such ... = { y : m.y } regardless of the TargetScript version\n                var prefix = resolver.getExpressionNamePrefix(node.name);\n                if (prefix) {\n                    emitDownlevelShorthandPropertyAssignment(node);\n                }\n                else {\n                    emitLeadingComments(node);\n                    emit(node.name);\n                    emitTrailingComments(node);\n                }\n            }\n            function tryEmitConstantValue(node) {\n                var constantValue = resolver.getConstantValue(node);\n                if (constantValue !== undefined) {\n                    var propertyName = node.kind === 143 /* PropertyAccessExpression */ ? ts.declarationNameToString(node.name) : ts.getTextOfNode(node.argumentExpression);\n                    write(constantValue.toString() + \" /* \" + propertyName + \" */\");\n                    return true;\n                }\n                return false;\n            }\n            function emitPropertyAccess(node) {\n                if (tryEmitConstantValue(node)) {\n                    return;\n                }\n                emit(node.expression);\n                write(\".\");\n                emit(node.name);\n            }\n            function emitQualifiedName(node) {\n                emit(node.left);\n                write(\".\");\n                emit(node.right);\n            }\n            function emitIndexedAccess(node) {\n                if (tryEmitConstantValue(node)) {\n                    return;\n                }\n                emit(node.expression);\n                write(\"[\");\n                emit(node.argumentExpression);\n                write(\"]\");\n            }\n            function emitCallExpression(node) {\n                var superCall = false;\n                if (node.expression.kind === 89 /* SuperKeyword */) {\n                    write(\"_super\");\n                    superCall = true;\n                }\n                else {\n                    emit(node.expression);\n                    superCall = node.expression.kind === 143 /* PropertyAccessExpression */ && node.expression.expression.kind === 89 /* SuperKeyword */;\n                }\n                if (superCall) {\n                    write(\".call(\");\n                    emitThis(node.expression);\n                    if (node.arguments.length) {\n                        write(\", \");\n                        emitCommaList(node.arguments, false);\n                    }\n                    write(\")\");\n                }\n                else {\n                    write(\"(\");\n                    emitCommaList(node.arguments, false);\n                    write(\")\");\n                }\n            }\n            function emitNewExpression(node) {\n                write(\"new \");\n                emit(node.expression);\n                if (node.arguments) {\n                    write(\"(\");\n                    emitCommaList(node.arguments, false);\n                    write(\")\");\n                }\n            }\n            function emitTaggedTemplateExpression(node) {\n                ts.Debug.assert(compilerOptions.target >= 2 /* ES6 */, \"Trying to emit a tagged template in pre-ES6 mode.\");\n                emit(node.tag);\n                write(\" \");\n                emit(node.template);\n            }\n            function emitParenExpression(node) {\n                if (node.expression.kind === 148 /* TypeAssertionExpression */) {\n                    var operand = node.expression.expression;\n                    while (operand.kind == 148 /* TypeAssertionExpression */) {\n                        operand = operand.expression;\n                    }\n                    // We have an expression of the form: (<Type>SubExpr)\n                    // Emitting this as (SubExpr) is really not desirable. We would like to emit the subexpr as is.\n                    // Omitting the parentheses, however, could cause change in the semantics of the generated\n                    // code if the casted expression has a lower precedence than the rest of the expression, e.g.: \n                    //      (<any>new A).foo should be emitted as (new A).foo and not new A.foo\n                    //      (<any>typeof A).toString() should be emitted as (typeof A).toString() and not typeof A.toString()\n                    //      new (<any>A()) should be emitted as new (A()) and not new A()\n                    //      (<any>function foo() { })() should be emitted as an IIF (function foo(){})() and not declaration function foo(){} ()\n                    if (operand.kind !== 155 /* PrefixUnaryExpression */ && operand.kind !== 154 /* VoidExpression */ && operand.kind !== 153 /* TypeOfExpression */ && operand.kind !== 152 /* DeleteExpression */ && operand.kind !== 156 /* PostfixUnaryExpression */ && operand.kind !== 146 /* NewExpression */ && !(operand.kind === 145 /* CallExpression */ && node.parent.kind === 146 /* NewExpression */) && !(operand.kind === 150 /* FunctionExpression */ && node.parent.kind === 145 /* CallExpression */)) {\n                        emit(operand);\n                        return;\n                    }\n                }\n                write(\"(\");\n                emit(node.expression);\n                write(\")\");\n            }\n            function emitDeleteExpression(node) {\n                write(ts.tokenToString(72 /* DeleteKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function emitVoidExpression(node) {\n                write(ts.tokenToString(97 /* VoidKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function emitTypeOfExpression(node) {\n                write(ts.tokenToString(95 /* TypeOfKeyword */));\n                write(\" \");\n                emit(node.expression);\n            }\n            function emitPrefixUnaryExpression(node) {\n                write(ts.tokenToString(node.operator));\n                // In some cases, we need to emit a space between the operator and the operand. One obvious case\n                // is when the operator is an identifier, like delete or typeof. We also need to do this for plus\n                // and minus expressions in certain cases. Specifically, consider the following two cases (parens\n                // are just for clarity of exposition, and not part of the source code):\n                //\n                //  (+(+1))\n                //  (+(++1))\n                //\n                // We need to emit a space in both cases. In the first case, the absence of a space will make\n                // the resulting expression a prefix increment operation. And in the second, it will make the resulting\n                // expression a prefix increment whose operand is a plus expression - (++(+x))\n                // The same is true of minus of course.\n                if (node.operand.kind === 155 /* PrefixUnaryExpression */) {\n                    var operand = node.operand;\n                    if (node.operator === 32 /* PlusToken */ && (operand.operator === 32 /* PlusToken */ || operand.operator === 37 /* PlusPlusToken */)) {\n                        write(\" \");\n                    }\n                    else if (node.operator === 33 /* MinusToken */ && (operand.operator === 33 /* MinusToken */ || operand.operator === 38 /* MinusMinusToken */)) {\n                        write(\" \");\n                    }\n                }\n                emit(node.operand);\n            }\n            function emitPostfixUnaryExpression(node) {\n                emit(node.operand);\n                write(ts.tokenToString(node.operator));\n            }\n            function emitBinaryExpression(node) {\n                emit(node.left);\n                if (node.operator !== 22 /* CommaToken */)\n                    write(\" \");\n                write(ts.tokenToString(node.operator));\n                write(\" \");\n                emit(node.right);\n            }\n            function emitConditionalExpression(node) {\n                emit(node.condition);\n                write(\" ? \");\n                emit(node.whenTrue);\n                write(\" : \");\n                emit(node.whenFalse);\n            }\n            function emitBlock(node) {\n                emitToken(13 /* OpenBraceToken */, node.pos);\n                increaseIndent();\n                scopeEmitStart(node.parent);\n                if (node.kind === 190 /* ModuleBlock */) {\n                    ts.Debug.assert(node.parent.kind === 189 /* ModuleDeclaration */);\n                    emitCaptureThisForNodeIfNecessary(node.parent);\n                }\n                emitLines(node.statements);\n                decreaseIndent();\n                writeLine();\n                emitToken(14 /* CloseBraceToken */, node.statements.end);\n                scopeEmitEnd();\n            }\n            function emitEmbeddedStatement(node) {\n                if (node.kind === 163 /* Block */) {\n                    write(\" \");\n                    emit(node);\n                }\n                else {\n                    increaseIndent();\n                    writeLine();\n                    emit(node);\n                    decreaseIndent();\n                }\n            }\n            function emitExpressionStatement(node) {\n                var isArrowExpression = node.expression.kind === 151 /* ArrowFunction */;\n                emitLeadingComments(node);\n                if (isArrowExpression)\n                    write(\"(\");\n                emit(node.expression);\n                if (isArrowExpression)\n                    write(\")\");\n                write(\";\");\n                emitTrailingComments(node);\n            }\n            function emitIfStatement(node) {\n                emitLeadingComments(node);\n                var endPos = emitToken(82 /* IfKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(15 /* OpenParenToken */, endPos);\n                emit(node.expression);\n                emitToken(16 /* CloseParenToken */, node.expression.end);\n                emitEmbeddedStatement(node.thenStatement);\n                if (node.elseStatement) {\n                    writeLine();\n                    emitToken(74 /* ElseKeyword */, node.thenStatement.end);\n                    if (node.elseStatement.kind === 167 /* IfStatement */) {\n                        write(\" \");\n                        emit(node.elseStatement);\n                    }\n                    else {\n                        emitEmbeddedStatement(node.elseStatement);\n                    }\n                }\n                emitTrailingComments(node);\n            }\n            function emitDoStatement(node) {\n                write(\"do\");\n                emitEmbeddedStatement(node.statement);\n                if (node.statement.kind === 163 /* Block */) {\n                    write(\" \");\n                }\n                else {\n                    writeLine();\n                }\n                write(\"while (\");\n                emit(node.expression);\n                write(\");\");\n            }\n            function emitWhileStatement(node) {\n                write(\"while (\");\n                emit(node.expression);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitForStatement(node) {\n                var endPos = emitToken(80 /* ForKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(15 /* OpenParenToken */, endPos);\n                if (node.declarations) {\n                    if (node.declarations[0] && ts.isLet(node.declarations[0])) {\n                        emitToken(102 /* LetKeyword */, endPos);\n                    }\n                    else if (node.declarations[0] && ts.isConst(node.declarations[0])) {\n                        emitToken(68 /* ConstKeyword */, endPos);\n                    }\n                    else {\n                        emitToken(96 /* VarKeyword */, endPos);\n                    }\n                    write(\" \");\n                    emitCommaList(node.declarations, false);\n                }\n                if (node.initializer) {\n                    emit(node.initializer);\n                }\n                write(\";\");\n                emitOptional(\" \", node.condition);\n                write(\";\");\n                emitOptional(\" \", node.iterator);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitForInStatement(node) {\n                var endPos = emitToken(80 /* ForKeyword */, node.pos);\n                write(\" \");\n                endPos = emitToken(15 /* OpenParenToken */, endPos);\n                if (node.declarations) {\n                    if (node.declarations.length >= 1) {\n                        var decl = node.declarations[0];\n                        if (ts.isLet(decl)) {\n                            emitToken(102 /* LetKeyword */, endPos);\n                        }\n                        else {\n                            emitToken(96 /* VarKeyword */, endPos);\n                        }\n                        write(\" \");\n                        emit(decl);\n                    }\n                }\n                else {\n                    emit(node.variable);\n                }\n                write(\" in \");\n                emit(node.expression);\n                emitToken(16 /* CloseParenToken */, node.expression.end);\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitBreakOrContinueStatement(node) {\n                emitToken(node.kind === 173 /* BreakStatement */ ? 64 /* BreakKeyword */ : 69 /* ContinueKeyword */, node.pos);\n                emitOptional(\" \", node.label);\n                write(\";\");\n            }\n            function emitReturnStatement(node) {\n                emitLeadingComments(node);\n                emitToken(88 /* ReturnKeyword */, node.pos);\n                emitOptional(\" \", node.expression);\n                write(\";\");\n                emitTrailingComments(node);\n            }\n            function emitWithStatement(node) {\n                write(\"with (\");\n                emit(node.expression);\n                write(\")\");\n                emitEmbeddedStatement(node.statement);\n            }\n            function emitSwitchStatement(node) {\n                var endPos = emitToken(90 /* SwitchKeyword */, node.pos);\n                write(\" \");\n                emitToken(15 /* OpenParenToken */, endPos);\n                emit(node.expression);\n                endPos = emitToken(16 /* CloseParenToken */, node.expression.end);\n                write(\" \");\n                emitToken(13 /* OpenBraceToken */, endPos);\n                increaseIndent();\n                emitLines(node.clauses);\n                decreaseIndent();\n                writeLine();\n                emitToken(14 /* CloseBraceToken */, node.clauses.end);\n            }\n            function isOnSameLine(node1, node2) {\n                return getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node1.pos)) === getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node2.pos));\n            }\n            function emitCaseOrDefaultClause(node) {\n                if (node.kind === 194 /* CaseClause */) {\n                    write(\"case \");\n                    emit(node.expression);\n                    write(\":\");\n                }\n                else {\n                    write(\"default:\");\n                }\n                if (node.statements.length === 1 && isOnSameLine(node, node.statements[0])) {\n                    write(\" \");\n                    emit(node.statements[0]);\n                }\n                else {\n                    increaseIndent();\n                    emitLines(node.statements);\n                    decreaseIndent();\n                }\n            }\n            function emitThrowStatement(node) {\n                write(\"throw \");\n                emit(node.expression);\n                write(\";\");\n            }\n            function emitTryStatement(node) {\n                write(\"try \");\n                emit(node.tryBlock);\n                emit(node.catchClause);\n                if (node.finallyBlock) {\n                    writeLine();\n                    write(\"finally \");\n                    emit(node.finallyBlock);\n                }\n            }\n            function emitCatchClause(node) {\n                writeLine();\n                var endPos = emitToken(66 /* CatchKeyword */, node.pos);\n                write(\" \");\n                emitToken(15 /* OpenParenToken */, endPos);\n                emit(node.name);\n                emitToken(16 /* CloseParenToken */, node.name.end);\n                write(\" \");\n                emitBlock(node.block);\n            }\n            function emitDebuggerStatement(node) {\n                emitToken(70 /* DebuggerKeyword */, node.pos);\n                write(\";\");\n            }\n            function emitLabelledStatement(node) {\n                emit(node.label);\n                write(\": \");\n                emit(node.statement);\n            }\n            function getContainingModule(node) {\n                do {\n                    node = node.parent;\n                } while (node && node.kind !== 189 /* ModuleDeclaration */);\n                return node;\n            }\n            function emitModuleMemberName(node) {\n                emitStart(node.name);\n                if (node.flags & 1 /* Export */) {\n                    var container = getContainingModule(node);\n                    write(container ? resolver.getLocalNameOfContainer(container) : \"exports\");\n                    write(\".\");\n                }\n                emitNode(node.name);\n                emitEnd(node.name);\n            }\n            function emitVariableDeclaration(node) {\n                emitLeadingComments(node);\n                emitModuleMemberName(node);\n                emitOptional(\" = \", node.initializer);\n                emitTrailingComments(node);\n            }\n            function emitVariableStatement(node) {\n                emitLeadingComments(node);\n                if (!(node.flags & 1 /* Export */)) {\n                    if (ts.isLet(node)) {\n                        write(\"let \");\n                    }\n                    else if (ts.isConst(node)) {\n                        write(\"const \");\n                    }\n                    else {\n                        write(\"var \");\n                    }\n                }\n                emitCommaList(node.declarations, false);\n                write(\";\");\n                emitTrailingComments(node);\n            }\n            function emitParameter(node) {\n                emitLeadingComments(node);\n                emit(node.name);\n                emitTrailingComments(node);\n            }\n            function emitDefaultValueAssignments(node) {\n                ts.forEach(node.parameters, function (param) {\n                    if (param.initializer) {\n                        writeLine();\n                        emitStart(param);\n                        write(\"if (\");\n                        emitNode(param.name);\n                        write(\" === void 0)\");\n                        emitEnd(param);\n                        write(\" { \");\n                        emitStart(param);\n                        emitNode(param.name);\n                        write(\" = \");\n                        emitNode(param.initializer);\n                        emitEnd(param);\n                        write(\"; }\");\n                    }\n                });\n            }\n            function emitRestParameter(node) {\n                if (ts.hasRestParameters(node)) {\n                    var restIndex = node.parameters.length - 1;\n                    var restParam = node.parameters[restIndex];\n                    writeLine();\n                    emitLeadingComments(restParam);\n                    emitStart(restParam);\n                    write(\"var \");\n                    emitNode(restParam.name);\n                    write(\" = [];\");\n                    emitEnd(restParam);\n                    emitTrailingComments(restParam);\n                    writeLine();\n                    write(\"for (\");\n                    emitStart(restParam);\n                    write(\"var _i = \" + restIndex + \";\");\n                    emitEnd(restParam);\n                    write(\" \");\n                    emitStart(restParam);\n                    write(\"_i < arguments.length;\");\n                    emitEnd(restParam);\n                    write(\" \");\n                    emitStart(restParam);\n                    write(\"_i++\");\n                    emitEnd(restParam);\n                    write(\") {\");\n                    increaseIndent();\n                    writeLine();\n                    emitStart(restParam);\n                    emitNode(restParam.name);\n                    write(\"[_i - \" + restIndex + \"] = arguments[_i];\");\n                    emitEnd(restParam);\n                    decreaseIndent();\n                    writeLine();\n                    write(\"}\");\n                }\n            }\n            function emitAccessor(node) {\n                emitLeadingComments(node);\n                write(node.kind === 127 /* GetAccessor */ ? \"get \" : \"set \");\n                emit(node.name);\n                emitSignatureAndBody(node);\n                emitTrailingComments(node);\n            }\n            function emitFunctionDeclaration(node) {\n                if (!node.body) {\n                    return emitPinnedOrTripleSlashComments(node);\n                }\n                if (node.kind !== 125 /* Method */) {\n                    // Methods will emit the comments as part of emitting method declaration\n                    emitLeadingComments(node);\n                }\n                write(\"function \");\n                if (node.kind === 184 /* FunctionDeclaration */ || (node.kind === 150 /* FunctionExpression */ && node.name)) {\n                    emit(node.name);\n                }\n                emitSignatureAndBody(node);\n                if (node.kind !== 125 /* Method */) {\n                    emitTrailingComments(node);\n                }\n            }\n            function emitCaptureThisForNodeIfNecessary(node) {\n                if (resolver.getNodeCheckFlags(node) & 4 /* CaptureThis */) {\n                    writeLine();\n                    emitStart(node);\n                    write(\"var _this = this;\");\n                    emitEnd(node);\n                }\n            }\n            function emitSignatureParameters(node) {\n                increaseIndent();\n                write(\"(\");\n                if (node) {\n                    emitCommaList(node.parameters, false, node.parameters.length - (ts.hasRestParameters(node) ? 1 : 0));\n                }\n                write(\")\");\n                decreaseIndent();\n            }\n            function emitSignatureAndBody(node) {\n                emitSignatureParameters(node);\n                write(\" {\");\n                scopeEmitStart(node);\n                increaseIndent();\n                emitDetachedComments(node.body.kind === 163 /* Block */ ? node.body.statements : node.body);\n                var startIndex = 0;\n                if (node.body.kind === 163 /* Block */) {\n                    startIndex = emitDirectivePrologues(node.body.statements, true);\n                }\n                var outPos = writer.getTextPos();\n                emitCaptureThisForNodeIfNecessary(node);\n                emitDefaultValueAssignments(node);\n                emitRestParameter(node);\n                if (node.body.kind !== 163 /* Block */ && outPos === writer.getTextPos()) {\n                    decreaseIndent();\n                    write(\" \");\n                    emitStart(node.body);\n                    write(\"return \");\n                    emitNode(node.body);\n                    emitEnd(node.body);\n                    write(\"; \");\n                    emitStart(node.body);\n                    write(\"}\");\n                    emitEnd(node.body);\n                }\n                else {\n                    if (node.body.kind === 163 /* Block */) {\n                        emitLinesStartingAt(node.body.statements, startIndex);\n                    }\n                    else {\n                        writeLine();\n                        emitLeadingComments(node.body);\n                        write(\"return \");\n                        emit(node.body);\n                        write(\";\");\n                        emitTrailingComments(node.body);\n                    }\n                    writeLine();\n                    if (node.body.kind === 163 /* Block */) {\n                        emitLeadingCommentsOfPosition(node.body.statements.end);\n                        decreaseIndent();\n                        emitToken(14 /* CloseBraceToken */, node.body.statements.end);\n                    }\n                    else {\n                        decreaseIndent();\n                        emitStart(node.body);\n                        write(\"}\");\n                        emitEnd(node.body);\n                    }\n                }\n                scopeEmitEnd();\n                if (node.flags & 1 /* Export */) {\n                    writeLine();\n                    emitStart(node);\n                    emitModuleMemberName(node);\n                    write(\" = \");\n                    emit(node.name);\n                    emitEnd(node);\n                    write(\";\");\n                }\n            }\n            function findInitialSuperCall(ctor) {\n                if (ctor.body) {\n                    var statement = ctor.body.statements[0];\n                    if (statement && statement.kind === 166 /* ExpressionStatement */) {\n                        var expr = statement.expression;\n                        if (expr && expr.kind === 145 /* CallExpression */) {\n                            var func = expr.expression;\n                            if (func && func.kind === 89 /* SuperKeyword */) {\n                                return statement;\n                            }\n                        }\n                    }\n                }\n            }\n            function emitParameterPropertyAssignments(node) {\n                ts.forEach(node.parameters, function (param) {\n                    if (param.flags & 112 /* AccessibilityModifier */) {\n                        writeLine();\n                        emitStart(param);\n                        emitStart(param.name);\n                        write(\"this.\");\n                        emitNode(param.name);\n                        emitEnd(param.name);\n                        write(\" = \");\n                        emit(param.name);\n                        write(\";\");\n                        emitEnd(param);\n                    }\n                });\n            }\n            function emitMemberAccessForPropertyName(memberName) {\n                if (memberName.kind === 7 /* StringLiteral */ || memberName.kind === 6 /* NumericLiteral */) {\n                    write(\"[\");\n                    emitNode(memberName);\n                    write(\"]\");\n                }\n                else if (memberName.kind === 121 /* ComputedPropertyName */) {\n                    emitComputedPropertyName(memberName);\n                }\n                else {\n                    write(\".\");\n                    emitNode(memberName);\n                }\n            }\n            function emitMemberAssignments(node, staticFlag) {\n                ts.forEach(node.members, function (member) {\n                    if (member.kind === 124 /* Property */ && (member.flags & 128 /* Static */) === staticFlag && member.initializer) {\n                        writeLine();\n                        emitLeadingComments(member);\n                        emitStart(member);\n                        emitStart(member.name);\n                        if (staticFlag) {\n                            emitNode(node.name);\n                        }\n                        else {\n                            write(\"this\");\n                        }\n                        emitMemberAccessForPropertyName(member.name);\n                        emitEnd(member.name);\n                        write(\" = \");\n                        emit(member.initializer);\n                        write(\";\");\n                        emitEnd(member);\n                        emitTrailingComments(member);\n                    }\n                });\n            }\n            function emitMemberFunctions(node) {\n                ts.forEach(node.members, function (member) {\n                    if (member.kind === 125 /* Method */) {\n                        if (!member.body) {\n                            return emitPinnedOrTripleSlashComments(member);\n                        }\n                        writeLine();\n                        emitLeadingComments(member);\n                        emitStart(member);\n                        emitStart(member.name);\n                        emitNode(node.name);\n                        if (!(member.flags & 128 /* Static */)) {\n                            write(\".prototype\");\n                        }\n                        emitMemberAccessForPropertyName(member.name);\n                        emitEnd(member.name);\n                        write(\" = \");\n                        emitStart(member);\n                        emitFunctionDeclaration(member);\n                        emitEnd(member);\n                        emitEnd(member);\n                        write(\";\");\n                        emitTrailingComments(member);\n                    }\n                    else if (member.kind === 127 /* GetAccessor */ || member.kind === 128 /* SetAccessor */) {\n                        var accessors = getAllAccessorDeclarations(node, member);\n                        if (member === accessors.firstAccessor) {\n                            writeLine();\n                            emitStart(member);\n                            write(\"Object.defineProperty(\");\n                            emitStart(member.name);\n                            emitNode(node.name);\n                            if (!(member.flags & 128 /* Static */)) {\n                                write(\".prototype\");\n                            }\n                            write(\", \");\n                            emitExpressionForPropertyName(member.name);\n                            emitEnd(member.name);\n                            write(\", {\");\n                            increaseIndent();\n                            if (accessors.getAccessor) {\n                                writeLine();\n                                emitLeadingComments(accessors.getAccessor);\n                                write(\"get: \");\n                                emitStart(accessors.getAccessor);\n                                write(\"function \");\n                                emitSignatureAndBody(accessors.getAccessor);\n                                emitEnd(accessors.getAccessor);\n                                emitTrailingComments(accessors.getAccessor);\n                                write(\",\");\n                            }\n                            if (accessors.setAccessor) {\n                                writeLine();\n                                emitLeadingComments(accessors.setAccessor);\n                                write(\"set: \");\n                                emitStart(accessors.setAccessor);\n                                write(\"function \");\n                                emitSignatureAndBody(accessors.setAccessor);\n                                emitEnd(accessors.setAccessor);\n                                emitTrailingComments(accessors.setAccessor);\n                                write(\",\");\n                            }\n                            writeLine();\n                            write(\"enumerable: true,\");\n                            writeLine();\n                            write(\"configurable: true\");\n                            decreaseIndent();\n                            writeLine();\n                            write(\"});\");\n                            emitEnd(member);\n                        }\n                    }\n                });\n            }\n            function emitClassDeclaration(node) {\n                emitLeadingComments(node);\n                write(\"var \");\n                emit(node.name);\n                write(\" = (function (\");\n                var baseTypeNode = ts.getClassBaseTypeNode(node);\n                if (baseTypeNode) {\n                    write(\"_super\");\n                }\n                write(\") {\");\n                increaseIndent();\n                scopeEmitStart(node);\n                if (baseTypeNode) {\n                    writeLine();\n                    emitStart(baseTypeNode);\n                    write(\"__extends(\");\n                    emit(node.name);\n                    write(\", _super);\");\n                    emitEnd(baseTypeNode);\n                }\n                writeLine();\n                emitConstructorOfClass();\n                emitMemberFunctions(node);\n                emitMemberAssignments(node, 128 /* Static */);\n                writeLine();\n                function emitClassReturnStatement() {\n                    write(\"return \");\n                    emitNode(node.name);\n                }\n                emitToken(14 /* CloseBraceToken */, node.members.end, emitClassReturnStatement);\n                write(\";\");\n                decreaseIndent();\n                writeLine();\n                emitToken(14 /* CloseBraceToken */, node.members.end);\n                scopeEmitEnd();\n                emitStart(node);\n                write(\")(\");\n                if (baseTypeNode) {\n                    emit(baseTypeNode.typeName);\n                }\n                write(\");\");\n                emitEnd(node);\n                if (node.flags & 1 /* Export */) {\n                    writeLine();\n                    emitStart(node);\n                    emitModuleMemberName(node);\n                    write(\" = \");\n                    emit(node.name);\n                    emitEnd(node);\n                    write(\";\");\n                }\n                emitTrailingComments(node);\n                function emitConstructorOfClass() {\n                    // Emit the constructor overload pinned comments\n                    ts.forEach(node.members, function (member) {\n                        if (member.kind === 126 /* Constructor */ && !member.body) {\n                            emitPinnedOrTripleSlashComments(member);\n                        }\n                    });\n                    var ctor = getFirstConstructorWithBody(node);\n                    if (ctor) {\n                        emitLeadingComments(ctor);\n                    }\n                    emitStart(ctor || node);\n                    write(\"function \");\n                    emit(node.name);\n                    emitSignatureParameters(ctor);\n                    write(\" {\");\n                    scopeEmitStart(node, \"constructor\");\n                    increaseIndent();\n                    if (ctor) {\n                        emitDetachedComments(ctor.body.statements);\n                    }\n                    emitCaptureThisForNodeIfNecessary(node);\n                    if (ctor) {\n                        emitDefaultValueAssignments(ctor);\n                        emitRestParameter(ctor);\n                        if (baseTypeNode) {\n                            var superCall = findInitialSuperCall(ctor);\n                            if (superCall) {\n                                writeLine();\n                                emit(superCall);\n                            }\n                        }\n                        emitParameterPropertyAssignments(ctor);\n                    }\n                    else {\n                        if (baseTypeNode) {\n                            writeLine();\n                            emitStart(baseTypeNode);\n                            write(\"_super.apply(this, arguments);\");\n                            emitEnd(baseTypeNode);\n                        }\n                    }\n                    emitMemberAssignments(node, 0);\n                    if (ctor) {\n                        var statements = ctor.body.statements;\n                        if (superCall)\n                            statements = statements.slice(1);\n                        emitLines(statements);\n                    }\n                    writeLine();\n                    if (ctor) {\n                        emitLeadingCommentsOfPosition(ctor.body.statements.end);\n                    }\n                    decreaseIndent();\n                    emitToken(14 /* CloseBraceToken */, ctor ? ctor.body.statements.end : node.members.end);\n                    scopeEmitEnd();\n                    emitEnd(ctor || node);\n                    if (ctor) {\n                        emitTrailingComments(ctor);\n                    }\n                }\n            }\n            function emitInterfaceDeclaration(node) {\n                emitPinnedOrTripleSlashComments(node);\n            }\n            function emitEnumDeclaration(node) {\n                // const enums are completely erased during compilation.\n                var isConstEnum = ts.isConst(node);\n                if (isConstEnum && !compilerOptions.preserveConstEnums) {\n                    return;\n                }\n                emitLeadingComments(node);\n                if (!(node.flags & 1 /* Export */)) {\n                    emitStart(node);\n                    write(\"var \");\n                    emit(node.name);\n                    emitEnd(node);\n                    write(\";\");\n                }\n                writeLine();\n                emitStart(node);\n                write(\"(function (\");\n                emitStart(node.name);\n                write(resolver.getLocalNameOfContainer(node));\n                emitEnd(node.name);\n                write(\") {\");\n                increaseIndent();\n                scopeEmitStart(node);\n                emitEnumMemberDeclarations(isConstEnum);\n                decreaseIndent();\n                writeLine();\n                emitToken(14 /* CloseBraceToken */, node.members.end);\n                scopeEmitEnd();\n                write(\")(\");\n                emitModuleMemberName(node);\n                write(\" || (\");\n                emitModuleMemberName(node);\n                write(\" = {}));\");\n                emitEnd(node);\n                if (node.flags & 1 /* Export */) {\n                    writeLine();\n                    emitStart(node);\n                    write(\"var \");\n                    emit(node.name);\n                    write(\" = \");\n                    emitModuleMemberName(node);\n                    emitEnd(node);\n                    write(\";\");\n                }\n                emitTrailingComments(node);\n                function emitEnumMemberDeclarations(isConstEnum) {\n                    ts.forEach(node.members, function (member) {\n                        writeLine();\n                        emitLeadingComments(member);\n                        emitStart(member);\n                        write(resolver.getLocalNameOfContainer(node));\n                        write(\"[\");\n                        write(resolver.getLocalNameOfContainer(node));\n                        write(\"[\");\n                        emitExpressionForPropertyName(member.name);\n                        write(\"] = \");\n                        if (member.initializer && !isConstEnum) {\n                            emit(member.initializer);\n                        }\n                        else {\n                            write(resolver.getEnumMemberValue(member).toString());\n                        }\n                        write(\"] = \");\n                        emitExpressionForPropertyName(member.name);\n                        emitEnd(member);\n                        write(\";\");\n                        emitTrailingComments(member);\n                    });\n                }\n            }\n            function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {\n                if (moduleDeclaration.body.kind === 189 /* ModuleDeclaration */) {\n                    var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);\n                    return recursiveInnerModule || moduleDeclaration.body;\n                }\n            }\n            function emitModuleDeclaration(node) {\n                var shouldEmit = ts.getModuleInstanceState(node) === 1 /* Instantiated */ || (ts.getModuleInstanceState(node) === 2 /* ConstEnumOnly */ && compilerOptions.preserveConstEnums);\n                if (!shouldEmit) {\n                    return emitPinnedOrTripleSlashComments(node);\n                }\n                emitLeadingComments(node);\n                emitStart(node);\n                write(\"var \");\n                emit(node.name);\n                write(\";\");\n                emitEnd(node);\n                writeLine();\n                emitStart(node);\n                write(\"(function (\");\n                emitStart(node.name);\n                write(resolver.getLocalNameOfContainer(node));\n                emitEnd(node.name);\n                write(\") \");\n                if (node.body.kind === 190 /* ModuleBlock */) {\n                    emit(node.body);\n                }\n                else {\n                    write(\"{\");\n                    increaseIndent();\n                    scopeEmitStart(node);\n                    emitCaptureThisForNodeIfNecessary(node);\n                    writeLine();\n                    emit(node.body);\n                    decreaseIndent();\n                    writeLine();\n                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;\n                    emitToken(14 /* CloseBraceToken */, moduleBlock.statements.end);\n                    scopeEmitEnd();\n                }\n                write(\")(\");\n                if (node.flags & 1 /* Export */) {\n                    emit(node.name);\n                    write(\" = \");\n                }\n                emitModuleMemberName(node);\n                write(\" || (\");\n                emitModuleMemberName(node);\n                write(\" = {}));\");\n                emitEnd(node);\n                emitTrailingComments(node);\n            }\n            function emitImportDeclaration(node) {\n                var emitImportDeclaration = resolver.isReferencedImportDeclaration(node);\n                if (!emitImportDeclaration) {\n                    // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when\n                    // - current file is not external module\n                    // - import declaration is top level and target is value imported by entity name\n                    emitImportDeclaration = !ts.isExternalModule(currentSourceFile) && resolver.isTopLevelValueImportWithEntityName(node);\n                }\n                if (emitImportDeclaration) {\n                    if (ts.isExternalModuleImportDeclaration(node) && node.parent.kind === 201 /* SourceFile */ && compilerOptions.module === 2 /* AMD */) {\n                        if (node.flags & 1 /* Export */) {\n                            writeLine();\n                            emitLeadingComments(node);\n                            emitStart(node);\n                            emitModuleMemberName(node);\n                            write(\" = \");\n                            emit(node.name);\n                            write(\";\");\n                            emitEnd(node);\n                            emitTrailingComments(node);\n                        }\n                    }\n                    else {\n                        writeLine();\n                        emitLeadingComments(node);\n                        emitStart(node);\n                        if (!(node.flags & 1 /* Export */))\n                            write(\"var \");\n                        emitModuleMemberName(node);\n                        write(\" = \");\n                        if (ts.isInternalModuleImportDeclaration(node)) {\n                            emit(node.moduleReference);\n                        }\n                        else {\n                            var literal = ts.getExternalModuleImportDeclarationExpression(node);\n                            write(\"require(\");\n                            emitStart(literal);\n                            emitLiteral(literal);\n                            emitEnd(literal);\n                            emitToken(16 /* CloseParenToken */, literal.end);\n                        }\n                        write(\";\");\n                        emitEnd(node);\n                        emitTrailingComments(node);\n                    }\n                }\n            }\n            function getExternalImportDeclarations(node) {\n                var result = [];\n                ts.forEach(node.statements, function (statement) {\n                    if (ts.isExternalModuleImportDeclaration(statement) && resolver.isReferencedImportDeclaration(statement)) {\n                        result.push(statement);\n                    }\n                });\n                return result;\n            }\n            function getFirstExportAssignment(sourceFile) {\n                return ts.forEach(sourceFile.statements, function (node) {\n                    if (node.kind === 192 /* ExportAssignment */) {\n                        return node;\n                    }\n                });\n            }\n            function emitAMDModule(node, startIndex) {\n                var imports = getExternalImportDeclarations(node);\n                writeLine();\n                write(\"define(\");\n                if (node.amdModuleName) {\n                    write(\"\\\"\" + node.amdModuleName + \"\\\", \");\n                }\n                write(\"[\\\"require\\\", \\\"exports\\\"\");\n                ts.forEach(imports, function (imp) {\n                    write(\", \");\n                    emitLiteral(ts.getExternalModuleImportDeclarationExpression(imp));\n                });\n                ts.forEach(node.amdDependencies, function (amdDependency) {\n                    var text = \"\\\"\" + amdDependency + \"\\\"\";\n                    write(\", \");\n                    write(text);\n                });\n                write(\"], function (require, exports\");\n                ts.forEach(imports, function (imp) {\n                    write(\", \");\n                    emit(imp.name);\n                });\n                write(\") {\");\n                increaseIndent();\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                var exportName = resolver.getExportAssignmentName(node);\n                if (exportName) {\n                    writeLine();\n                    var exportAssignement = getFirstExportAssignment(node);\n                    emitStart(exportAssignement);\n                    write(\"return \");\n                    emitStart(exportAssignement.exportName);\n                    write(exportName);\n                    emitEnd(exportAssignement.exportName);\n                    write(\";\");\n                    emitEnd(exportAssignement);\n                }\n                decreaseIndent();\n                writeLine();\n                write(\"});\");\n            }\n            function emitCommonJSModule(node, startIndex) {\n                emitCaptureThisForNodeIfNecessary(node);\n                emitLinesStartingAt(node.statements, startIndex);\n                var exportName = resolver.getExportAssignmentName(node);\n                if (exportName) {\n                    writeLine();\n                    var exportAssignement = getFirstExportAssignment(node);\n                    emitStart(exportAssignement);\n                    write(\"module.exports = \");\n                    emitStart(exportAssignement.exportName);\n                    write(exportName);\n                    emitEnd(exportAssignement.exportName);\n                    write(\";\");\n                    emitEnd(exportAssignement);\n                }\n            }\n            function emitDirectivePrologues(statements, startWithNewLine) {\n                for (var i = 0; i < statements.length; ++i) {\n                    if (ts.isPrologueDirective(statements[i])) {\n                        if (startWithNewLine || i > 0) {\n                            writeLine();\n                        }\n                        emit(statements[i]);\n                    }\n                    else {\n                        // return index of the first non prologue directive\n                        return i;\n                    }\n                }\n                return statements.length;\n            }\n            function emitSourceFile(node) {\n                currentSourceFile = node;\n                // Start new file on new line\n                writeLine();\n                emitDetachedComments(node);\n                // emit prologue directives prior to __extends\n                var startIndex = emitDirectivePrologues(node.statements, false);\n                if (!extendsEmitted && resolver.getNodeCheckFlags(node) & 8 /* EmitExtends */) {\n                    writeLine();\n                    write(\"var __extends = this.__extends || function (d, b) {\");\n                    increaseIndent();\n                    writeLine();\n                    write(\"for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\");\n                    writeLine();\n                    write(\"function __() { this.constructor = d; }\");\n                    writeLine();\n                    write(\"__.prototype = b.prototype;\");\n                    writeLine();\n                    write(\"d.prototype = new __();\");\n                    decreaseIndent();\n                    writeLine();\n                    write(\"};\");\n                    extendsEmitted = true;\n                }\n                if (ts.isExternalModule(node)) {\n                    if (compilerOptions.module === 2 /* AMD */) {\n                        emitAMDModule(node, startIndex);\n                    }\n                    else {\n                        emitCommonJSModule(node, startIndex);\n                    }\n                }\n                else {\n                    emitCaptureThisForNodeIfNecessary(node);\n                    emitLinesStartingAt(node.statements, startIndex);\n                }\n                emitLeadingComments(node.endOfFileToken);\n            }\n            function emitNode(node) {\n                if (!node) {\n                    return;\n                }\n                if (node.flags & 2 /* Ambient */) {\n                    return emitPinnedOrTripleSlashComments(node);\n                }\n                switch (node.kind) {\n                    case 63 /* Identifier */:\n                        return emitIdentifier(node);\n                    case 123 /* Parameter */:\n                        return emitParameter(node);\n                    case 127 /* GetAccessor */:\n                    case 128 /* SetAccessor */:\n                        return emitAccessor(node);\n                    case 91 /* ThisKeyword */:\n                        return emitThis(node);\n                    case 89 /* SuperKeyword */:\n                        return emitSuper(node);\n                    case 87 /* NullKeyword */:\n                        return write(\"null\");\n                    case 93 /* TrueKeyword */:\n                        return write(\"true\");\n                    case 78 /* FalseKeyword */:\n                        return write(\"false\");\n                    case 6 /* NumericLiteral */:\n                    case 7 /* StringLiteral */:\n                    case 8 /* RegularExpressionLiteral */:\n                    case 9 /* NoSubstitutionTemplateLiteral */:\n                    case 10 /* TemplateHead */:\n                    case 11 /* TemplateMiddle */:\n                    case 12 /* TemplateTail */:\n                        return emitLiteral(node);\n                    case 159 /* TemplateExpression */:\n                        return emitTemplateExpression(node);\n                    case 162 /* TemplateSpan */:\n                        return emitTemplateSpan(node);\n                    case 120 /* QualifiedName */:\n                        return emitQualifiedName(node);\n                    case 141 /* ArrayLiteralExpression */:\n                        return emitArrayLiteral(node);\n                    case 142 /* ObjectLiteralExpression */:\n                        return emitObjectLiteral(node);\n                    case 198 /* PropertyAssignment */:\n                        return emitPropertyAssignment(node);\n                    case 121 /* ComputedPropertyName */:\n                        return emitComputedPropertyName(node);\n                    case 143 /* PropertyAccessExpression */:\n                        return emitPropertyAccess(node);\n                    case 144 /* ElementAccessExpression */:\n                        return emitIndexedAccess(node);\n                    case 145 /* CallExpression */:\n                        return emitCallExpression(node);\n                    case 146 /* NewExpression */:\n                        return emitNewExpression(node);\n                    case 147 /* TaggedTemplateExpression */:\n                        return emitTaggedTemplateExpression(node);\n                    case 148 /* TypeAssertionExpression */:\n                        return emit(node.expression);\n                    case 149 /* ParenthesizedExpression */:\n                        return emitParenExpression(node);\n                    case 184 /* FunctionDeclaration */:\n                    case 150 /* FunctionExpression */:\n                    case 151 /* ArrowFunction */:\n                        return emitFunctionDeclaration(node);\n                    case 152 /* DeleteExpression */:\n                        return emitDeleteExpression(node);\n                    case 153 /* TypeOfExpression */:\n                        return emitTypeOfExpression(node);\n                    case 154 /* VoidExpression */:\n                        return emitVoidExpression(node);\n                    case 155 /* PrefixUnaryExpression */:\n                        return emitPrefixUnaryExpression(node);\n                    case 156 /* PostfixUnaryExpression */:\n                        return emitPostfixUnaryExpression(node);\n                    case 157 /* BinaryExpression */:\n                        return emitBinaryExpression(node);\n                    case 158 /* ConditionalExpression */:\n                        return emitConditionalExpression(node);\n                    case 161 /* OmittedExpression */:\n                        return;\n                    case 163 /* Block */:\n                    case 180 /* TryBlock */:\n                    case 181 /* FinallyBlock */:\n                    case 190 /* ModuleBlock */:\n                        return emitBlock(node);\n                    case 164 /* VariableStatement */:\n                        return emitVariableStatement(node);\n                    case 165 /* EmptyStatement */:\n                        return write(\";\");\n                    case 166 /* ExpressionStatement */:\n                        return emitExpressionStatement(node);\n                    case 167 /* IfStatement */:\n                        return emitIfStatement(node);\n                    case 168 /* DoStatement */:\n                        return emitDoStatement(node);\n                    case 169 /* WhileStatement */:\n                        return emitWhileStatement(node);\n                    case 170 /* ForStatement */:\n                        return emitForStatement(node);\n                    case 171 /* ForInStatement */:\n                        return emitForInStatement(node);\n                    case 172 /* ContinueStatement */:\n                    case 173 /* BreakStatement */:\n                        return emitBreakOrContinueStatement(node);\n                    case 174 /* ReturnStatement */:\n                        return emitReturnStatement(node);\n                    case 175 /* WithStatement */:\n                        return emitWithStatement(node);\n                    case 176 /* SwitchStatement */:\n                        return emitSwitchStatement(node);\n                    case 194 /* CaseClause */:\n                    case 195 /* DefaultClause */:\n                        return emitCaseOrDefaultClause(node);\n                    case 177 /* LabeledStatement */:\n                        return emitLabelledStatement(node);\n                    case 178 /* ThrowStatement */:\n                        return emitThrowStatement(node);\n                    case 179 /* TryStatement */:\n                        return emitTryStatement(node);\n                    case 197 /* CatchClause */:\n                        return emitCatchClause(node);\n                    case 182 /* DebuggerStatement */:\n                        return emitDebuggerStatement(node);\n                    case 183 /* VariableDeclaration */:\n                        return emitVariableDeclaration(node);\n                    case 185 /* ClassDeclaration */:\n                        return emitClassDeclaration(node);\n                    case 186 /* InterfaceDeclaration */:\n                        return emitInterfaceDeclaration(node);\n                    case 188 /* EnumDeclaration */:\n                        return emitEnumDeclaration(node);\n                    case 189 /* ModuleDeclaration */:\n                        return emitModuleDeclaration(node);\n                    case 191 /* ImportDeclaration */:\n                        return emitImportDeclaration(node);\n                    case 201 /* SourceFile */:\n                        return emitSourceFile(node);\n                }\n                // Emit node which needs to be emitted differently depended on ScriptTarget\n                if (compilerOptions.target < 2 /* ES6 */) {\n                    switch (node.kind) {\n                        case 199 /* ShorthandPropertyAssignment */:\n                            return emitDownlevelShorthandPropertyAssignment(node);\n                        case 125 /* Method */:\n                            return emitDownlevelMethod(node);\n                    }\n                }\n                else {\n                    // Emit node natively\n                    ts.Debug.assert(compilerOptions.target >= 2 /* ES6 */, \"Invalid ScriptTarget. We should emit as ES6 or above\");\n                    switch (node.kind) {\n                        case 199 /* ShorthandPropertyAssignment */:\n                            return emitShorthandPropertyAssignment(node);\n                        case 125 /* Method */:\n                            return emitMethod(node);\n                    }\n                }\n            }\n            function hasDetachedComments(pos) {\n                return detachedCommentsInfo !== undefined && detachedCommentsInfo[detachedCommentsInfo.length - 1].nodePos === pos;\n            }\n            function getLeadingCommentsWithoutDetachedComments() {\n                // get the leading comments from detachedPos\n                var leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, detachedCommentsInfo[detachedCommentsInfo.length - 1].detachedCommentEndPos);\n                if (detachedCommentsInfo.length - 1) {\n                    detachedCommentsInfo.pop();\n                }\n                else {\n                    detachedCommentsInfo = undefined;\n                }\n                return leadingComments;\n            }\n            function getLeadingCommentsToEmit(node) {\n                // Emit the leading comments only if the parent's pos doesn't match because parent should take care of emitting these comments\n                if (node.parent.kind === 201 /* SourceFile */ || node.pos !== node.parent.pos) {\n                    var leadingComments;\n                    if (hasDetachedComments(node.pos)) {\n                        // get comments without detached comments\n                        leadingComments = getLeadingCommentsWithoutDetachedComments();\n                    }\n                    else {\n                        // get the leading comments from the node\n                        leadingComments = ts.getLeadingCommentRangesOfNode(node, currentSourceFile);\n                    }\n                    return leadingComments;\n                }\n            }\n            function emitLeadingDeclarationComments(node) {\n                var leadingComments = getLeadingCommentsToEmit(node);\n                emitNewLineBeforeLeadingComments(currentSourceFile, writer, node, leadingComments);\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\n                emitComments(currentSourceFile, writer, leadingComments, true, newLine, writeComment);\n            }\n            function emitTrailingDeclarationComments(node) {\n                // Emit the trailing comments only if the parent's end doesn't match\n                if (node.parent.kind === 201 /* SourceFile */ || node.end !== node.parent.end) {\n                    var trailingComments = ts.getTrailingCommentRanges(currentSourceFile.text, node.end);\n                    // trailing comments are emitted at space/*trailing comment1 */space/*trailing comment*/\n                    emitComments(currentSourceFile, writer, trailingComments, false, newLine, writeComment);\n                }\n            }\n            function emitLeadingCommentsOfLocalPosition(pos) {\n                var leadingComments;\n                if (hasDetachedComments(pos)) {\n                    // get comments without detached comments\n                    leadingComments = getLeadingCommentsWithoutDetachedComments();\n                }\n                else {\n                    // get the leading comments from the node\n                    leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, pos);\n                }\n                emitNewLineBeforeLeadingComments(currentSourceFile, writer, { pos: pos, end: pos }, leadingComments);\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\n                emitComments(currentSourceFile, writer, leadingComments, true, newLine, writeComment);\n            }\n            function emitDetachedCommentsAtPosition(node) {\n                var leadingComments = ts.getLeadingCommentRanges(currentSourceFile.text, node.pos);\n                if (leadingComments) {\n                    var detachedComments = [];\n                    var lastComment;\n                    ts.forEach(leadingComments, function (comment) {\n                        if (lastComment) {\n                            var lastCommentLine = getLineOfLocalPosition(currentSourceFile, lastComment.end);\n                            var commentLine = getLineOfLocalPosition(currentSourceFile, comment.pos);\n                            if (commentLine >= lastCommentLine + 2) {\n                                // There was a blank line between the last comment and this comment.  This\n                                // comment is not part of the copyright comments.  Return what we have so \n                                // far.\n                                return detachedComments;\n                            }\n                        }\n                        detachedComments.push(comment);\n                        lastComment = comment;\n                    });\n                    if (detachedComments.length) {\n                        // All comments look like they could have been part of the copyright header.  Make\n                        // sure there is at least one blank line between it and the node.  If not, it's not\n                        // a copyright header.\n                        var lastCommentLine = getLineOfLocalPosition(currentSourceFile, detachedComments[detachedComments.length - 1].end);\n                        var astLine = getLineOfLocalPosition(currentSourceFile, ts.skipTrivia(currentSourceFile.text, node.pos));\n                        if (astLine >= lastCommentLine + 2) {\n                            // Valid detachedComments\n                            emitNewLineBeforeLeadingComments(currentSourceFile, writer, node, leadingComments);\n                            emitComments(currentSourceFile, writer, detachedComments, true, newLine, writeComment);\n                            var currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: detachedComments[detachedComments.length - 1].end };\n                            if (detachedCommentsInfo) {\n                                detachedCommentsInfo.push(currentDetachedCommentInfo);\n                            }\n                            else {\n                                detachedCommentsInfo = [currentDetachedCommentInfo];\n                            }\n                        }\n                    }\n                }\n            }\n            function emitPinnedOrTripleSlashCommentsOfNode(node) {\n                var pinnedComments = ts.filter(getLeadingCommentsToEmit(node), isPinnedOrTripleSlashComment);\n                function isPinnedOrTripleSlashComment(comment) {\n                    if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 42 /* asterisk */) {\n                        return currentSourceFile.text.charCodeAt(comment.pos + 2) === 33 /* exclamation */;\n                    }\n                    else if (currentSourceFile.text.charCodeAt(comment.pos + 1) === 47 /* slash */ && comment.pos + 2 < comment.end && currentSourceFile.text.charCodeAt(comment.pos + 2) === 47 /* slash */ && currentSourceFile.text.substring(comment.pos, comment.end).match(ts.fullTripleSlashReferencePathRegEx)) {\n                        return true;\n                    }\n                }\n                emitNewLineBeforeLeadingComments(currentSourceFile, writer, node, pinnedComments);\n                // Leading comments are emitted at /*leading comment1 */space/*leading comment*/space\n                emitComments(currentSourceFile, writer, pinnedComments, true, newLine, writeComment);\n            }\n            if (compilerOptions.sourceMap) {\n                initializeEmitterWithSourceMaps();\n            }\n            if (root) {\n                emit(root);\n            }\n            else {\n                ts.forEach(program.getSourceFiles(), function (sourceFile) {\n                    if (!isExternalModuleOrDeclarationFile(sourceFile)) {\n                        emit(sourceFile);\n                    }\n                });\n            }\n            writeLine();\n            writeEmittedFiles(writer.getText(), compilerOptions.emitBOM);\n        }\n        function writeDeclarationFile(jsFilePath, sourceFile) {\n            var emitDeclarationResult = emitDeclarations(program, resolver, diagnostics, jsFilePath, sourceFile);\n            // TODO(shkamat): Should we not write any declaration file if any of them can produce error, \n            // or should we just not write this file like we are doing now\n            if (!emitDeclarationResult.reportedDeclarationError) {\n                var declarationOutput = emitDeclarationResult.referencePathsOutput;\n                // apply additions\n                var appliedSyncOutputPos = 0;\n                ts.forEach(emitDeclarationResult.aliasDeclarationEmitInfo, function (aliasEmitInfo) {\n                    if (aliasEmitInfo.asynchronousOutput) {\n                        declarationOutput += emitDeclarationResult.synchronousDeclarationOutput.substring(appliedSyncOutputPos, aliasEmitInfo.outputPos);\n                        declarationOutput += aliasEmitInfo.asynchronousOutput;\n                        appliedSyncOutputPos = aliasEmitInfo.outputPos;\n                    }\n                });\n                declarationOutput += emitDeclarationResult.synchronousDeclarationOutput.substring(appliedSyncOutputPos);\n                writeFile(compilerHost, diagnostics, ts.removeFileExtension(jsFilePath) + \".d.ts\", declarationOutput, compilerOptions.emitBOM);\n            }\n        }\n        var hasSemanticErrors = false;\n        var isEmitBlocked = false;\n        if (targetSourceFile === undefined) {\n            // No targetSourceFile is specified (e.g. calling emitter from batch compiler)\n            hasSemanticErrors = resolver.hasSemanticErrors();\n            isEmitBlocked = resolver.isEmitBlocked();\n            ts.forEach(program.getSourceFiles(), function (sourceFile) {\n                if (shouldEmitToOwnFile(sourceFile, compilerOptions)) {\n                    var jsFilePath = getOwnEmitOutputFilePath(sourceFile, program, \".js\");\n                    emitFile(jsFilePath, sourceFile);\n                }\n            });\n            if (compilerOptions.out) {\n                emitFile(compilerOptions.out);\n            }\n        }\n        else {\n            // targetSourceFile is specified (e.g calling emitter from language service or calling getSemanticDiagnostic from language service)\n            if (shouldEmitToOwnFile(targetSourceFile, compilerOptions)) {\n                // If shouldEmitToOwnFile returns true or targetSourceFile is an external module file, then emit targetSourceFile in its own output file\n                hasSemanticErrors = resolver.hasSemanticErrors(targetSourceFile);\n                isEmitBlocked = resolver.isEmitBlocked(targetSourceFile);\n                var jsFilePath = getOwnEmitOutputFilePath(targetSourceFile, program, \".js\");\n                emitFile(jsFilePath, targetSourceFile);\n            }\n            else if (!ts.isDeclarationFile(targetSourceFile) && compilerOptions.out) {\n                // Otherwise, if --out is specified and targetSourceFile is not a declaration file,\n                // Emit all, non-external-module file, into one single output file\n                ts.forEach(program.getSourceFiles(), function (sourceFile) {\n                    if (!shouldEmitToOwnFile(sourceFile, compilerOptions)) {\n                        hasSemanticErrors = hasSemanticErrors || resolver.hasSemanticErrors(sourceFile);\n                        isEmitBlocked = isEmitBlocked || resolver.isEmitBlocked(sourceFile);\n                    }\n                });\n                emitFile(compilerOptions.out);\n            }\n        }\n        function emitFile(jsFilePath, sourceFile) {\n            if (!isEmitBlocked) {\n                emitJavaScript(jsFilePath, sourceFile);\n                if (!hasSemanticErrors && compilerOptions.declaration) {\n                    writeDeclarationFile(jsFilePath, sourceFile);\n                }\n            }\n        }\n        // Sort and make the unique list of diagnostics\n        diagnostics.sort(ts.compareDiagnostics);\n        diagnostics = ts.deduplicateSortedDiagnostics(diagnostics);\n        // Update returnCode if there is any EmitterError\n        var hasEmitterError = ts.forEach(diagnostics, function (diagnostic) { return diagnostic.category === 1 /* Error */; });\n        // Check and update returnCode for syntactic and semantic\n        var emitResultStatus;\n        if (isEmitBlocked) {\n            emitResultStatus = 1 /* AllOutputGenerationSkipped */;\n        }\n        else if (hasEmitterError) {\n            emitResultStatus = 4 /* EmitErrorsEncountered */;\n        }\n        else if (hasSemanticErrors && compilerOptions.declaration) {\n            emitResultStatus = 3 /* DeclarationGenerationSkipped */;\n        }\n        else if (hasSemanticErrors && !compilerOptions.declaration) {\n            emitResultStatus = 2 /* JSGeneratedWithSemanticErrors */;\n        }\n        else {\n            emitResultStatus = 0 /* Succeeded */;\n        }\n        return {\n            emitResultStatus: emitResultStatus,\n            diagnostics: diagnostics,\n            sourceMaps: sourceMapDataList\n        };\n    }\n    ts.emitFiles = emitFiles;\n})(ts || (ts = {}));\n/// <reference path=\"types.ts\"/>\n/// <reference path=\"core.ts\"/>\n/// <reference path=\"scanner.ts\"/>\n/// <reference path=\"parser.ts\"/>\n/// <reference path=\"binder.ts\"/>\n/// <reference path=\"emitter.ts\"/>\n/// <reference path=\"utilities.ts\"/>\nvar ts;\n(function (ts) {\n    var nextSymbolId = 1;\n    var nextNodeId = 1;\n    var nextMergeId = 1;\n    /// fullTypeCheck denotes if this instance of the typechecker will be used to get semantic diagnostics.\n    /// If fullTypeCheck === true,  then the typechecker should do every possible check to produce all errors\n    /// If fullTypeCheck === false, the typechecker can take shortcuts and skip checks that only produce errors.\n    /// NOTE: checks that somehow affect decisions being made during typechecking should be executed in both cases.\n    function createTypeChecker(program, fullTypeCheck) {\n        var Symbol = ts.objectAllocator.getSymbolConstructor();\n        var Type = ts.objectAllocator.getTypeConstructor();\n        var Signature = ts.objectAllocator.getSignatureConstructor();\n        var typeCount = 0;\n        var emptyArray = [];\n        var emptySymbols = {};\n        var compilerOptions = program.getCompilerOptions();\n        var checker = {\n            getProgram: function () { return program; },\n            getNodeCount: function () { return ts.sum(program.getSourceFiles(), \"nodeCount\"); },\n            getIdentifierCount: function () { return ts.sum(program.getSourceFiles(), \"identifierCount\"); },\n            getSymbolCount: function () { return ts.sum(program.getSourceFiles(), \"symbolCount\"); },\n            getTypeCount: function () { return typeCount; },\n            isUndefinedSymbol: function (symbol) { return symbol === undefinedSymbol; },\n            isArgumentsSymbol: function (symbol) { return symbol === argumentsSymbol; },\n            emitFiles: invokeEmitter,\n            getDiagnostics: getDiagnostics,\n            getDeclarationDiagnostics: getDeclarationDiagnostics,\n            getGlobalDiagnostics: getGlobalDiagnostics,\n            getTypeOfSymbolAtLocation: getTypeOfSymbolAtLocation,\n            getDeclaredTypeOfSymbol: getDeclaredTypeOfSymbol,\n            getPropertiesOfType: getPropertiesOfType,\n            getPropertyOfType: getPropertyOfType,\n            getSignaturesOfType: getSignaturesOfType,\n            getIndexTypeOfType: getIndexTypeOfType,\n            getReturnTypeOfSignature: getReturnTypeOfSignature,\n            getSymbolsInScope: getSymbolsInScope,\n            getSymbolAtLocation: getSymbolAtLocation,\n            getShorthandAssignmentValueSymbol: getShorthandAssignmentValueSymbol,\n            getTypeAtLocation: getTypeAtLocation,\n            typeToString: typeToString,\n            getSymbolDisplayBuilder: getSymbolDisplayBuilder,\n            symbolToString: symbolToString,\n            getAugmentedPropertiesOfType: getAugmentedPropertiesOfType,\n            getRootSymbols: getRootSymbols,\n            getContextualType: getContextualType,\n            getFullyQualifiedName: getFullyQualifiedName,\n            getResolvedSignature: getResolvedSignature,\n            getEnumMemberValue: getEnumMemberValue,\n            isValidPropertyAccess: isValidPropertyAccess,\n            getSignatureFromDeclaration: getSignatureFromDeclaration,\n            isImplementationOfOverload: isImplementationOfOverload,\n            getAliasedSymbol: resolveImport,\n            hasEarlyErrors: hasEarlyErrors,\n            isEmitBlocked: isEmitBlocked,\n        };\n        var undefinedSymbol = createSymbol(4 /* Property */ | 268435456 /* Transient */, \"undefined\");\n        var argumentsSymbol = createSymbol(4 /* Property */ | 268435456 /* Transient */, \"arguments\");\n        var unknownSymbol = createSymbol(4 /* Property */ | 268435456 /* Transient */, \"unknown\");\n        var resolvingSymbol = createSymbol(268435456 /* Transient */, \"__resolving__\");\n        var anyType = createIntrinsicType(1 /* Any */, \"any\");\n        var stringType = createIntrinsicType(2 /* String */, \"string\");\n        var numberType = createIntrinsicType(4 /* Number */, \"number\");\n        var booleanType = createIntrinsicType(8 /* Boolean */, \"boolean\");\n        var voidType = createIntrinsicType(16 /* Void */, \"void\");\n        var undefinedType = createIntrinsicType(32 /* Undefined */, \"undefined\");\n        var nullType = createIntrinsicType(64 /* Null */, \"null\");\n        var unknownType = createIntrinsicType(1 /* Any */, \"unknown\");\n        var resolvingType = createIntrinsicType(1 /* Any */, \"__resolving__\");\n        var emptyObjectType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\n        var anyFunctionType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\n        var noConstraintType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\n        var inferenceFailureType = createAnonymousType(undefined, emptySymbols, emptyArray, emptyArray, undefined, undefined);\n        var anySignature = createSignature(undefined, undefined, emptyArray, anyType, 0, false, false);\n        var unknownSignature = createSignature(undefined, undefined, emptyArray, unknownType, 0, false, false);\n        var globals = {};\n        var globalArraySymbol;\n        var globalObjectType;\n        var globalFunctionType;\n        var globalArrayType;\n        var globalStringType;\n        var globalNumberType;\n        var globalBooleanType;\n        var globalRegExpType;\n        var globalTemplateStringsArrayType;\n        var tupleTypes = {};\n        var unionTypes = {};\n        var stringLiteralTypes = {};\n        var emitExtends = false;\n        var mergedSymbols = [];\n        var symbolLinks = [];\n        var nodeLinks = [];\n        var potentialThisCollisions = [];\n        var diagnostics = [];\n        var diagnosticsModified = false;\n        function addDiagnostic(diagnostic) {\n            diagnostics.push(diagnostic);\n            diagnosticsModified = true;\n        }\n        function error(location, message, arg0, arg1, arg2) {\n            var diagnostic = location ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2) : ts.createCompilerDiagnostic(message, arg0, arg1, arg2);\n            addDiagnostic(diagnostic);\n        }\n        function createSymbol(flags, name) {\n            return new Symbol(flags, name);\n        }\n        function getExcludedSymbolFlags(flags) {\n            var result = 0;\n            if (flags & 2 /* BlockScopedVariable */)\n                result |= 107455 /* BlockScopedVariableExcludes */;\n            if (flags & 1 /* FunctionScopedVariable */)\n                result |= 107454 /* FunctionScopedVariableExcludes */;\n            if (flags & 4 /* Property */)\n                result |= 107455 /* PropertyExcludes */;\n            if (flags & 8 /* EnumMember */)\n                result |= 107455 /* EnumMemberExcludes */;\n            if (flags & 16 /* Function */)\n                result |= 106927 /* FunctionExcludes */;\n            if (flags & 32 /* Class */)\n                result |= 3258879 /* ClassExcludes */;\n            if (flags & 64 /* Interface */)\n                result |= 3152288 /* InterfaceExcludes */;\n            if (flags & 256 /* RegularEnum */)\n                result |= 3258623 /* RegularEnumExcludes */;\n            if (flags & 128 /* ConstEnum */)\n                result |= 3259263 /* ConstEnumExcludes */;\n            if (flags & 512 /* ValueModule */)\n                result |= 106639 /* ValueModuleExcludes */;\n            if (flags & 8192 /* Method */)\n                result |= 99263 /* MethodExcludes */;\n            if (flags & 32768 /* GetAccessor */)\n                result |= 41919 /* GetAccessorExcludes */;\n            if (flags & 65536 /* SetAccessor */)\n                result |= 74687 /* SetAccessorExcludes */;\n            if (flags & 1048576 /* TypeParameter */)\n                result |= 2103776 /* TypeParameterExcludes */;\n            if (flags & 2097152 /* TypeAlias */)\n                result |= 3152352 /* TypeAliasExcludes */;\n            if (flags & 33554432 /* Import */)\n                result |= 33554432 /* ImportExcludes */;\n            return result;\n        }\n        function recordMergedSymbol(target, source) {\n            if (!source.mergeId)\n                source.mergeId = nextMergeId++;\n            mergedSymbols[source.mergeId] = target;\n        }\n        function cloneSymbol(symbol) {\n            var result = createSymbol(symbol.flags | 134217728 /* Merged */, symbol.name);\n            result.declarations = symbol.declarations.slice(0);\n            result.parent = symbol.parent;\n            if (symbol.valueDeclaration)\n                result.valueDeclaration = symbol.valueDeclaration;\n            if (symbol.constEnumOnlyModule)\n                result.constEnumOnlyModule = true;\n            if (symbol.members)\n                result.members = cloneSymbolTable(symbol.members);\n            if (symbol.exports)\n                result.exports = cloneSymbolTable(symbol.exports);\n            recordMergedSymbol(result, symbol);\n            return result;\n        }\n        function extendSymbol(target, source) {\n            if (!(target.flags & getExcludedSymbolFlags(source.flags))) {\n                if (source.flags & 512 /* ValueModule */ && target.flags & 512 /* ValueModule */ && target.constEnumOnlyModule && !source.constEnumOnlyModule) {\n                    // reset flag when merging instantiated module into value module that has only const enums\n                    target.constEnumOnlyModule = false;\n                }\n                target.flags |= source.flags;\n                if (!target.valueDeclaration && source.valueDeclaration)\n                    target.valueDeclaration = source.valueDeclaration;\n                ts.forEach(source.declarations, function (node) {\n                    target.declarations.push(node);\n                });\n                if (source.members) {\n                    if (!target.members)\n                        target.members = {};\n                    extendSymbolTable(target.members, source.members);\n                }\n                if (source.exports) {\n                    if (!target.exports)\n                        target.exports = {};\n                    extendSymbolTable(target.exports, source.exports);\n                }\n                recordMergedSymbol(target, source);\n            }\n            else {\n                var message = target.flags & 2 /* BlockScopedVariable */ || source.flags & 2 /* BlockScopedVariable */ ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0 : ts.Diagnostics.Duplicate_identifier_0;\n                ts.forEach(source.declarations, function (node) {\n                    error(node.name ? node.name : node, message, symbolToString(source));\n                });\n                ts.forEach(target.declarations, function (node) {\n                    error(node.name ? node.name : node, message, symbolToString(source));\n                });\n            }\n        }\n        function cloneSymbolTable(symbolTable) {\n            var result = {};\n            for (var id in symbolTable) {\n                if (ts.hasProperty(symbolTable, id)) {\n                    result[id] = symbolTable[id];\n                }\n            }\n            return result;\n        }\n        function extendSymbolTable(target, source) {\n            for (var id in source) {\n                if (ts.hasProperty(source, id)) {\n                    if (!ts.hasProperty(target, id)) {\n                        target[id] = source[id];\n                    }\n                    else {\n                        var symbol = target[id];\n                        if (!(symbol.flags & 134217728 /* Merged */)) {\n                            target[id] = symbol = cloneSymbol(symbol);\n                        }\n                        extendSymbol(symbol, source[id]);\n                    }\n                }\n            }\n        }\n        function getSymbolLinks(symbol) {\n            if (symbol.flags & 268435456 /* Transient */)\n                return symbol;\n            if (!symbol.id)\n                symbol.id = nextSymbolId++;\n            return symbolLinks[symbol.id] || (symbolLinks[symbol.id] = {});\n        }\n        function getNodeLinks(node) {\n            if (!node.id)\n                node.id = nextNodeId++;\n            return nodeLinks[node.id] || (nodeLinks[node.id] = {});\n        }\n        function getSourceFile(node) {\n            return ts.getAncestor(node, 201 /* SourceFile */);\n        }\n        function isGlobalSourceFile(node) {\n            return node.kind === 201 /* SourceFile */ && !ts.isExternalModule(node);\n        }\n        function getSymbol(symbols, name, meaning) {\n            if (meaning && ts.hasProperty(symbols, name)) {\n                var symbol = symbols[name];\n                ts.Debug.assert((symbol.flags & 67108864 /* Instantiated */) === 0, \"Should never get an instantiated symbol here.\");\n                if (symbol.flags & meaning) {\n                    return symbol;\n                }\n                if (symbol.flags & 33554432 /* Import */) {\n                    var target = resolveImport(symbol);\n                    // unknown symbol will mean that there were reported error during import resolution\n                    // treat it as positive answer to avoid cascading errors\n                    if (target === unknownSymbol || target.flags & meaning) {\n                        return symbol;\n                    }\n                }\n            }\n            // return undefined if we can't find a symbol.\n        }\n        /** Returns true if node1 is defined before node 2**/\n        function isDefinedBefore(node1, node2) {\n            var file1 = ts.getSourceFileOfNode(node1);\n            var file2 = ts.getSourceFileOfNode(node2);\n            if (file1 === file2) {\n                return node1.pos <= node2.pos;\n            }\n            if (!compilerOptions.out) {\n                return true;\n            }\n            var sourceFiles = program.getSourceFiles();\n            return sourceFiles.indexOf(file1) <= sourceFiles.indexOf(file2);\n        }\n        // Resolve a given name for a given meaning at a given location. An error is reported if the name was not found and\n        // the nameNotFoundMessage argument is not undefined. Returns the resolved symbol, or undefined if no symbol with\n        // the given name can be found.\n        function resolveName(location, name, meaning, nameNotFoundMessage, nameArg) {\n            var result;\n            var lastLocation;\n            var propertyWithInvalidInitializer;\n            var errorLocation = location;\n            loop: while (location) {\n                // Locals of a source file are not in scope (because they get merged into the global symbol table)\n                if (location.locals && !isGlobalSourceFile(location)) {\n                    if (result = getSymbol(location.locals, name, meaning)) {\n                        break loop;\n                    }\n                }\n                switch (location.kind) {\n                    case 201 /* SourceFile */:\n                        if (!ts.isExternalModule(location))\n                            break;\n                    case 189 /* ModuleDeclaration */:\n                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & 35653619 /* ModuleMember */)) {\n                            break loop;\n                        }\n                        break;\n                    case 188 /* EnumDeclaration */:\n                        if (result = getSymbol(getSymbolOfNode(location).exports, name, meaning & 8 /* EnumMember */)) {\n                            break loop;\n                        }\n                        break;\n                    case 124 /* Property */:\n                        // TypeScript 1.0 spec (April 2014): 8.4.1\n                        // Initializer expressions for instance member variables are evaluated in the scope \n                        // of the class constructor body but are not permitted to reference parameters or \n                        // local variables of the constructor. This effectively means that entities from outer scopes \n                        // by the same name as a constructor parameter or local variable are inaccessible \n                        // in initializer expressions for instance member variables.\n                        if (location.parent.kind === 185 /* ClassDeclaration */ && !(location.flags & 128 /* Static */)) {\n                            var ctor = findConstructorDeclaration(location.parent);\n                            if (ctor && ctor.locals) {\n                                if (getSymbol(ctor.locals, name, meaning & 107455 /* Value */)) {\n                                    // Remember the property node, it will be used later to report appropriate error\n                                    propertyWithInvalidInitializer = location;\n                                }\n                            }\n                        }\n                        break;\n                    case 185 /* ClassDeclaration */:\n                    case 186 /* InterfaceDeclaration */:\n                        if (result = getSymbol(getSymbolOfNode(location).members, name, meaning & 3152352 /* Type */)) {\n                            if (lastLocation && lastLocation.flags & 128 /* Static */) {\n                                // TypeScript 1.0 spec (April 2014): 3.4.1\n                                // The scope of a type parameter extends over the entire declaration with which the type\n                                // parameter list is associated, with the exception of static member declarations in classes.\n                                error(errorLocation, ts.Diagnostics.Static_members_cannot_reference_class_type_parameters);\n                                return undefined;\n                            }\n                            break loop;\n                        }\n                        break;\n                    case 125 /* Method */:\n                    case 126 /* Constructor */:\n                    case 127 /* GetAccessor */:\n                    case 128 /* SetAccessor */:\n                    case 184 /* FunctionDeclaration */:\n                    case 151 /* ArrowFunction */:\n                        if (name === \"arguments\") {\n                            result = argumentsSymbol;\n                            break loop;\n                        }\n                        break;\n                    case 150 /* FunctionExpression */:\n                        if (name === \"arguments\") {\n                            result = argumentsSymbol;\n                            break loop;\n                        }\n                        var id = location.name;\n                        if (id && name === id.text) {\n                            result = location.symbol;\n                            break loop;\n                        }\n                        break;\n                    case 197 /* CatchClause */:\n                        var id = location.name;\n                        if (name === id.text) {\n                            result = location.symbol;\n                            break loop;\n                        }\n                        break;\n                }\n                lastLocation = location;\n                location = location.parent;\n            }\n            if (!result) {\n                result = getSymbol(globals, name, meaning);\n            }\n            if (!result) {\n                if (nameNotFoundMessage) {\n                    error(errorLocation, nameNotFoundMessage, typeof nameArg === \"string\" ? nameArg : ts.declarationNameToString(nameArg));\n                }\n                return undefined;\n            }\n            // Perform extra checks only if error reporting was requested\n            if (nameNotFoundMessage) {\n                if (propertyWithInvalidInitializer) {\n                    // We have a match, but the reference occurred within a property initializer and the identifier also binds\n                    // to a local variable in the constructor where the code will be emitted.\n                    var propertyName = propertyWithInvalidInitializer.name;\n                    error(errorLocation, ts.Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, ts.declarationNameToString(propertyName), typeof nameArg === \"string\" ? nameArg : ts.declarationNameToString(nameArg));\n                    return undefined;\n                }\n                if (result.flags & 2 /* BlockScopedVariable */) {\n                    // Block-scoped variables cannot be used before their definition\n                    var declaration = ts.forEach(result.declarations, function (d) { return d.flags & 6144 /* BlockScoped */ ? d : undefined; });\n                    ts.Debug.assert(declaration !== undefined, \"Block-scoped variable declaration is undefined\");\n                    if (!isDefinedBefore(declaration, errorLocation)) {\n                        error(errorLocation, ts.Diagnostics.Block_scoped_variable_0_used_before_its_declaration, ts.declarationNameToString(declaration.name));\n                    }\n                }\n            }\n            return result;\n        }\n        function resolveImport(symbol) {\n            ts.Debug.assert((symbol.flags & 33554432 /* Import */) !== 0, \"Should only get Imports here.\");\n            var links = getSymbolLinks(symbol);\n            if (!links.target) {\n                links.target = resolvingSymbol;\n                var node = ts.getDeclarationOfKind(symbol, 191 /* ImportDeclaration */);\n                var target = node.moduleReference.kind === 193 /* ExternalModuleReference */ ? resolveExternalModuleName(node, ts.getExternalModuleImportDeclarationExpression(node)) : getSymbolOfPartOfRightHandSideOfImport(node.moduleReference, node);\n                if (links.target === resolvingSymbol) {\n                    links.target = target || unknownSymbol;\n                }\n                else {\n                    error(node, ts.Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));\n                }\n            }\n            else if (links.target === resolvingSymbol) {\n                links.target = unknownSymbol;\n            }\n            return links.target;\n        }\n        // This function is only for imports with entity names\n        function getSymbolOfPartOfRightHandSideOfImport(entityName, importDeclaration) {\n            if (!importDeclaration) {\n                importDeclaration = ts.getAncestor(entityName, 191 /* ImportDeclaration */);\n                ts.Debug.assert(importDeclaration !== undefined);\n            }\n            // There are three things we might try to look for. In the following examples,\n            // the search term is enclosed in |...|:\n            //\n            //     import a = |b|; // Namespace\n            //     import a = |b.c|; // Value, type, namespace\n            //     import a = |b.c|.d; // Namespace\n            if (entityName.kind === 63 /* Identifier */ && isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {\n                entityName = entityName.parent;\n            }\n            // Check for case 1 and 3 in the above example\n            if (entityName.kind === 63 /* Identifier */ || entityName.parent.kind === 120 /* QualifiedName */) {\n                return resolveEntityName(importDeclaration, entityName, 1536 /* Namespace */);\n            }\n            else {\n                // Case 2 in above example\n                // entityName.kind could be a QualifiedName or a Missing identifier\n                ts.Debug.assert(entityName.parent.kind === 191 /* ImportDeclaration */);\n                return resolveEntityName(importDeclaration, entityName, 107455 /* Value */ | 3152352 /* Type */ | 1536 /* Namespace */);\n            }\n        }\n        function getFullyQualifiedName(symbol) {\n            return symbol.parent ? getFullyQualifiedName(symbol.parent) + \".\" + symbolToString(symbol) : symbolToString(symbol);\n        }\n        // Resolves a qualified name and any involved import aliases\n        function resolveEntityName(location, name, meaning) {\n            if (ts.getFullWidth(name) === 0) {\n                return undefined;\n            }\n            if (name.kind === 63 /* Identifier */) {\n                var symbol = resolveName(location, name.text, meaning, ts.Diagnostics.Cannot_find_name_0, name);\n                if (!symbol) {\n                    return;\n                }\n            }\n            else if (name.kind === 120 /* QualifiedName */) {\n                var namespace = resolveEntityName(location, name.left, 1536 /* Namespace */);\n                if (!namespace || namespace === unknownSymbol || ts.getFullWidth(name.right) === 0)\n                    return;\n                var symbol = getSymbol(namespace.exports, name.right.text, meaning);\n                if (!symbol) {\n                    error(location, ts.Diagnostics.Module_0_has_no_exported_member_1, getFullyQualifiedName(namespace), ts.declarationNameToString(name.right));\n                    return;\n                }\n            }\n            ts.Debug.assert((symbol.flags & 67108864 /* Instantiated */) === 0, \"Should never get an instantiated symbol here.\");\n            return symbol.flags & meaning ? symbol : resolveImport(symbol);\n        }\n        function isExternalModuleNameRelative(moduleName) {\n            // TypeScript 1.0 spec (April 2014): 11.2.1\n            // An external module name is \"relative\" if the first term is \".\" or \"..\".\n            return moduleName.substr(0, 2) === \"./\" || moduleName.substr(0, 3) === \"../\" || moduleName.substr(0, 2) === \".\\\\\" || moduleName.substr(0, 3) === \"..\\\\\";\n        }\n        function resolveExternalModuleName(location, moduleReferenceExpression) {\n            if (moduleReferenceExpression.kind !== 7 /* StringLiteral */) {\n                return;\n            }\n            var moduleReferenceLiteral = moduleReferenceExpression;\n            var searchPath = ts.getDirectoryPath(getSourceFile(location).filename);\n            // Module names are escaped in our symbol table.  However, string literal values aren't.\n            // Escape the name in the \"require(...)\" clause to ensure we find the right symbol.\n            var moduleName = ts.escapeIdentifier(moduleReferenceLiteral.text);\n            if (!moduleName)\n                return;\n            var isRelative = isExternalModuleNameRelative(moduleName);\n            if (!isRelative) {\n                var symbol = getSymbol(globals, '\"' + moduleName + '\"', 512 /* ValueModule */);\n                if (symbol) {\n                    return getResolvedExportSymbol(symbol);\n                }\n            }\n            while (true) {\n                var filename = ts.normalizePath(ts.combinePaths(searchPath, moduleName));\n                var sourceFile = program.getSourceFile(filename + \".ts\") || program.getSourceFile(filename + \".d.ts\");\n                if (sourceFile || isRelative)\n                    break;\n                var parentPath = ts.getDirectoryPath(searchPath);\n                if (parentPath === searchPath)\n                    break;\n                searchPath = parentPath;\n            }\n            if (sourceFile) {\n                if (sourceFile.symbol) {\n                    return getResolvedExportSymbol(sourceFile.symbol);\n                }\n                error(moduleReferenceLiteral, ts.Diagnostics.File_0_is_not_an_external_module, sourceFile.filename);\n                return;\n            }\n            error(moduleReferenceLiteral, ts.Diagnostics.Cannot_find_external_module_0, moduleName);\n        }\n        function getResolvedExportSymbol(moduleSymbol) {\n            var symbol = getExportAssignmentSymbol(moduleSymbol);\n            if (symbol) {\n                if (symbol.flags & (107455 /* Value */ | 3152352 /* Type */ | 1536 /* Namespace */)) {\n                    return symbol;\n                }\n                if (symbol.flags & 33554432 /* Import */) {\n                    return resolveImport(symbol);\n                }\n            }\n            return moduleSymbol;\n        }\n        function getExportAssignmentSymbol(symbol) {\n            checkTypeOfExportAssignmentSymbol(symbol);\n            var symbolLinks = getSymbolLinks(symbol);\n            return symbolLinks.exportAssignSymbol === unknownSymbol ? undefined : symbolLinks.exportAssignSymbol;\n        }\n        function checkTypeOfExportAssignmentSymbol(containerSymbol) {\n            var symbolLinks = getSymbolLinks(containerSymbol);\n            if (!symbolLinks.exportAssignSymbol) {\n                var exportInformation = collectExportInformationForSourceFileOrModule(containerSymbol);\n                if (exportInformation.exportAssignments.length) {\n                    if (exportInformation.exportAssignments.length > 1) {\n                        // TypeScript 1.0 spec (April 2014): 11.2.4\n                        // It is an error for an external module to contain more than one export assignment.\n                        ts.forEach(exportInformation.exportAssignments, function (node) { return error(node, ts.Diagnostics.A_module_cannot_have_more_than_one_export_assignment); });\n                    }\n                    var node = exportInformation.exportAssignments[0];\n                    if (exportInformation.hasExportedMember) {\n                        // TypeScript 1.0 spec (April 2014): 11.2.3\n                        // If an external module contains an export assignment it is an error \n                        // for the external module to also contain export declarations.\n                        // The two types of exports are mutually exclusive.\n                        error(node, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);\n                    }\n                    if (node.exportName.text) {\n                        var meaning = 107455 /* Value */ | 3152352 /* Type */ | 1536 /* Namespace */;\n                        var exportSymbol = resolveName(node, node.exportName.text, meaning, ts.Diagnostics.Cannot_find_name_0, node.exportName);\n                    }\n                }\n                symbolLinks.exportAssignSymbol = exportSymbol || unknownSymbol;\n            }\n        }\n        function collectExportInformationForSourceFileOrModule(symbol) {\n            var seenExportedMember = false;\n            var result = [];\n            ts.forEach(symbol.declarations, function (declaration) {\n                var block = (declaration.kind === 201 /* SourceFile */ ? declaration : declaration.body);\n                ts.forEach(block.statements, function (node) {\n                    if (node.kind === 192 /* ExportAssignment */) {\n                        result.push(node);\n                    }\n                    else {\n                        seenExportedMember = seenExportedMember || (node.flags & 1 /* Export */) !== 0;\n                    }\n                });\n            });\n            return {\n                hasExportedMember: seenExportedMember,\n                exportAssignments: result\n            };\n        }\n        function getMergedSymbol(symbol) {\n            var merged;\n            return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;\n        }\n        function getSymbolOfNode(node) {\n            return getMergedSymbol(node.symbol);\n        }\n        function getParentOfSymbol(symbol) {\n            return getMergedSymbol(symbol.parent);\n        }\n        function getExportSymbolOfValueSymbolIfExported(symbol) {\n            return symbol && (symbol.flags & 4194304 /* ExportValue */) !== 0 ? getMergedSymbol(symbol.exportSymbol) : symbol;\n        }\n        function symbolIsValue(symbol) {\n            // If it is an instantiated symbol, then it is a value if the symbol it is an\n            // instantiation of is a value.\n            if (symbol.flags & 67108864 /* Instantiated */) {\n                return symbolIsValue(getSymbolLinks(symbol).target);\n            }\n            // If the symbol has the value flag, it is trivially a value.\n            if (symbol.flags & 107455 /* Value */) {\n                return true;\n            }\n            // If it is an import, then it is a value if the symbol it resolves to is a value.\n            if (symbol.flags & 33554432 /* Import */) {\n                return (resolveImport(symbol).flags & 107455 /* Value */) !== 0;\n            }\n            return false;\n        }\n        function findConstructorDeclaration(node) {\n            var members = node.members;\n            for (var i = 0; i < members.length; i++) {\n                var member = members[i];\n                if (member.kind === 126 /* Constructor */ && member.body) {\n                    return member;\n                }\n            }\n        }\n        function createType(flags) {\n            var result = new Type(checker, flags);\n            result.id = typeCount++;\n            return result;\n        }\n        function createIntrinsicType(kind, intrinsicName) {\n            var type = createType(kind);\n            type.intrinsicName = intrinsicName;\n            return type;\n        }\n        function createObjectType(kind, symbol) {\n            var type = createType(kind);\n            type.symbol = symbol;\n            return type;\n        }\n        // A reserved member name starts with two underscores followed by a non-underscore\n        function isReservedMemberName(name) {\n            return name.charCodeAt(0) === 95 /* _ */ && name.charCodeAt(1) === 95 /* _ */ && name.charCodeAt(2) !== 95 /* _ */;\n        }\n        function getNamedMembers(members) {\n            var result;\n            for (var id in members) {\n                if (ts.hasProperty(members, id)) {\n                    if (!isReservedMemberName(id)) {\n                        if (!result)\n                            result = [];\n                        var symbol = members[id];\n                        if (symbolIsValue(symbol)) {\n                            result.push(symbol);\n                        }\n                    }\n                }\n            }\n            return result || emptyArray;\n        }\n        function setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType) {\n            type.members = members;\n            type.properties = getNamedMembers(members);\n            type.callSignatures = callSignatures;\n            type.constructSignatures = constructSignatures;\n            if (stringIndexType)\n                type.stringIndexType = stringIndexType;\n            if (numberIndexType)\n                type.numberIndexType = numberIndexType;\n            return type;\n        }\n        function createAnonymousType(symbol, members, callSignatures, constructSignatures, stringIndexType, numberIndexType) {\n            return setObjectTypeMembers(createObjectType(32768 /* Anonymous */, symbol), members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\n        }\n        function isOptionalProperty(propertySymbol) {\n            //  class C {\n            //      constructor(public x?) { }\n            //  }\n            //\n            // x is an optional parameter, but it is a required property.\n            return propertySymbol.valueDeclaration && ts.hasQuestionToken(propertySymbol.valueDeclaration) && propertySymbol.valueDeclaration.kind !== 123 /* Parameter */;\n        }\n        function forEachSymbolTableInScope(enclosingDeclaration, callback) {\n            var result;\n            for (var location = enclosingDeclaration; location; location = location.parent) {\n                // Locals of a source file are not in scope (because they get merged into the global symbol table)\n                if (location.locals && !isGlobalSourceFile(location)) {\n                    if (result = callback(location.locals)) {\n                        return result;\n                    }\n                }\n                switch (location.kind) {\n                    case 201 /* SourceFile */:\n                        if (!ts.isExternalModule(location)) {\n                            break;\n                        }\n                    case 189 /* ModuleDeclaration */:\n                        if (result = callback(getSymbolOfNode(location).exports)) {\n                            return result;\n                        }\n                        break;\n                    case 185 /* ClassDeclaration */:\n                    case 186 /* InterfaceDeclaration */:\n                        if (result = callback(getSymbolOfNode(location).members)) {\n                            return result;\n                        }\n                        break;\n                }\n            }\n            return callback(globals);\n        }\n        function getQualifiedLeftMeaning(rightMeaning) {\n            // If we are looking in value space, the parent meaning is value, other wise it is namespace\n            return rightMeaning === 107455 /* Value */ ? 107455 /* Value */ : 1536 /* Namespace */;\n        }\n        function getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, useOnlyExternalAliasing) {\n            function getAccessibleSymbolChainFromSymbolTable(symbols) {\n                function canQualifySymbol(symbolFromSymbolTable, meaning) {\n                    // If the symbol is equivalent and doesn't need further qualification, this symbol is accessible\n                    if (!needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning)) {\n                        return true;\n                    }\n                    // If symbol needs qualification, make sure that parent is accessible, if it is then this symbol is accessible too\n                    var accessibleParent = getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing);\n                    return !!accessibleParent;\n                }\n                function isAccessible(symbolFromSymbolTable, resolvedAliasSymbol) {\n                    if (symbol === (resolvedAliasSymbol || symbolFromSymbolTable)) {\n                        // if the symbolFromSymbolTable is not external module (it could be if it was determined as ambient external module and would be in globals table)\n                        // and if symbolfrom symbolTable or alias resolution matches the symbol, \n                        // check the symbol can be qualified, it is only then this symbol is accessible\n                        return !ts.forEach(symbolFromSymbolTable.declarations, function (declaration) { return hasExternalModuleSymbol(declaration); }) && canQualifySymbol(symbolFromSymbolTable, meaning);\n                    }\n                }\n                // If symbol is directly available by its name in the symbol table\n                if (isAccessible(ts.lookUp(symbols, symbol.name))) {\n                    return [symbol];\n                }\n                // Check if symbol is any of the alias\n                return ts.forEachValue(symbols, function (symbolFromSymbolTable) {\n                    if (symbolFromSymbolTable.flags & 33554432 /* Import */) {\n                        if (!useOnlyExternalAliasing || ts.forEach(symbolFromSymbolTable.declarations, ts.isExternalModuleImportDeclaration)) {\n                            var resolvedImportedSymbol = resolveImport(symbolFromSymbolTable);\n                            if (isAccessible(symbolFromSymbolTable, resolveImport(symbolFromSymbolTable))) {\n                                return [symbolFromSymbolTable];\n                            }\n                            // Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain\n                            // but only if the symbolFromSymbolTable can be qualified\n                            var accessibleSymbolsFromExports = resolvedImportedSymbol.exports ? getAccessibleSymbolChainFromSymbolTable(resolvedImportedSymbol.exports) : undefined;\n                            if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {\n                                return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);\n                            }\n                        }\n                    }\n                });\n            }\n            if (symbol) {\n                return forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);\n            }\n        }\n        function needsQualification(symbol, enclosingDeclaration, meaning) {\n            var qualify = false;\n            forEachSymbolTableInScope(enclosingDeclaration, function (symbolTable) {\n                // If symbol of this name is not available in the symbol table we are ok\n                if (!ts.hasProperty(symbolTable, symbol.name)) {\n                    // Continue to the next symbol table\n                    return false;\n                }\n                // If the symbol with this name is present it should refer to the symbol\n                var symbolFromSymbolTable = symbolTable[symbol.name];\n                if (symbolFromSymbolTable === symbol) {\n                    // No need to qualify\n                    return true;\n                }\n                // Qualify if the symbol from symbol table has same meaning as expected\n                symbolFromSymbolTable = (symbolFromSymbolTable.flags & 33554432 /* Import */) ? resolveImport(symbolFromSymbolTable) : symbolFromSymbolTable;\n                if (symbolFromSymbolTable.flags & meaning) {\n                    qualify = true;\n                    return true;\n                }\n                // Continue to the next symbol table\n                return false;\n            });\n            return qualify;\n        }\n        function isSymbolAccessible(symbol, enclosingDeclaration, meaning) {\n            if (symbol && enclosingDeclaration && !(symbol.flags & 1048576 /* TypeParameter */)) {\n                var initialSymbol = symbol;\n                var meaningToLook = meaning;\n                while (symbol) {\n                    // Symbol is accessible if it by itself is accessible\n                    var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaningToLook, false);\n                    if (accessibleSymbolChain) {\n                        var hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0]);\n                        if (!hasAccessibleDeclarations) {\n                            return {\n                                accessibility: 1 /* NotAccessible */,\n                                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),\n                                errorModuleName: symbol !== initialSymbol ? symbolToString(symbol, enclosingDeclaration, 1536 /* Namespace */) : undefined,\n                            };\n                        }\n                        return hasAccessibleDeclarations;\n                    }\n                    // If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.\n                    // It could be a qualified symbol and hence verify the path\n                    // e.g.:\n                    // module m {\n                    //     export class c {\n                    //     }\n                    // }\n                    // var x: typeof m.c\n                    // In the above example when we start with checking if typeof m.c symbol is accessible,\n                    // we are going to see if c can be accessed in scope directly. \n                    // But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible\n                    // It is accessible if the parent m is accessible because then m.c can be accessed through qualification\n                    meaningToLook = getQualifiedLeftMeaning(meaning);\n                    symbol = getParentOfSymbol(symbol);\n                }\n                // This could be a symbol that is not exported in the external module \n                // or it could be a symbol from different external module that is not aliased and hence cannot be named\n                var symbolExternalModule = ts.forEach(initialSymbol.declarations, function (declaration) { return getExternalModuleContainer(declaration); });\n                if (symbolExternalModule) {\n                    var enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);\n                    if (symbolExternalModule !== enclosingExternalModule) {\n                        // name from different external module that is not visible\n                        return {\n                            accessibility: 2 /* CannotBeNamed */,\n                            errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),\n                            errorModuleName: symbolToString(symbolExternalModule)\n                        };\n                    }\n                }\n                // Just a local name that is not accessible\n                return {\n                    accessibility: 1 /* NotAccessible */,\n                    errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),\n                };\n            }\n            return { accessibility: 0 /* Accessible */ };\n            function getExternalModuleContainer(declaration) {\n                for (; declaration; declaration = declaration.parent) {\n                    if (hasExternalModuleSymbol(declaration)) {\n                        return getSymbolOfNode(declaration);\n                    }\n                }\n            }\n        }\n        function hasExternalModuleSymbol(declaration) {\n            return (declaration.kind === 189 /* ModuleDeclaration */ && declaration.name.kind === 7 /* StringLiteral */) || (declaration.kind === 201 /* SourceFile */ && ts.isExternalModule(declaration));\n        }\n        function hasVisibleDeclarations(symbol) {\n            var aliasesToMakeVisible;\n            if (ts.forEach(symbol.declarations, function (declaration) { return !getIsDeclarationVisible(declaration); })) {\n                return undefined;\n            }\n            return { accessibility: 0 /* Accessible */, aliasesToMakeVisible: aliasesToMakeVisible };\n            function getIsDeclarationVisible(declaration) {\n                if (!isDeclarationVisible(declaration)) {\n                    // Mark the unexported alias as visible if its parent is visible \n                    // because these kind of aliases can be used to name types in declaration file\n                    if (declaration.kind === 191 /* ImportDeclaration */ && !(declaration.flags & 1 /* Export */) && isDeclarationVisible(declaration.parent)) {\n                        getNodeLinks(declaration).isVisible = true;\n                        if (aliasesToMakeVisible) {\n                            if (!ts.contains(aliasesToMakeVisible, declaration)) {\n                                aliasesToMakeVisible.push(declaration);\n                            }\n                        }\n                        else {\n                            aliasesToMakeVisible = [declaration];\n                        }\n                        return true;\n                    }\n                    // Declaration is not visible\n                    return false;\n                }\n                return true;\n            }\n        }\n        function isEntityNameVisible(entityName, enclosingDeclaration) {\n            // get symbol of the first identifier of the entityName\n            var meaning;\n            if (entityName.parent.kind === 135 /* TypeQuery */) {\n                // Typeof value\n                meaning = 107455 /* Value */ | 4194304 /* ExportValue */;\n            }\n            else if (entityName.kind === 120 /* QualifiedName */ || entityName.parent.kind === 191 /* ImportDeclaration */) {\n                // Left identifier from type reference or TypeAlias\n                // Entity name of the import declaration \n                meaning = 1536 /* Namespace */;\n            }\n            else {\n                // Type Reference or TypeAlias entity = Identifier\n                meaning = 3152352 /* Type */;\n            }\n            var firstIdentifier = getFirstIdentifier(entityName);\n            var symbol = resolveName(enclosingDeclaration, firstIdentifier.text, meaning, undefined, undefined);\n            // Verify if the symbol is accessible\n            return (symbol && hasVisibleDeclarations(symbol)) || {\n                accessibility: 1 /* NotAccessible */,\n                errorSymbolName: ts.getTextOfNode(firstIdentifier),\n                errorNode: firstIdentifier\n            };\n        }\n        function writeKeyword(writer, kind) {\n            writer.writeKeyword(ts.tokenToString(kind));\n        }\n        function writePunctuation(writer, kind) {\n            writer.writePunctuation(ts.tokenToString(kind));\n        }\n        function writeSpace(writer) {\n            writer.writeSpace(\" \");\n        }\n        function symbolToString(symbol, enclosingDeclaration, meaning) {\n            var writer = ts.getSingleLineStringWriter();\n            getSymbolDisplayBuilder().buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning);\n            var result = writer.string();\n            ts.releaseStringWriter(writer);\n            return result;\n        }\n        function typeToString(type, enclosingDeclaration, flags) {\n            var writer = ts.getSingleLineStringWriter();\n            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);\n            var result = writer.string();\n            ts.releaseStringWriter(writer);\n            var maxLength = compilerOptions.noErrorTruncation || flags & 4 /* NoTruncation */ ? undefined : 100;\n            if (maxLength && result.length >= maxLength) {\n                result = result.substr(0, maxLength - \"...\".length) + \"...\";\n            }\n            return result;\n        }\n        function getTypeAliasForTypeLiteral(type) {\n            if (type.symbol && type.symbol.flags & 2048 /* TypeLiteral */) {\n                var node = type.symbol.declarations[0].parent;\n                while (node.kind === 140 /* ParenthesizedType */) {\n                    node = node.parent;\n                }\n                if (node.kind === 187 /* TypeAliasDeclaration */) {\n                    return getSymbolOfNode(node);\n                }\n            }\n            return undefined;\n        }\n        // This is for caching the result of getSymbolDisplayBuilder. Do not access directly.\n        var _displayBuilder;\n        function getSymbolDisplayBuilder() {\n            /**\n             * Writes only the name of the symbol out to the writer. Uses the original source text\n             * for the name of the symbol if it is available to match how the user inputted the name.\n             */\n            function appendSymbolNameOnly(symbol, writer) {\n                if (symbol.declarations && symbol.declarations.length > 0) {\n                    var declaration = symbol.declarations[0];\n                    if (declaration.name) {\n                        writer.writeSymbol(ts.declarationNameToString(declaration.name), symbol);\n                        return;\n                    }\n                }\n                writer.writeSymbol(symbol.name, symbol);\n            }\n            /**\n             * Enclosing declaration is optional when we don't want to get qualified name in the enclosing declaration scope\n             * Meaning needs to be specified if the enclosing declaration is given\n             */\n            function buildSymbolDisplay(symbol, writer, enclosingDeclaration, meaning, flags) {\n                var parentSymbol;\n                function appendParentTypeArgumentsAndSymbolName(symbol) {\n                    if (parentSymbol) {\n                        // Write type arguments of instantiated class/interface here\n                        if (flags & 1 /* WriteTypeParametersOrArguments */) {\n                            if (symbol.flags & 67108864 /* Instantiated */) {\n                                buildDisplayForTypeArgumentsAndDelimiters(getTypeParametersOfClassOrInterface(parentSymbol), symbol.mapper, writer, enclosingDeclaration);\n                            }\n                            else {\n                                buildTypeParameterDisplayFromSymbol(parentSymbol, writer, enclosingDeclaration);\n                            }\n                        }\n                        writePunctuation(writer, 19 /* DotToken */);\n                    }\n                    parentSymbol = symbol;\n                    appendSymbolNameOnly(symbol, writer);\n                }\n                // Let the writer know we just wrote out a symbol.  The declaration emitter writer uses \n                // this to determine if an import it has previously seen (and not written out) needs \n                // to be written to the file once the walk of the tree is complete.\n                //\n                // NOTE(cyrusn): This approach feels somewhat unfortunate.  A simple pass over the tree\n                // up front (for example, during checking) could determine if we need to emit the imports\n                // and we could then access that data during declaration emit.\n                writer.trackSymbol(symbol, enclosingDeclaration, meaning);\n                function walkSymbol(symbol, meaning) {\n                    if (symbol) {\n                        var accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, !!(flags & 2 /* UseOnlyExternalAliasing */));\n                        if (!accessibleSymbolChain || needsQualification(accessibleSymbolChain[0], enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning))) {\n                            // Go up and add our parent.\n                            walkSymbol(getParentOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol), getQualifiedLeftMeaning(meaning));\n                        }\n                        if (accessibleSymbolChain) {\n                            for (var i = 0, n = accessibleSymbolChain.length; i < n; i++) {\n                                appendParentTypeArgumentsAndSymbolName(accessibleSymbolChain[i]);\n                            }\n                        }\n                        else {\n                            // If we didn't find accessible symbol chain for this symbol, break if this is external module\n                            if (!parentSymbol && ts.forEach(symbol.declarations, function (declaration) { return hasExternalModuleSymbol(declaration); })) {\n                                return;\n                            }\n                            // if this is anonymous type break\n                            if (symbol.flags & 2048 /* TypeLiteral */ || symbol.flags & 4096 /* ObjectLiteral */) {\n                                return;\n                            }\n                            appendParentTypeArgumentsAndSymbolName(symbol);\n                        }\n                    }\n                }\n                // Get qualified name \n                if (enclosingDeclaration && !(symbol.flags & 1048576 /* TypeParameter */)) {\n                    walkSymbol(symbol, meaning);\n                    return;\n                }\n                return appendParentTypeArgumentsAndSymbolName(symbol);\n            }\n            function buildTypeDisplay(type, writer, enclosingDeclaration, globalFlags, typeStack) {\n                var globalFlagsToPass = globalFlags & 16 /* WriteOwnNameForAnyLike */;\n                return writeType(type, globalFlags);\n                function writeType(type, flags) {\n                    // Write undefined/null type as any\n                    if (type.flags & 127 /* Intrinsic */) {\n                        // Special handling for unknown / resolving types, they should show up as any and not unknown or __resolving\n                        writer.writeKeyword(!(globalFlags & 16 /* WriteOwnNameForAnyLike */) && (type.flags & 1 /* Any */) ? \"any\" : type.intrinsicName);\n                    }\n                    else if (type.flags & 4096 /* Reference */) {\n                        writeTypeReference(type, flags);\n                    }\n                    else if (type.flags & (1024 /* Class */ | 2048 /* Interface */ | 128 /* Enum */ | 512 /* TypeParameter */)) {\n                        buildSymbolDisplay(type.symbol, writer, enclosingDeclaration, 3152352 /* Type */);\n                    }\n                    else if (type.flags & 8192 /* Tuple */) {\n                        writeTupleType(type);\n                    }\n                    else if (type.flags & 16384 /* Union */) {\n                        writeUnionType(type, flags);\n                    }\n                    else if (type.flags & 32768 /* Anonymous */) {\n                        writeAnonymousType(type, flags);\n                    }\n                    else if (type.flags & 256 /* StringLiteral */) {\n                        writer.writeStringLiteral(type.text);\n                    }\n                    else {\n                        // Should never get here\n                        // { ... }\n                        writePunctuation(writer, 13 /* OpenBraceToken */);\n                        writeSpace(writer);\n                        writePunctuation(writer, 20 /* DotDotDotToken */);\n                        writeSpace(writer);\n                        writePunctuation(writer, 14 /* CloseBraceToken */);\n                    }\n                }\n                function writeTypeList(types, union) {\n                    for (var i = 0; i < types.length; i++) {\n                        if (i > 0) {\n                            if (union) {\n                                writeSpace(writer);\n                            }\n                            writePunctuation(writer, union ? 43 /* BarToken */ : 22 /* CommaToken */);\n                            writeSpace(writer);\n                        }\n                        writeType(types[i], union ? 64 /* InElementType */ : 0 /* None */);\n                    }\n                }\n                function writeTypeReference(type, flags) {\n                    if (type.target === globalArrayType && !(flags & 1 /* WriteArrayAsGenericType */)) {\n                        writeType(type.typeArguments[0], 64 /* InElementType */);\n                        writePunctuation(writer, 17 /* OpenBracketToken */);\n                        writePunctuation(writer, 18 /* CloseBracketToken */);\n                    }\n                    else {\n                        buildSymbolDisplay(type.target.symbol, writer, enclosingDeclaration, 3152352 /* Type */);\n                        writePunctuation(writer, 23 /* LessThanToken */);\n                        writeTypeList(type.typeArguments, false);\n                        writePunctuation(writer, 24 /* GreaterThanToken */);\n                    }\n                }\n                function writeTupleType(type) {\n                    writePunctuation(writer, 17 /* OpenBracketToken */);\n                    writeTypeList(type.elementTypes, false);\n                    writePunctuation(writer, 18 /* CloseBracketToken */);\n                }\n                function writeUnionType(type, flags) {\n                    if (flags & 64 /* InElementType */) {\n                        writePunctuation(writer, 15 /* OpenParenToken */);\n                    }\n                    writeTypeList(type.types, true);\n                    if (flags & 64 /* InElementType */) {\n                        writePunctuation(writer, 16 /* CloseParenToken */);\n                    }\n                }\n                function writeAnonymousType(type, flags) {\n                    // Always use 'typeof T' for type of class, enum, and module objects\n                    if (type.symbol && type.symbol.flags & (32 /* Class */ | 384 /* Enum */ | 512 /* ValueModule */)) {\n                        writeTypeofSymbol(type);\n                    }\n                    else if (shouldWriteTypeOfFunctionSymbol()) {\n                        writeTypeofSymbol(type);\n                    }\n                    else if (typeStack && ts.contains(typeStack, type)) {\n                        // If type is an anonymous type literal in a type alias declaration, use type alias name\n                        var typeAlias = getTypeAliasForTypeLiteral(type);\n                        if (typeAlias) {\n                            buildSymbolDisplay(typeAlias, writer, enclosingDeclaration, 3152352 /* Type */);\n                        }\n                        else {\n                            // Recursive usage, use any\n                            writeKeyword(writer, 109 /* AnyKeyword */);\n                        }\n                    }\n                    else {\n                        if (!typeStack) {\n                            typeStack = [];\n                        }\n                        typeStack.push(type);\n                        writeLiteralType(type, flags);\n                        typeStack.pop();\n                    }\n                    function shouldWriteTypeOfFunctionSymbol() {\n                        if (type.symbol) {\n                            var isStaticMethodSymbol = !!(type.symbol.flags & 8192 /* Method */ && ts.forEach(type.symbol.declarations, function (declaration) { return declaration.flags & 128 /* Static */; }));\n                            var isNonLocalFunctionSymbol = !!(type.symbol.flags & 16 /* Function */) && (type.symbol.parent || ts.forEach(type.symbol.declarations, function (declaration) { return declaration.parent.kind === 201 /* SourceFile */ || declaration.parent.kind === 190 /* ModuleBlock */; }));\n                            if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {\n                                // typeof is allowed only for static/non local functions\n                                return !!(flags & 2 /* UseTypeOfFunction */) || (typeStack && ts.contains(typeStack, type)); // it is type of the symbol uses itself recursively\n                            }\n                        }\n                    }\n                }\n                function writeTypeofSymbol(type) {\n                    writeKeyword(writer, 95 /* TypeOfKeyword */);\n                    writeSpace(writer);\n                    buildSymbolDisplay(type.symbol, writer, enclosingDeclaration, 107455 /* Value */);\n                }\n                function getIndexerParameterName(type, indexKind, fallbackName) {\n                    var declaration = getIndexDeclarationOfSymbol(type.symbol, indexKind);\n                    if (!declaration) {\n                        // declaration might not be found if indexer was added from the contextual type.\n                        // in this case use fallback name\n                        return fallbackName;\n                    }\n                    ts.Debug.assert(declaration.parameters.length !== 0);\n                    return ts.declarationNameToString(declaration.parameters[0].name);\n                }\n                function writeLiteralType(type, flags) {\n                    var resolved = resolveObjectOrUnionTypeMembers(type);\n                    if (!resolved.properties.length && !resolved.stringIndexType && !resolved.numberIndexType) {\n                        if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {\n                            writePunctuation(writer, 13 /* OpenBraceToken */);\n                            writePunctuation(writer, 14 /* CloseBraceToken */);\n                            return;\n                        }\n                        if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {\n                            if (flags & 64 /* InElementType */) {\n                                writePunctuation(writer, 15 /* OpenParenToken */);\n                            }\n                            buildSignatureDisplay(resolved.callSignatures[0], writer, enclosingDeclaration, globalFlagsToPass | 8 /* WriteArrowStyleSignature */, typeStack);\n                            if (flags & 64 /* InElementType */) {\n                                writePunctuation(writer, 16 /* CloseParenToken */);\n                            }\n                            return;\n                        }\n                        if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {\n                            if (flags & 64 /* InElementType */) {\n                                writePunctuation(writer, 15 /* OpenParenToken */);\n                            }\n                            writeKeyword(writer, 86 /* NewKeyword */);\n                            writeSpace(writer);\n                            buildSignatureDisplay(resolved.constructSignatures[0], writer, enclosingDeclaration, globalFlagsToPass | 8 /* WriteArrowStyleSignature */, typeStack);\n                            if (flags & 64 /* InElementType */) {\n                                writePunctuation(writer, 16 /* CloseParenToken */);\n                            }\n                            return;\n                        }\n                    }\n                    writePunctuation(writer, 13 /* OpenBraceToken */);\n                    writer.writeLine();\n                    writer.increaseIndent();\n                    for (var i = 0; i < resolved.callSignatures.length; i++) {\n                        buildSignatureDisplay(resolved.callSignatures[i], writer, enclosingDeclaration, globalFlagsToPass, typeStack);\n                        writePunctuation(writer, 21 /* SemicolonToken */);\n                        writer.writeLine();\n                    }\n                    for (var i = 0; i < resolved.constructSignatures.length; i++) {\n                        writeKeyword(writer, 86 /* NewKeyword */);\n                        writeSpace(writer);\n                        buildSignatureDisplay(resolved.constructSignatures[i], writer, enclosingDeclaration, globalFlagsToPass, typeStack);\n                        writePunctuation(writer, 21 /* SemicolonToken */);\n                        writer.writeLine();\n                    }\n                    if (resolved.stringIndexType) {\n                        // [x: string]: \n                        writePunctuation(writer, 17 /* OpenBracketToken */);\n                        writer.writeParameter(getIndexerParameterName(resolved, 0 /* String */, \"x\"));\n                        writePunctuation(writer, 50 /* ColonToken */);\n                        writeSpace(writer);\n                        writeKeyword(writer, 118 /* StringKeyword */);\n                        writePunctuation(writer, 18 /* CloseBracketToken */);\n                        writePunctuation(writer, 50 /* ColonToken */);\n                        writeSpace(writer);\n                        writeType(resolved.stringIndexType, 0 /* None */);\n                        writePunctuation(writer, 21 /* SemicolonToken */);\n                        writer.writeLine();\n                    }\n                    if (resolved.numberIndexType) {\n                        // [x: number]: \n                        writePunctuation(writer, 17 /* OpenBracketToken */);\n                        writer.writeParameter(getIndexerParameterName(resolved, 1 /* Number */, \"x\"));\n                        writePunctuation(writer, 50 /* ColonToken */);\n                        writeSpace(writer);\n                        writeKeyword(writer, 116 /* NumberKeyword */);\n                        writePunctuation(writer, 18 /* CloseBracketToken */);\n                        writePunctuation(writer, 50 /* ColonToken */);\n                        writeSpace(writer);\n                        writeType(resolved.numberIndexType, 0 /* None */);\n                        writePunctuation(writer, 21 /* SemicolonToken */);\n                        writer.writeLine();\n                    }\n                    for (var i = 0; i < resolved.properties.length; i++) {\n                        var p = resolved.properties[i];\n                        var t = getTypeOfSymbol(p);\n                        if (p.flags & (16 /* Function */ | 8192 /* Method */) && !getPropertiesOfObjectType(t).length) {\n                            var signatures = getSignaturesOfType(t, 0 /* Call */);\n                            for (var j = 0; j < signatures.length; j++) {\n                                buildSymbolDisplay(p, writer);\n                                if (isOptionalProperty(p)) {\n                                    writePunctuation(writer, 49 /* QuestionToken */);\n                                }\n                                buildSignatureDisplay(signatures[j], writer, enclosingDeclaration, globalFlagsToPass, typeStack);\n                                writePunctuation(writer, 21 /* SemicolonToken */);\n                                writer.writeLine();\n                            }\n                        }\n                        else {\n                            buildSymbolDisplay(p, writer);\n                            if (isOptionalProperty(p)) {\n                                writePunctuation(writer, 49 /* QuestionToken */);\n                            }\n                            writePunctuation(writer, 50 /* ColonToken */);\n                            writeSpace(writer);\n                            writeType(t, 0 /* None */);\n                            writePunctuation(writer, 21 /* SemicolonToken */);\n                            writer.writeLine();\n                        }\n                    }\n                    writer.decreaseIndent();\n                    writePunctuation(writer, 14 /* CloseBraceToken */);\n                }\n            }\n            function buildTypeParameterDisplayFromSymbol(symbol, writer, enclosingDeclaraiton, flags) {\n                var targetSymbol = getTargetSymbol(symbol);\n                if (targetSymbol.flags & 32 /* Class */ || targetSymbol.flags & 64 /* Interface */) {\n                    buildDisplayForTypeParametersAndDelimiters(getTypeParametersOfClassOrInterface(symbol), writer, enclosingDeclaraiton, flags);\n                }\n            }\n            function buildTypeParameterDisplay(tp, writer, enclosingDeclaration, flags, typeStack) {\n                appendSymbolNameOnly(tp.symbol, writer);\n                var constraint = getConstraintOfTypeParameter(tp);\n                if (constraint) {\n                    writeSpace(writer);\n                    writeKeyword(writer, 77 /* ExtendsKeyword */);\n                    writeSpace(writer);\n                    buildTypeDisplay(constraint, writer, enclosingDeclaration, flags, typeStack);\n                }\n            }\n            function buildParameterDisplay(p, writer, enclosingDeclaration, flags, typeStack) {\n                if (ts.hasDotDotDotToken(p.valueDeclaration)) {\n                    writePunctuation(writer, 20 /* DotDotDotToken */);\n                }\n                appendSymbolNameOnly(p, writer);\n                if (ts.hasQuestionToken(p.valueDeclaration) || p.valueDeclaration.initializer) {\n                    writePunctuation(writer, 49 /* QuestionToken */);\n                }\n                writePunctuation(writer, 50 /* ColonToken */);\n                writeSpace(writer);\n                buildTypeDisplay(getTypeOfSymbol(p), writer, enclosingDeclaration, flags, typeStack);\n            }\n            function buildDisplayForTypeParametersAndDelimiters(typeParameters, writer, enclosingDeclaration, flags, typeStack) {\n                if (typeParameters && typeParameters.length) {\n                    writePunctuation(writer, 23 /* LessThanToken */);\n                    for (var i = 0; i < typeParameters.length; i++) {\n                        if (i > 0) {\n                            writePunctuation(writer, 22 /* CommaToken */);\n                            writeSpace(writer);\n                        }\n                        buildTypeParameterDisplay(typeParameters[i], writer, enclosingDeclaration, flags, typeStack);\n                    }\n                    writePunctuation(writer, 24 /* GreaterThanToken */);\n                }\n            }\n            function buildDisplayForTypeArgumentsAndDelimiters(typeParameters, mapper, writer, enclosingDeclaration, flags, typeStack) {\n                if (typeParameters && typeParameters.length) {\n                    writePunctuation(writer, 23 /* LessThanToken */);\n                    for (var i = 0; i < typeParameters.length; i++) {\n                        if (i > 0) {\n                            writePunctuation(writer, 22 /* CommaToken */);\n                            writeSpace(writer);\n                        }\n                        buildTypeDisplay(mapper(typeParameters[i]), writer, enclosingDeclaration, 0 /* None */);\n                    }\n                    writePunctuation(writer, 24 /* GreaterThanToken */);\n                }\n            }\n            function buildDisplayForParametersAndDelimiters(parameters, writer, enclosingDeclaration, flags, typeStack) {\n                writePunctuation(writer, 15 /* OpenParenToken */);\n                for (var i = 0; i < parameters.length; i++) {\n                    if (i > 0) {\n                        writePunctuation(writer, 22 /* CommaToken */);\n                        writeSpace(writer);\n                    }\n                    buildParameterDisplay(parameters[i], writer, enclosingDeclaration, flags, typeStack);\n                }\n                writePunctuation(writer, 16 /* CloseParenToken */);\n            }\n            function buildReturnTypeDisplay(signature, writer, enclosingDeclaration, flags, typeStack) {\n                if (flags & 8 /* WriteArrowStyleSignature */) {\n                    writeSpace(writer);\n                    writePunctuation(writer, 31 /* EqualsGreaterThanToken */);\n                }\n                else {\n                    writePunctuation(writer, 50 /* ColonToken */);\n                }\n                writeSpace(writer);\n                buildTypeDisplay(getReturnTypeOfSignature(signature), writer, enclosingDeclaration, flags, typeStack);\n            }\n            function buildSignatureDisplay(signature, writer, enclosingDeclaration, flags, typeStack) {\n                if (signature.target && (flags & 32 /* WriteTypeArgumentsOfSignature */)) {\n                    // Instantiated signature, write type arguments instead\n                    // This is achieved by passing in the mapper separately\n                    buildDisplayForTypeArgumentsAndDelimiters(signature.target.typeParameters, signature.mapper, writer, enclosingDeclaration);\n                }\n                else {\n                    buildDisplayForTypeParametersAndDelimiters(signature.typeParameters, writer, enclosingDeclaration, flags, typeStack);\n                }\n                buildDisplayForParametersAndDelimiters(signature.parameters, writer, enclosingDeclaration, flags, typeStack);\n                buildReturnTypeDisplay(signature, writer, enclosingDeclaration, flags, typeStack);\n            }\n            return _displayBuilder || (_displayBuilder = {\n                symbolToString: symbolToString,\n                typeToString: typeToString,\n                buildSymbolDisplay: buildSymbolDisplay,\n                buildTypeDisplay: buildTypeDisplay,\n                buildTypeParameterDisplay: buildTypeParameterDisplay,\n                buildParameterDisplay: buildParameterDisplay,\n                buildDisplayForParametersAndDelimiters: buildDisplayForParametersAndDelimiters,\n                buildDisplayForTypeParametersAndDelimiters: buildDisplayForTypeParametersAndDelimiters,\n                buildDisplayForTypeArgumentsAndDelimiters: buildDisplayForTypeArgumentsAndDelimiters,\n                buildTypeParameterDisplayFromSymbol: buildTypeParameterDisplayFromSymbol,\n                buildSignatureDisplay: buildSignatureDisplay,\n                buildReturnTypeDisplay: buildReturnTypeDisplay\n            });\n        }\n        function isDeclarationVisible(node) {\n            function getContainingExternalModule(node) {\n                for (; node; node = node.parent) {\n                    if (node.kind === 189 /* ModuleDeclaration */) {\n                        if (node.name.kind === 7 /* StringLiteral */) {\n                            return node;\n                        }\n                    }\n                    else if (node.kind === 201 /* SourceFile */) {\n                        return ts.isExternalModule(node) ? node : undefined;\n                    }\n                }\n                ts.Debug.fail(\"getContainingModule cant reach here\");\n            }\n            function isUsedInExportAssignment(node) {\n                // Get source File and see if it is external module and has export assigned symbol\n                var externalModule = getContainingExternalModule(node);\n                if (externalModule) {\n                    // This is export assigned symbol node\n                    var externalModuleSymbol = getSymbolOfNode(externalModule);\n                    var exportAssignmentSymbol = getExportAssignmentSymbol(externalModuleSymbol);\n                    var resolvedExportSymbol;\n                    var symbolOfNode = getSymbolOfNode(node);\n                    if (isSymbolUsedInExportAssignment(symbolOfNode)) {\n                        return true;\n                    }\n                    // if symbolOfNode is import declaration, resolve the symbol declaration and check\n                    if (symbolOfNode.flags & 33554432 /* Import */) {\n                        return isSymbolUsedInExportAssignment(resolveImport(symbolOfNode));\n                    }\n                }\n                // Check if the symbol is used in export assignment\n                function isSymbolUsedInExportAssignment(symbol) {\n                    if (exportAssignmentSymbol === symbol) {\n                        return true;\n                    }\n                    if (exportAssignmentSymbol && !!(exportAssignmentSymbol.flags & 33554432 /* Import */)) {\n                        // if export assigned symbol is import declaration, resolve the import\n                        resolvedExportSymbol = resolvedExportSymbol || resolveImport(exportAssignmentSymbol);\n                        if (resolvedExportSymbol === symbol) {\n                            return true;\n                        }\n                        // Container of resolvedExportSymbol is visible\n                        return ts.forEach(resolvedExportSymbol.declarations, function (current) {\n                            while (current) {\n                                if (current === node) {\n                                    return true;\n                                }\n                                current = current.parent;\n                            }\n                        });\n                    }\n                }\n            }\n            function determineIfDeclarationIsVisible() {\n                switch (node.kind) {\n                    case 183 /* VariableDeclaration */:\n                    case 189 /* ModuleDeclaration */:\n                    case 185 /* ClassDeclaration */:\n                    case 186 /* InterfaceDeclaration */:\n                    case 187 /* TypeAliasDeclaration */:\n                    case 184 /* FunctionDeclaration */:\n                    case 188 /* EnumDeclaration */:\n                    case 191 /* ImportDeclaration */:\n                        // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent\n                        var parent = node.kind === 183 /* VariableDeclaration */ ? node.parent.parent : node.parent;\n                        // If the node is not exported or it is not ambient module element (except import declaration)\n                        if (!(node.flags & 1 /* Export */) && !(node.kind !== 191 /* ImportDeclaration */ && parent.kind !== 201 /* SourceFile */ && ts.isInAmbientContext(parent))) {\n                            return isGlobalSourceFile(parent) || isUsedInExportAssignment(node);\n                        }\n                        // Exported members/ambient module elements (exception import declaration) are visible if parent is visible\n                        return isDeclarationVisible(parent);\n                    case 124 /* Property */:\n                    case 127 /* GetAccessor */:\n                    case 128 /* SetAccessor */:\n                    case 125 /* Method */:\n                        if (node.flags & (32 /* Private */ | 64 /* Protected */)) {\n                            // Private/protected properties/methods are not visible\n                            return false;\n                        }\n                    case 126 /* Constructor */:\n                    case 130 /* ConstructSignature */:\n                    case 129 /* CallSignature */:\n                    case 131 /* IndexSignature */:\n                    case 123 /* Parameter */:\n                    case 190 /* ModuleBlock */:\n                    case 133 /* FunctionType */:\n                    case 134 /* ConstructorType */:\n                    case 136 /* TypeLiteral */:\n                    case 132 /* TypeReference */:\n                    case 137 /* ArrayType */:\n                    case 138 /* TupleType */:\n                    case 139 /* UnionType */:\n                    case 140 /* ParenthesizedType */:\n                        return isDeclarationVisible(node.parent);\n                    case 122 /* TypeParameter */:\n                    case 201 /* SourceFile */:\n                        return true;\n                    default:\n                        ts.Debug.fail(\"isDeclarationVisible unknown: SyntaxKind: \" + node.kind);\n                }\n            }\n            if (node) {\n                var links = getNodeLinks(node);\n                if (links.isVisible === undefined) {\n                    links.isVisible = !!determineIfDeclarationIsVisible();\n                }\n                return links.isVisible;\n            }\n        }\n        function getTypeOfPrototypeProperty(prototype) {\n            // TypeScript 1.0 spec (April 2014): 8.4\n            // Every class automatically contains a static property member named 'prototype', \n            // the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.\n            // It is an error to explicitly declare a static property member with the name 'prototype'.\n            var classType = getDeclaredTypeOfSymbol(prototype.parent);\n            return classType.typeParameters ? createTypeReference(classType, ts.map(classType.typeParameters, function (_) { return anyType; })) : classType;\n        }\n        function getTypeOfVariableOrParameterOrPropertyDeclaration(declaration) {\n            // A variable declared in a for..in statement is always of type any\n            if (declaration.parent.kind === 171 /* ForInStatement */) {\n                return anyType;\n            }\n            // Use type from type annotation if one is present\n            if (declaration.type) {\n                return getTypeFromTypeNode(declaration.type);\n            }\n            if (declaration.kind === 123 /* Parameter */) {\n                var func = declaration.parent;\n                // For a parameter of a set accessor, use the type of the get accessor if one is present\n                if (func.kind === 128 /* SetAccessor */ && !ts.hasComputedNameButNotSymbol(func)) {\n                    var getter = ts.getDeclarationOfKind(declaration.parent.symbol, 127 /* GetAccessor */);\n                    if (getter) {\n                        return getReturnTypeOfSignature(getSignatureFromDeclaration(getter));\n                    }\n                }\n                // Use contextual parameter type if one is available\n                var type = getContextuallyTypedParameterType(declaration);\n                if (type) {\n                    return type;\n                }\n            }\n            // Use the type of the initializer expression if one is present\n            if (declaration.initializer) {\n                var type = checkAndMarkExpression(declaration.initializer);\n                // Widening of property assignments is handled by checkObjectLiteral, exclude them here\n                if (declaration.kind !== 198 /* PropertyAssignment */) {\n                    var unwidenedType = type;\n                    type = getWidenedType(type);\n                    if (type !== unwidenedType) {\n                        checkImplicitAny(type);\n                    }\n                }\n                return type;\n            }\n            // If it is a short-hand property assignment; Use the type of the identifier\n            if (declaration.kind === 199 /* ShorthandPropertyAssignment */) {\n                var type = checkIdentifier(declaration.name);\n                return type;\n            }\n            // Rest parameters default to type any[], other parameters default to type any\n            var type = ts.hasDotDotDotToken(declaration) ? createArrayType(anyType) : anyType;\n            checkImplicitAny(type);\n            return type;\n            function checkImplicitAny(type) {\n                if (!fullTypeCheck || !compilerOptions.noImplicitAny) {\n                    return;\n                }\n                // We need to have ended up with 'any', 'any[]', 'any[][]', etc.\n                if (getInnermostTypeOfNestedArrayTypes(type) !== anyType) {\n                    return;\n                }\n                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.\n                // (e.g. privates within .d.ts files do not expose type information)\n                if (isPrivateWithinAmbient(declaration) || (declaration.kind === 123 /* Parameter */ && isPrivateWithinAmbient(declaration.parent))) {\n                    return;\n                }\n                switch (declaration.kind) {\n                    case 124 /* Property */:\n                        var diagnostic = ts.Diagnostics.Member_0_implicitly_has_an_1_type;\n                        break;\n                    case 123 /* Parameter */:\n                        var diagnostic = ts.hasDotDotDotToken(declaration) ? ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : ts.Diagnostics.Parameter_0_implicitly_has_an_1_type;\n                        break;\n                    default:\n                        var diagnostic = ts.Diagnostics.Variable_0_implicitly_has_an_1_type;\n                }\n                error(declaration, diagnostic, ts.declarationNameToString(declaration.name), typeToString(type));\n            }\n        }\n        function getTypeOfVariableOrParameterOrProperty(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.type) {\n                // Handle prototype property\n                if (symbol.flags & 536870912 /* Prototype */) {\n                    return links.type = getTypeOfPrototypeProperty(symbol);\n                }\n                // Handle catch clause variables\n                var declaration = symbol.valueDeclaration;\n                if (declaration.kind === 197 /* CatchClause */) {\n                    return links.type = anyType;\n                }\n                // Handle variable, parameter or property\n                links.type = resolvingType;\n                var type = getTypeOfVariableOrParameterOrPropertyDeclaration(declaration);\n                if (links.type === resolvingType) {\n                    links.type = type;\n                }\n            }\n            else if (links.type === resolvingType) {\n                links.type = anyType;\n                if (compilerOptions.noImplicitAny) {\n                    var diagnostic = symbol.valueDeclaration.type ? ts.Diagnostics._0_implicitly_has_type_any_because_it_is_referenced_directly_or_indirectly_in_its_own_type_annotation : ts.Diagnostics._0_implicitly_has_type_any_because_it_is_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer;\n                    error(symbol.valueDeclaration, diagnostic, symbolToString(symbol));\n                }\n            }\n            return links.type;\n        }\n        function getSetAccessorTypeAnnotationNode(accessor) {\n            return accessor && accessor.parameters.length > 0 && accessor.parameters[0].type;\n        }\n        function getAnnotatedAccessorType(accessor) {\n            if (accessor) {\n                if (accessor.kind === 127 /* GetAccessor */) {\n                    return accessor.type && getTypeFromTypeNode(accessor.type);\n                }\n                else {\n                    var setterTypeAnnotation = getSetAccessorTypeAnnotationNode(accessor);\n                    return setterTypeAnnotation && getTypeFromTypeNode(setterTypeAnnotation);\n                }\n            }\n            return undefined;\n        }\n        function getTypeOfAccessors(symbol) {\n            var links = getSymbolLinks(symbol);\n            checkAndStoreTypeOfAccessors(symbol, links);\n            return links.type;\n        }\n        function checkAndStoreTypeOfAccessors(symbol, links) {\n            links = links || getSymbolLinks(symbol);\n            if (!links.type) {\n                links.type = resolvingType;\n                var getter = ts.getDeclarationOfKind(symbol, 127 /* GetAccessor */);\n                var setter = ts.getDeclarationOfKind(symbol, 128 /* SetAccessor */);\n                var type;\n                // First try to see if the user specified a return type on the get-accessor.\n                var getterReturnType = getAnnotatedAccessorType(getter);\n                if (getterReturnType) {\n                    type = getterReturnType;\n                }\n                else {\n                    // If the user didn't specify a return type, try to use the set-accessor's parameter type.\n                    var setterParameterType = getAnnotatedAccessorType(setter);\n                    if (setterParameterType) {\n                        type = setterParameterType;\n                    }\n                    else {\n                        // If there are no specified types, try to infer it from the body of the get accessor if it exists.\n                        if (getter && getter.body) {\n                            type = getReturnTypeFromBody(getter);\n                        }\n                        else {\n                            if (compilerOptions.noImplicitAny) {\n                                error(setter, ts.Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_type_annotation, symbolToString(symbol));\n                            }\n                            type = anyType;\n                        }\n                    }\n                }\n                if (links.type === resolvingType) {\n                    links.type = type;\n                }\n            }\n            else if (links.type === resolvingType) {\n                links.type = anyType;\n                if (compilerOptions.noImplicitAny) {\n                    var getter = ts.getDeclarationOfKind(symbol, 127 /* GetAccessor */);\n                    error(getter, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol));\n                }\n            }\n        }\n        function getTypeOfFuncClassEnumModule(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.type) {\n                links.type = createObjectType(32768 /* Anonymous */, symbol);\n            }\n            return links.type;\n        }\n        function getTypeOfEnumMember(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.type) {\n                links.type = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));\n            }\n            return links.type;\n        }\n        function getTypeOfImport(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.type) {\n                links.type = getTypeOfSymbol(resolveImport(symbol));\n            }\n            return links.type;\n        }\n        function getTypeOfInstantiatedSymbol(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.type) {\n                links.type = instantiateType(getTypeOfSymbol(links.target), links.mapper);\n            }\n            return links.type;\n        }\n        function getTypeOfSymbol(symbol) {\n            if (symbol.flags & 67108864 /* Instantiated */) {\n                return getTypeOfInstantiatedSymbol(symbol);\n            }\n            if (symbol.flags & (3 /* Variable */ | 4 /* Property */)) {\n                return getTypeOfVariableOrParameterOrProperty(symbol);\n            }\n            if (symbol.flags & (16 /* Function */ | 8192 /* Method */ | 32 /* Class */ | 384 /* Enum */ | 512 /* ValueModule */)) {\n                return getTypeOfFuncClassEnumModule(symbol);\n            }\n            if (symbol.flags & 8 /* EnumMember */) {\n                return getTypeOfEnumMember(symbol);\n            }\n            if (symbol.flags & 98304 /* Accessor */) {\n                return getTypeOfAccessors(symbol);\n            }\n            if (symbol.flags & 33554432 /* Import */) {\n                return getTypeOfImport(symbol);\n            }\n            return unknownType;\n        }\n        function getTargetType(type) {\n            return type.flags & 4096 /* Reference */ ? type.target : type;\n        }\n        function hasBaseType(type, checkBase) {\n            return check(type);\n            function check(type) {\n                var target = getTargetType(type);\n                return target === checkBase || ts.forEach(target.baseTypes, check);\n            }\n        }\n        // Return combined list of type parameters from all declarations of a class or interface. Elsewhere we check they're all\n        // the same, but even if they're not we still need the complete list to ensure instantiations supply type arguments\n        // for all type parameters.\n        function getTypeParametersOfClassOrInterface(symbol) {\n            var result;\n            ts.forEach(symbol.declarations, function (node) {\n                if (node.kind === 186 /* InterfaceDeclaration */ || node.kind === 185 /* ClassDeclaration */) {\n                    var declaration = node;\n                    if (declaration.typeParameters && declaration.typeParameters.length) {\n                        ts.forEach(declaration.typeParameters, function (node) {\n                            var tp = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));\n                            if (!result) {\n                                result = [tp];\n                            }\n                            else if (!ts.contains(result, tp)) {\n                                result.push(tp);\n                            }\n                        });\n                    }\n                }\n            });\n            return result;\n        }\n        function getDeclaredTypeOfClass(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.declaredType) {\n                var type = links.declaredType = createObjectType(1024 /* Class */, symbol);\n                var typeParameters = getTypeParametersOfClassOrInterface(symbol);\n                if (typeParameters) {\n                    type.flags |= 4096 /* Reference */;\n                    type.typeParameters = typeParameters;\n                    type.instantiations = {};\n                    type.instantiations[getTypeListId(type.typeParameters)] = type;\n                    type.target = type;\n                    type.typeArguments = type.typeParameters;\n                }\n                type.baseTypes = [];\n                var declaration = ts.getDeclarationOfKind(symbol, 185 /* ClassDeclaration */);\n                var baseTypeNode = ts.getClassBaseTypeNode(declaration);\n                if (baseTypeNode) {\n                    var baseType = getTypeFromTypeReferenceNode(baseTypeNode);\n                    if (baseType !== unknownType) {\n                        if (getTargetType(baseType).flags & 1024 /* Class */) {\n                            if (type !== baseType && !hasBaseType(baseType, type)) {\n                                type.baseTypes.push(baseType);\n                            }\n                            else {\n                                error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */));\n                            }\n                        }\n                        else {\n                            error(baseTypeNode, ts.Diagnostics.A_class_may_only_extend_another_class);\n                        }\n                    }\n                }\n                type.declaredProperties = getNamedMembers(symbol.members);\n                type.declaredCallSignatures = emptyArray;\n                type.declaredConstructSignatures = emptyArray;\n                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);\n                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);\n            }\n            return links.declaredType;\n        }\n        function getDeclaredTypeOfInterface(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.declaredType) {\n                var type = links.declaredType = createObjectType(2048 /* Interface */, symbol);\n                var typeParameters = getTypeParametersOfClassOrInterface(symbol);\n                if (typeParameters) {\n                    type.flags |= 4096 /* Reference */;\n                    type.typeParameters = typeParameters;\n                    type.instantiations = {};\n                    type.instantiations[getTypeListId(type.typeParameters)] = type;\n                    type.target = type;\n                    type.typeArguments = type.typeParameters;\n                }\n                type.baseTypes = [];\n                ts.forEach(symbol.declarations, function (declaration) {\n                    if (declaration.kind === 186 /* InterfaceDeclaration */ && ts.getInterfaceBaseTypeNodes(declaration)) {\n                        ts.forEach(ts.getInterfaceBaseTypeNodes(declaration), function (node) {\n                            var baseType = getTypeFromTypeReferenceNode(node);\n                            if (baseType !== unknownType) {\n                                if (getTargetType(baseType).flags & (1024 /* Class */ | 2048 /* Interface */)) {\n                                    if (type !== baseType && !hasBaseType(baseType, type)) {\n                                        type.baseTypes.push(baseType);\n                                    }\n                                    else {\n                                        error(declaration, ts.Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */));\n                                    }\n                                }\n                                else {\n                                    error(node, ts.Diagnostics.An_interface_may_only_extend_a_class_or_another_interface);\n                                }\n                            }\n                        });\n                    }\n                });\n                type.declaredProperties = getNamedMembers(symbol.members);\n                type.declaredCallSignatures = getSignaturesOfSymbol(symbol.members[\"__call\"]);\n                type.declaredConstructSignatures = getSignaturesOfSymbol(symbol.members[\"__new\"]);\n                type.declaredStringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);\n                type.declaredNumberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);\n            }\n            return links.declaredType;\n        }\n        function getDeclaredTypeOfTypeAlias(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.declaredType) {\n                links.declaredType = resolvingType;\n                var declaration = ts.getDeclarationOfKind(symbol, 187 /* TypeAliasDeclaration */);\n                var type = getTypeFromTypeNode(declaration.type);\n                if (links.declaredType === resolvingType) {\n                    links.declaredType = type;\n                }\n            }\n            else if (links.declaredType === resolvingType) {\n                links.declaredType = unknownType;\n                var declaration = ts.getDeclarationOfKind(symbol, 187 /* TypeAliasDeclaration */);\n                error(declaration.name, ts.Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));\n            }\n            return links.declaredType;\n        }\n        function getDeclaredTypeOfEnum(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.declaredType) {\n                var type = createType(128 /* Enum */);\n                type.symbol = symbol;\n                links.declaredType = type;\n            }\n            return links.declaredType;\n        }\n        function getDeclaredTypeOfTypeParameter(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.declaredType) {\n                var type = createType(512 /* TypeParameter */);\n                type.symbol = symbol;\n                if (!ts.getDeclarationOfKind(symbol, 122 /* TypeParameter */).constraint) {\n                    type.constraint = noConstraintType;\n                }\n                links.declaredType = type;\n            }\n            return links.declaredType;\n        }\n        function getDeclaredTypeOfImport(symbol) {\n            var links = getSymbolLinks(symbol);\n            if (!links.declaredType) {\n                links.declaredType = getDeclaredTypeOfSymbol(resolveImport(symbol));\n            }\n            return links.declaredType;\n        }\n        function getDeclaredTypeOfSymbol(symbol) {\n            ts.Debug.assert((symbol.flags & 67108864 /* Instantiated */) === 0);\n            if (symbol.flags & 32 /* Class */) {\n                return getDeclaredTypeOfClass(symbol);\n            }\n            if (symbol.flags & 64 /* Interface */) {\n                return getDeclaredTypeOfInterface(symbol);\n            }\n            if (symbol.flags & 2097152 /* TypeAlias */) {\n                return getDeclaredTypeOfTypeAlias(symbol);\n            }\n            if (symbol.flags & 384 /* Enum */) {\n                return getDeclaredTypeOfEnum(symbol);\n            }\n            if (symbol.flags & 1048576 /* TypeParameter */) {\n                return getDeclaredTypeOfTypeParameter(symbol);\n            }\n            if (symbol.flags & 33554432 /* Import */) {\n                return getDeclaredTypeOfImport(symbol);\n            }\n            return unknownType;\n        }\n        function createSymbolTable(symbols) {\n            var result = {};\n            for (var i = 0; i < symbols.length; i++) {\n                var symbol = symbols[i];\n                result[symbol.name] = symbol;\n            }\n            return result;\n        }\n        function createInstantiatedSymbolTable(symbols, mapper) {\n            var result = {};\n            for (var i = 0; i < symbols.length; i++) {\n                var symbol = symbols[i];\n                result[symbol.name] = instantiateSymbol(symbol, mapper);\n            }\n            return result;\n        }\n        function addInheritedMembers(symbols, baseSymbols) {\n            for (var i = 0; i < baseSymbols.length; i++) {\n                var s = baseSymbols[i];\n                if (!ts.hasProperty(symbols, s.name)) {\n                    symbols[s.name] = s;\n                }\n            }\n        }\n        function addInheritedSignatures(signatures, baseSignatures) {\n            if (baseSignatures) {\n                for (var i = 0; i < baseSignatures.length; i++) {\n                    signatures.push(baseSignatures[i]);\n                }\n            }\n        }\n        function resolveClassOrInterfaceMembers(type) {\n            var members = type.symbol.members;\n            var callSignatures = type.declaredCallSignatures;\n            var constructSignatures = type.declaredConstructSignatures;\n            var stringIndexType = type.declaredStringIndexType;\n            var numberIndexType = type.declaredNumberIndexType;\n            if (type.baseTypes.length) {\n                members = createSymbolTable(type.declaredProperties);\n                ts.forEach(type.baseTypes, function (baseType) {\n                    addInheritedMembers(members, getPropertiesOfObjectType(baseType));\n                    callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(baseType, 0 /* Call */));\n                    constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(baseType, 1 /* Construct */));\n                    stringIndexType = stringIndexType || getIndexTypeOfType(baseType, 0 /* String */);\n                    numberIndexType = numberIndexType || getIndexTypeOfType(baseType, 1 /* Number */);\n                });\n            }\n            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\n        }\n        function resolveTypeReferenceMembers(type) {\n            var target = type.target;\n            var mapper = createTypeMapper(target.typeParameters, type.typeArguments);\n            var members = createInstantiatedSymbolTable(target.declaredProperties, mapper);\n            var callSignatures = instantiateList(target.declaredCallSignatures, mapper, instantiateSignature);\n            var constructSignatures = instantiateList(target.declaredConstructSignatures, mapper, instantiateSignature);\n            var stringIndexType = target.declaredStringIndexType ? instantiateType(target.declaredStringIndexType, mapper) : undefined;\n            var numberIndexType = target.declaredNumberIndexType ? instantiateType(target.declaredNumberIndexType, mapper) : undefined;\n            ts.forEach(target.baseTypes, function (baseType) {\n                var instantiatedBaseType = instantiateType(baseType, mapper);\n                addInheritedMembers(members, getPropertiesOfObjectType(instantiatedBaseType));\n                callSignatures = ts.concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0 /* Call */));\n                constructSignatures = ts.concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1 /* Construct */));\n                stringIndexType = stringIndexType || getIndexTypeOfType(instantiatedBaseType, 0 /* String */);\n                numberIndexType = numberIndexType || getIndexTypeOfType(instantiatedBaseType, 1 /* Number */);\n            });\n            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\n        }\n        function createSignature(declaration, typeParameters, parameters, resolvedReturnType, minArgumentCount, hasRestParameter, hasStringLiterals) {\n            var sig = new Signature(checker);\n            sig.declaration = declaration;\n            sig.typeParameters = typeParameters;\n            sig.parameters = parameters;\n            sig.resolvedReturnType = resolvedReturnType;\n            sig.minArgumentCount = minArgumentCount;\n            sig.hasRestParameter = hasRestParameter;\n            sig.hasStringLiterals = hasStringLiterals;\n            return sig;\n        }\n        function cloneSignature(sig) {\n            return createSignature(sig.declaration, sig.typeParameters, sig.parameters, sig.resolvedReturnType, sig.minArgumentCount, sig.hasRestParameter, sig.hasStringLiterals);\n        }\n        function getDefaultConstructSignatures(classType) {\n            if (classType.baseTypes.length) {\n                var baseType = classType.baseTypes[0];\n                var baseSignatures = getSignaturesOfType(getTypeOfSymbol(baseType.symbol), 1 /* Construct */);\n                return ts.map(baseSignatures, function (baseSignature) {\n                    var signature = baseType.flags & 4096 /* Reference */ ? getSignatureInstantiation(baseSignature, baseType.typeArguments) : cloneSignature(baseSignature);\n                    signature.typeParameters = classType.typeParameters;\n                    signature.resolvedReturnType = classType;\n                    return signature;\n                });\n            }\n            return [createSignature(undefined, classType.typeParameters, emptyArray, classType, 0, false, false)];\n        }\n        function createTupleTypeMemberSymbols(memberTypes) {\n            var members = {};\n            for (var i = 0; i < memberTypes.length; i++) {\n                var symbol = createSymbol(4 /* Property */ | 268435456 /* Transient */, \"\" + i);\n                symbol.type = memberTypes[i];\n                members[i] = symbol;\n            }\n            return members;\n        }\n        function resolveTupleTypeMembers(type) {\n            var arrayType = resolveObjectOrUnionTypeMembers(createArrayType(getUnionType(type.elementTypes)));\n            var members = createTupleTypeMemberSymbols(type.elementTypes);\n            addInheritedMembers(members, arrayType.properties);\n            setObjectTypeMembers(type, members, arrayType.callSignatures, arrayType.constructSignatures, arrayType.stringIndexType, arrayType.numberIndexType);\n        }\n        function signatureListsIdentical(s, t) {\n            if (s.length !== t.length) {\n                return false;\n            }\n            for (var i = 0; i < s.length; i++) {\n                if (!compareSignatures(s[i], t[i], false, compareTypes)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        // If the lists of call or construct signatures in the given types are all identical except for return types,\n        // and if none of the signatures are generic, return a list of signatures that has substitutes a union of the\n        // return types of the corresponding signatures in each resulting signature.\n        function getUnionSignatures(types, kind) {\n            var signatureLists = ts.map(types, function (t) { return getSignaturesOfType(t, kind); });\n            var signatures = signatureLists[0];\n            for (var i = 0; i < signatures.length; i++) {\n                if (signatures[i].typeParameters) {\n                    return emptyArray;\n                }\n            }\n            for (var i = 1; i < signatureLists.length; i++) {\n                if (!signatureListsIdentical(signatures, signatureLists[i])) {\n                    return emptyArray;\n                }\n            }\n            var result = ts.map(signatures, cloneSignature);\n            for (var i = 0; i < result.length; i++) {\n                var s = result[i];\n                // Clear resolved return type we possibly got from cloneSignature\n                s.resolvedReturnType = undefined;\n                s.unionSignatures = ts.map(signatureLists, function (signatures) { return signatures[i]; });\n            }\n            return result;\n        }\n        function getUnionIndexType(types, kind) {\n            var indexTypes = [];\n            for (var i = 0; i < types.length; i++) {\n                var indexType = getIndexTypeOfType(types[i], kind);\n                if (!indexType) {\n                    return undefined;\n                }\n                indexTypes.push(indexType);\n            }\n            return getUnionType(indexTypes);\n        }\n        function resolveUnionTypeMembers(type) {\n            // The members and properties collections are empty for union types. To get all properties of a union\n            // type use getPropertiesOfType (only the language service uses this).\n            var callSignatures = getUnionSignatures(type.types, 0 /* Call */);\n            var constructSignatures = getUnionSignatures(type.types, 1 /* Construct */);\n            var stringIndexType = getUnionIndexType(type.types, 0 /* String */);\n            var numberIndexType = getUnionIndexType(type.types, 1 /* Number */);\n            setObjectTypeMembers(type, emptySymbols, callSignatures, constructSignatures, stringIndexType, numberIndexType);\n        }\n        function resolveAnonymousTypeMembers(type) {\n            var symbol = type.symbol;\n            if (symbol.flags & 2048 /* TypeLiteral */) {\n                var members = symbol.members;\n                var callSignatures = getSignaturesOfSymbol(members[\"__call\"]);\n                var constructSignatures = getSignaturesOfSymbol(members[\"__new\"]);\n                var stringIndexType = getIndexTypeOfSymbol(symbol, 0 /* String */);\n                var numberIndexType = getIndexTypeOfSymbol(symbol, 1 /* Number */);\n            }\n            else {\n                // Combinations of function, class, enum and module\n                var members = emptySymbols;\n                var callSignatures = emptyArray;\n                var constructSignatures = emptyArray;\n                if (symbol.flags & 1952 /* HasExports */) {\n                    members = symbol.exports;\n                }\n                if (symbol.flags & (16 /* Function */ | 8192 /* Method */)) {\n                    callSignatures = getSignaturesOfSymbol(symbol);\n                }\n                if (symbol.flags & 32 /* Class */) {\n                    var classType = getDeclaredTypeOfClass(symbol);\n                    constructSignatures = getSignaturesOfSymbol(symbol.members[\"__constructor\"]);\n                    if (!constructSignatures.length) {\n                        constructSignatures = getDefaultConstructSignatures(classType);\n                    }\n                    if (classType.baseTypes.length) {\n                        members = createSymbolTable(getNamedMembers(members));\n                        addInheritedMembers(members, getPropertiesOfObjectType(getTypeOfSymbol(classType.baseTypes[0].symbol)));\n                    }\n                }\n                var stringIndexType = undefined;\n                var numberIndexType = (symbol.flags & 384 /* Enum */) ? stringType : undefined;\n            }\n            setObjectTypeMembers(type, members, callSignatures, constructSignatures, stringIndexType, numberIndexType);\n        }\n        function resolveObjectOrUnionTypeMembers(type) {\n            if (!type.members) {\n                if (type.flags & (1024 /* Class */ | 2048 /* Interface */)) {\n                    resolveClassOrInterfaceMembers(type);\n                }\n                else if (type.flags & 32768 /* Anonymous */) {\n                    resolveAnonymousTypeMembers(type);\n                }\n                else if (type.flags & 8192 /* Tuple */) {\n                    resolveTupleTypeMembers(type);\n                }\n                else if (type.flags & 16384 /* Union */) {\n                    resolveUnionTypeMembers(type);\n                }\n                else {\n                    resolveTypeReferenceMembers(type);\n                }\n            }\n            return type;\n        }\n        // Return properties of an object type or an empty array for other types\n        function getPropertiesOfObjectType(type) {\n            if (type.flags & 48128 /* ObjectType */) {\n                return resolveObjectOrUnionTypeMembers(type).properties;\n            }\n            return emptyArray;\n        }\n        // If the given type is an object type and that type has a property by the given name, return\n        // the symbol for that property. Otherwise return undefined.\n        function getPropertyOfObjectType(type, name) {\n            if (type.flags & 48128 /* ObjectType */) {\n                var resolved = resolveObjectOrUnionTypeMembers(type);\n                if (ts.hasProperty(resolved.members, name)) {\n                    var symbol = resolved.members[name];\n                    if (symbolIsValue(symbol)) {\n                        return symbol;\n                    }\n                }\n            }\n        }\n        function getPropertiesOfUnionType(type) {\n            var result = [];\n            ts.forEach(getPropertiesOfType(type.types[0]), function (prop) {\n                var unionProp = getPropertyOfUnionType(type, prop.name);\n                if (unionProp) {\n                    result.push(unionProp);\n                }\n            });\n            return result;\n        }\n        function getPropertiesOfType(type) {\n            if (type.flags & 16384 /* Union */) {\n                return getPropertiesOfUnionType(type);\n            }\n            return getPropertiesOfObjectType(getApparentType(type));\n        }\n        // For a type parameter, return the base constraint of the type parameter. For the string, number, and\n        // boolean primitive types, return the corresponding object types.Otherwise return the type itself.\n        // Note that the apparent type of a union type is the union type itself.\n        function getApparentType(type) {\n            if (type.flags & 512 /* TypeParameter */) {\n                do {\n                    type = getConstraintOfTypeParameter(type);\n                } while (type && type.flags & 512 /* TypeParameter */);\n                if (!type) {\n                    type = emptyObjectType;\n                }\n            }\n            if (type.flags & 258 /* StringLike */) {\n                type = globalStringType;\n            }\n            else if (type.flags & 132 /* NumberLike */) {\n                type = globalNumberType;\n            }\n            else if (type.flags & 8 /* Boolean */) {\n                type = globalBooleanType;\n            }\n            return type;\n        }\n        function createUnionProperty(unionType, name) {\n            var types = unionType.types;\n            var props;\n            for (var i = 0; i < types.length; i++) {\n                var type = getApparentType(types[i]);\n                if (type !== unknownType) {\n                    var prop = getPropertyOfType(type, name);\n                    if (!prop) {\n                        return undefined;\n                    }\n                    if (!props) {\n                        props = [prop];\n                    }\n                    else {\n                        props.push(prop);\n                    }\n                }\n            }\n            var propTypes = [];\n            var declarations = [];\n            for (var i = 0; i < props.length; i++) {\n                var prop = props[i];\n                if (prop.declarations) {\n                    declarations.push.apply(declarations, prop.declarations);\n                }\n                propTypes.push(getTypeOfSymbol(prop));\n            }\n            var result = createSymbol(4 /* Property */ | 268435456 /* Transient */ | 1073741824 /* UnionProperty */, name);\n            result.unionType = unionType;\n            result.declarations = declarations;\n            result.type = getUnionType(propTypes);\n            return result;\n        }\n        function getPropertyOfUnionType(type, name) {\n            var properties = type.resolvedProperties || (type.resolvedProperties = {});\n            if (ts.hasProperty(properties, name)) {\n                return properties[name];\n            }\n            var property = createUnionProperty(type, name);\n            if (property) {\n                properties[name] = property;\n            }\n            return property;\n        }\n        // Return the symbol for the property with the given name in the given type. Creates synthetic union properties when\n        // necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from\n        // Object and Function as appropriate.\n        function getPropertyOfType(type, name) {\n            if (type.flags & 16384 /* Union */) {\n                return getPropertyOfUnionType(type, name);\n            }\n            if (!(type.flags & 48128 /* ObjectType */)) {\n                type = getApparentType(type);\n                if (!(type.flags & 48128 /* ObjectType */)) {\n                    return undefined;\n                }\n            }\n            var resolved = resolveObjectOrUnionTypeMembers(type);\n            if (ts.hasProperty(resolved.members, name)) {\n                var symbol = resolved.members[name];\n                if (symbolIsValue(symbol)) {\n                    return symbol;\n                }\n            }\n            if (resolved === anyFunctionType || resolved.callSignatures.length || resolved.constructSignatures.length) {\n                var symbol = getPropertyOfObjectType(globalFunctionType, name);\n                if (symbol)\n                    return symbol;\n            }\n            return getPropertyOfObjectType(globalObjectType, name);\n        }\n        function getSignaturesOfObjectOrUnionType(type, kind) {\n            if (type.flags & (48128 /* ObjectType */ | 16384 /* Union */)) {\n                var resolved = resolveObjectOrUnionTypeMembers(type);\n                return kind === 0 /* Call */ ? resolved.callSignatures : resolved.constructSignatures;\n            }\n            return emptyArray;\n        }\n        // Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and\n        // maps primitive types and type parameters are to their apparent types.\n        function getSignaturesOfType(type, kind) {\n            return getSignaturesOfObjectOrUnionType(getApparentType(type), kind);\n        }\n        function getIndexTypeOfObjectOrUnionType(type, kind) {\n            if (type.flags & (48128 /* ObjectType */ | 16384 /* Union */)) {\n                var resolved = resolveObjectOrUnionTypeMembers(type);\n                return kind === 0 /* String */ ? resolved.stringIndexType : resolved.numberIndexType;\n            }\n        }\n        // Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and\n        // maps primitive types and type parameters are to their apparent types.\n        function getIndexTypeOfType(type, kind) {\n            return getIndexTypeOfObjectOrUnionType(getApparentType(type), kind);\n        }\n        // Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual\n        // type checking functions).\n        function getTypeParametersFromDeclaration(typeParameterDeclarations) {\n            var result = [];\n            ts.forEach(typeParameterDeclarations, function (node) {\n                var tp = getDeclaredTypeOfTypeParameter(node.symbol);\n                if (!ts.contains(result, tp)) {\n                    result.push(tp);\n                }\n            });\n            return result;\n        }\n        function getSignatureFromDeclaration(declaration) {\n            var links = getNodeLinks(declaration);\n            if (!links.resolvedSignature) {\n                var classType = declaration.kind === 126 /* Constructor */ ? getDeclaredTypeOfClass(declaration.parent.symbol) : undefined;\n                var typeParameters = classType ? classType.typeParameters : declaration.typeParameters ? getTypeParametersFromDeclaration(declaration.typeParameters) : undefined;\n                var parameters = [];\n                var hasStringLiterals = false;\n                var minArgumentCount = -1;\n                for (var i = 0, n = declaration.parameters.length; i < n; i++) {\n                    var param = declaration.parameters[i];\n                    parameters.push(param.symbol);\n                    if (param.type && param.type.kind === 7 /* StringLiteral */) {\n                        hasStringLiterals = true;\n                    }\n                    if (minArgumentCount < 0) {\n                        if (param.initializer || param.questionToken || param.dotDotDotToken) {\n                            minArgumentCount = i;\n                        }\n                    }\n                }\n                if (minArgumentCount < 0) {\n                    minArgumentCount = declaration.parameters.length;\n                }\n                var returnType;\n                if (classType) {\n                    returnType = classType;\n                }\n                else if (declaration.type) {\n                    returnType = getTypeFromTypeNode(declaration.type);\n                }\n                else {\n                    // TypeScript 1.0 spec (April 2014):\n                    // If only one accessor includes a type annotation, the other behaves as if it had the same type annotation.\n                    if (declaration.kind === 127 /* GetAccessor */ && !ts.hasComputedNameButNotSymbol(declaration)) {\n                        var setter = ts.getDeclarationOfKind(declaration.symbol, 128 /* SetAccessor */);\n                        returnType = getAnnotatedAccessorType(setter);\n                    }\n                    if (!returnType && !declaration.body) {\n                        returnType = anyType;\n                    }\n                }\n                links.resolvedSignature = createSignature(declaration, typeParameters, parameters, returnType, minArgumentCount, ts.hasRestParameters(declaration), hasStringLiterals);\n            }\n            return links.resolvedSignature;\n        }\n        function getSignaturesOfSymbol(symbol) {\n            if (!symbol)\n                return emptyArray;\n            var result = [];\n            for (var i = 0, len = symbol.declarations.length; i < len; i++) {\n                var node = symbol.declarations[i];\n                switch (node.kind) {\n                    case 133 /* FunctionType */:\n                    case 134 /* ConstructorType */:\n                    case 184 /* FunctionDeclaration */:\n                    case 125 /* Method */:\n                    case 126 /* Constructor */:\n                    case 129 /* CallSignature */:\n                    case 130 /* ConstructSignature */:\n                    case 131 /* IndexSignature */:\n                    case 127 /* GetAccessor */:\n                    case 128 /* SetAccessor */:\n                    case 150 /* FunctionExpression */:\n                    case 151 /* ArrowFunction */:\n                        // Don't include signature if node is the implementation of an overloaded function. A node is considered\n                        // an implementation node if it has a body and the previous node is of the same kind and immediately\n                        // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).\n                        if (i > 0 && node.body) {\n                            var previous = symbol.declarations[i - 1];\n                            if (node.parent === previous.parent && node.kind === previous.kind && node.pos === previous.end) {\n                                break;\n                            }\n                        }\n                        result.push(getSignatureFromDeclaration(node));\n                }\n            }\n            return result;\n        }\n        function getReturnTypeOfSignature(signature) {\n            if (!signature.resolvedReturnType) {\n                signature.resolvedReturnType = resolvingType;\n                if (signature.target) {\n                    var type = instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper);\n                }\n                else if (signature.unionSignatures) {\n                    var type = getUnionType(ts.map(signature.unionSignatures, getReturnTypeOfSignature));\n                }\n                else {\n                    var type = getReturnTypeFromBody(signature.declaration);\n                }\n                if (signature.resolvedReturnType === resolvingType) {\n                    signature.resolvedReturnType = type;\n                }\n            }\n            else if (signature.resolvedReturnType === resolvingType) {\n                signature.resolvedReturnType = anyType;\n                if (compilerOptions.noImplicitAny) {\n                    var declaration = signature.declaration;\n                    if (declaration.name) {\n                        error(declaration.name, ts.Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, ts.declarationNameToString(declaration.name));\n                    }\n                    else {\n                        error(declaration, ts.Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);\n                    }\n                }\n            }\n            return signature.resolvedReturnType;\n        }\n        function getRestTypeOfSignature(signature) {\n            if (signature.hasRestParameter) {\n                var type = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);\n                if (type.flags & 4096 /* Reference */ && type.target === globalArrayType) {\n                    return type.typeArguments[0];\n                }\n            }\n            return anyType;\n        }\n        function getSignatureInstantiation(signature, typeArguments) {\n            return instantiateSignature(signature, createTypeMapper(signature.typeParameters, typeArguments), true);\n        }\n        function getErasedSignature(signature) {\n            if (!signature.typeParameters)\n                return signature;\n            if (!signature.erasedSignatureCache) {\n                if (signature.target) {\n                    signature.erasedSignatureCache = instantiateSignature(getErasedSignature(signature.target), signature.mapper);\n                }\n                else {\n                    signature.erasedSignatureCache = instantiateSignature(signature, createTypeEraser(signature.typeParameters), true);\n                }\n            }\n            return signature.erasedSignatureCache;\n        }\n        function getOrCreateTypeFromSignature(signature) {\n            // There are two ways to declare a construct signature, one is by declaring a class constructor\n            // using the constructor keyword, and the other is declaring a bare construct signature in an\n            // object type literal or interface (using the new keyword). Each way of declaring a constructor\n            // will result in a different declaration kind.\n            if (!signature.isolatedSignatureType) {\n                var isConstructor = signature.declaration.kind === 126 /* Constructor */ || signature.declaration.kind === 130 /* ConstructSignature */;\n                var type = createObjectType(32768 /* Anonymous */ | 65536 /* FromSignature */);\n                type.members = emptySymbols;\n                type.properties = emptyArray;\n                type.callSignatures = !isConstructor ? [signature] : emptyArray;\n                type.constructSignatures = isConstructor ? [signature] : emptyArray;\n                signature.isolatedSignatureType = type;\n            }\n            return signature.isolatedSignatureType;\n        }\n        function getIndexSymbol(symbol) {\n            return symbol.members[\"__index\"];\n        }\n        function getIndexDeclarationOfSymbol(symbol, kind) {\n            var syntaxKind = kind === 1 /* Number */ ? 116 /* NumberKeyword */ : 118 /* StringKeyword */;\n            var indexSymbol = getIndexSymbol(symbol);\n            if (indexSymbol) {\n                var len = indexSymbol.declarations.length;\n                for (var i = 0; i < len; i++) {\n                    var node = indexSymbol.declarations[i];\n                    if (node.parameters.length === 1) {\n                        var parameter = node.parameters[0];\n                        if (parameter && parameter.type && parameter.type.kind === syntaxKind) {\n                            return node;\n                        }\n                    }\n                }\n            }\n            return undefined;\n        }\n        function getIndexTypeOfSymbol(symbol, kind) {\n            var declaration = getIndexDeclarationOfSymbol(symbol, kind);\n            return declaration ? declaration.type ? getTypeFromTypeNode(declaration.type) : anyType : undefined;\n        }\n        function getConstraintOfTypeParameter(type) {\n            if (!type.constraint) {\n                if (type.target) {\n                    var targetConstraint = getConstraintOfTypeParameter(type.target);\n                    type.constraint = targetConstraint ? instantiateType(targetConstraint, type.mapper) : noConstraintType;\n                }\n                else {\n                    type.constraint = getTypeFromTypeNode(ts.getDeclarationOfKind(type.symbol, 122 /* TypeParameter */).constraint);\n                }\n            }\n            return type.constraint === noConstraintType ? undefined : type.constraint;\n        }\n        function getTypeListId(types) {\n            switch (types.length) {\n                case 1:\n                    return \"\" + types[0].id;\n                case 2:\n                    return types[0].id + \",\" + types[1].id;\n                default:\n                    var result = \"\";\n                    for (var i = 0; i < types.length; i++) {\n                        if (i > 0)\n                            result += \",\";\n                        result += types[i].id;\n                    }\n                    return result;\n            }\n        }\n        function createTypeReference(target, typeArguments) {\n            var id = getTypeListId(typeArguments);\n            var type = target.instantiations[id];\n            if (!type) {\n                type = target.instantiations[id] = createObjectType(4096 /* Reference */, target.symbol);\n                type.target = target;\n                type.typeArguments = typeArguments;\n            }\n            return type;\n        }\n        function isTypeParameterReferenceIllegalInConstraint(typeReferenceNode, typeParameterSymbol) {\n            var links = getNodeLinks(typeReferenceNode);\n            if (links.isIllegalTypeReferenceInConstraint !== undefined) {\n                return links.isIllegalTypeReferenceInConstraint;\n            }\n            // bubble up to the declaration\n            var currentNode = typeReferenceNode;\n            while (!ts.forEach(typeParameterSymbol.declarations, function (d) { return d.parent === currentNode.parent; })) {\n                currentNode = currentNode.parent;\n            }\n            // if last step was made from the type parameter this means that path has started somewhere in constraint which is illegal\n            links.isIllegalTypeReferenceInConstraint = currentNode.kind === 122 /* TypeParameter */;\n            return links.isIllegalTypeReferenceInConstraint;\n        }\n        function checkTypeParameterHasIllegalReferencesInConstraint(typeParameter) {\n            var typeParameterSymbol;\n            function check(n) {\n                if (n.kind === 132 /* TypeReference */ && n.typeName.kind === 63 /* Identifier */) {\n                    var links = getNodeLinks(n);\n                    if (links.isIllegalTypeReferenceInConstraint === undefined) {\n                        var symbol = resolveName(typeParameter, n.typeName.text, 3152352 /* Type */, undefined, undefined);\n                        if (symbol && (symbol.flags & 1048576 /* TypeParameter */)) {\n                            // TypeScript 1.0 spec (April 2014): 3.4.1\n                            // Type parameters declared in a particular type parameter list \n                            // may not be referenced in constraints in that type parameter list\n                            // symbol.declaration.parent === typeParameter.parent\n                            // -> typeParameter and symbol.declaration originate from the same type parameter list \n                            // -> illegal for all declarations in symbol\n                            // forEach === exists\n                            links.isIllegalTypeReferenceInConstraint = ts.forEach(symbol.declarations, function (d) { return d.parent == typeParameter.parent; });\n                        }\n                    }\n                    if (links.isIllegalTypeReferenceInConstraint) {\n                        error(typeParameter, ts.Diagnostics.Constraint_of_a_type_parameter_cannot_reference_any_type_parameter_from_the_same_type_parameter_list);\n                    }\n                }\n                ts.forEachChild(n, check);\n            }\n            if (typeParameter.constraint) {\n                typeParameterSymbol = getSymbolOfNode(typeParameter);\n                check(typeParameter.constraint);\n            }\n        }\n        function getTypeFromTypeReferenceNode(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedType) {\n                var symbol = resolveEntityName(node, node.typeName, 3152352 /* Type */);\n                if (symbol) {\n                    var type;\n                    if ((symbol.flags & 1048576 /* TypeParameter */) && isTypeParameterReferenceIllegalInConstraint(node, symbol)) {\n                        // TypeScript 1.0 spec (April 2014): 3.4.1\n                        // Type parameters declared in a particular type parameter list \n                        // may not be referenced in constraints in that type parameter list\n                        // Implementation: such type references are resolved to 'unknown' type that usually denotes error\n                        type = unknownType;\n                    }\n                    else {\n                        type = getDeclaredTypeOfSymbol(symbol);\n                        if (type.flags & (1024 /* Class */ | 2048 /* Interface */) && type.flags & 4096 /* Reference */) {\n                            var typeParameters = type.typeParameters;\n                            if (node.typeArguments && node.typeArguments.length === typeParameters.length) {\n                                type = createTypeReference(type, ts.map(node.typeArguments, getTypeFromTypeNode));\n                            }\n                            else {\n                                error(node, ts.Diagnostics.Generic_type_0_requires_1_type_argument_s, typeToString(type, undefined, 1 /* WriteArrayAsGenericType */), typeParameters.length);\n                                type = undefined;\n                            }\n                        }\n                        else {\n                            if (node.typeArguments) {\n                                error(node, ts.Diagnostics.Type_0_is_not_generic, typeToString(type));\n                                type = undefined;\n                            }\n                        }\n                    }\n                }\n                links.resolvedType = type || unknownType;\n            }\n            return links.resolvedType;\n        }\n        function getTypeFromTypeQueryNode(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedType) {\n                // TypeScript 1.0 spec (April 2014): 3.6.3\n                // The expression is processed as an identifier expression (section 4.3)\n                // or property access expression(section 4.10),\n                // the widened type(section 3.9) of which becomes the result. \n                links.resolvedType = getWidenedType(checkExpressionOrQualifiedName(node.exprName));\n            }\n            return links.resolvedType;\n        }\n        function getTypeOfGlobalSymbol(symbol, arity) {\n            function getTypeDeclaration(symbol) {\n                var declarations = symbol.declarations;\n                for (var i = 0; i < declarations.length; i++) {\n                    var declaration = declarations[i];\n                    switch (declaration.kind) {\n                        case 185 /* ClassDeclaration */:\n                        case 186 /* InterfaceDeclaration */:\n                        case 188 /* EnumDeclaration */:\n                            return declaration;\n                    }\n                }\n            }\n            if (!symbol) {\n                return emptyObjectType;\n            }\n            var type = getDeclaredTypeOfSymbol(symbol);\n            if (!(type.flags & 48128 /* ObjectType */)) {\n                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbol.name);\n                return emptyObjectType;\n            }\n            if ((type.typeParameters ? type.typeParameters.length : 0) !== arity) {\n                error(getTypeDeclaration(symbol), ts.Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbol.name, arity);\n                return emptyObjectType;\n            }\n            return type;\n        }\n        function getGlobalSymbol(name) {\n            return resolveName(undefined, name, 3152352 /* Type */, ts.Diagnostics.Cannot_find_global_type_0, name);\n        }\n        function getGlobalType(name) {\n            return getTypeOfGlobalSymbol(getGlobalSymbol(name), 0);\n        }\n        function createArrayType(elementType) {\n            // globalArrayType will be undefined if we get here during creation of the Array type. This for example happens if\n            // user code augments the Array type with call or construct signatures that have an array type as the return type.\n            // We instead use globalArraySymbol to obtain the (not yet fully constructed) Array type.\n            var arrayType = globalArrayType || getDeclaredTypeOfSymbol(globalArraySymbol);\n            return arrayType !== emptyObjectType ? createTypeReference(arrayType, [elementType]) : emptyObjectType;\n        }\n        function getTypeFromArrayTypeNode(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedType) {\n                links.resolvedType = createArrayType(getTypeFromTypeNode(node.elementType));\n            }\n            return links.resolvedType;\n        }\n        function createTupleType(elementTypes) {\n            var id = getTypeListId(elementTypes);\n            var type = tupleTypes[id];\n            if (!type) {\n                type = tupleTypes[id] = createObjectType(8192 /* Tuple */);\n                type.elementTypes = elementTypes;\n            }\n            return type;\n        }\n        function getTypeFromTupleTypeNode(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedType) {\n                links.resolvedType = createTupleType(ts.map(node.elementTypes, getTypeFromTypeNode));\n            }\n            return links.resolvedType;\n        }\n        function addTypeToSortedSet(sortedSet, type) {\n            if (type.flags & 16384 /* Union */) {\n                addTypesToSortedSet(sortedSet, type.types);\n            }\n            else {\n                var i = 0;\n                var id = type.id;\n                while (i < sortedSet.length && sortedSet[i].id < id) {\n                    i++;\n                }\n                if (i === sortedSet.length || sortedSet[i].id !== id) {\n                    sortedSet.splice(i, 0, type);\n                }\n            }\n        }\n        function addTypesToSortedSet(sortedTypes, types) {\n            for (var i = 0, len = types.length; i < len; i++) {\n                addTypeToSortedSet(sortedTypes, types[i]);\n            }\n        }\n        function isSubtypeOfAny(candidate, types) {\n            for (var i = 0, len = types.length; i < len; i++) {\n                if (candidate !== types[i] && isTypeSubtypeOf(candidate, types[i])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function removeSubtypes(types) {\n            var i = types.length;\n            while (i > 0) {\n                i--;\n                if (isSubtypeOfAny(types[i], types)) {\n                    types.splice(i, 1);\n                }\n            }\n        }\n        function containsAnyType(types) {\n            for (var i = 0; i < types.length; i++) {\n                if (types[i].flags & 1 /* Any */) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function removeAllButLast(types, typeToRemove) {\n            var i = types.length;\n            while (i > 0 && types.length > 1) {\n                i--;\n                if (types[i] === typeToRemove) {\n                    types.splice(i, 1);\n                }\n            }\n        }\n        function getUnionType(types, noSubtypeReduction) {\n            if (types.length === 0) {\n                return emptyObjectType;\n            }\n            var sortedTypes = [];\n            addTypesToSortedSet(sortedTypes, types);\n            if (noSubtypeReduction) {\n                if (containsAnyType(sortedTypes)) {\n                    return anyType;\n                }\n                removeAllButLast(sortedTypes, undefinedType);\n                removeAllButLast(sortedTypes, nullType);\n            }\n            else {\n                removeSubtypes(sortedTypes);\n            }\n            if (sortedTypes.length === 1) {\n                return sortedTypes[0];\n            }\n            var id = getTypeListId(sortedTypes);\n            var type = unionTypes[id];\n            if (!type) {\n                type = unionTypes[id] = createObjectType(16384 /* Union */);\n                type.types = sortedTypes;\n            }\n            return type;\n        }\n        function getTypeFromUnionTypeNode(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedType) {\n                links.resolvedType = getUnionType(ts.map(node.types, getTypeFromTypeNode), true);\n            }\n            return links.resolvedType;\n        }\n        function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedType) {\n                // Deferred resolution of members is handled by resolveObjectTypeMembers\n                links.resolvedType = createObjectType(32768 /* Anonymous */, node.symbol);\n            }\n            return links.resolvedType;\n        }\n        function getStringLiteralType(node) {\n            if (ts.hasProperty(stringLiteralTypes, node.text)) {\n                return stringLiteralTypes[node.text];\n            }\n            var type = stringLiteralTypes[node.text] = createType(256 /* StringLiteral */);\n            type.text = ts.getTextOfNode(node);\n            return type;\n        }\n        function getTypeFromStringLiteral(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedType) {\n                links.resolvedType = getStringLiteralType(node);\n            }\n            return links.resolvedType;\n        }\n        function getTypeFromTypeNode(node) {\n            switch (node.kind) {\n                case 109 /* AnyKeyword */:\n                    return anyType;\n                case 118 /* StringKeyword */:\n                    return stringType;\n                case 116 /* NumberKeyword */:\n                    return numberType;\n                case 110 /* BooleanKeyword */:\n                    return booleanType;\n                case 97 /* VoidKeyword */:\n                    return voidType;\n                case 7 /* StringLiteral */:\n                    return getTypeFromStringLiteral(node);\n                case 132 /* TypeReference */:\n                    return getTypeFromTypeReferenceNode(node);\n                case 135 /* TypeQuery */:\n                    return getTypeFromTypeQueryNode(node);\n                case 137 /* ArrayType */:\n                    return getTypeFromArrayTypeNode(node);\n                case 138 /* TupleType */:\n                    return getTypeFromTupleTypeNode(node);\n                case 139 /* UnionType */:\n                    return getTypeFromUnionTypeNode(node);\n                case 140 /* ParenthesizedType */:\n                    return getTypeFromTypeNode(node.type);\n                case 133 /* FunctionType */:\n                case 134 /* ConstructorType */:\n                case 136 /* TypeLiteral */:\n                    return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);\n                case 63 /* Identifier */:\n                case 120 /* QualifiedName */:\n                    var symbol = getSymbolInfo(node);\n                    return symbol && getDeclaredTypeOfSymbol(symbol);\n                default:\n                    return unknownType;\n            }\n        }\n        function instantiateList(items, mapper, instantiator) {\n            if (items && items.length) {\n                var result = [];\n                for (var i = 0; i < items.length; i++) {\n                    result.push(instantiator(items[i], mapper));\n                }\n                return result;\n            }\n            return items;\n        }\n        function createUnaryTypeMapper(source, target) {\n            return function (t) { return t === source ? target : t; };\n        }\n        function createBinaryTypeMapper(source1, target1, source2, target2) {\n            return function (t) { return t === source1 ? target1 : t === source2 ? target2 : t; };\n        }\n        function createTypeMapper(sources, targets) {\n            switch (sources.length) {\n                case 1: return createUnaryTypeMapper(sources[0], targets[0]);\n                case 2: return createBinaryTypeMapper(sources[0], targets[0], sources[1], targets[1]);\n            }\n            return function (t) {\n                for (var i = 0; i < sources.length; i++) {\n                    if (t === sources[i])\n                        return targets[i];\n                }\n                return t;\n            };\n        }\n        function createUnaryTypeEraser(source) {\n            return function (t) { return t === source ? anyType : t; };\n        }\n        function createBinaryTypeEraser(source1, source2) {\n            return function (t) { return t === source1 || t === source2 ? anyType : t; };\n        }\n        function createTypeEraser(sources) {\n            switch (sources.length) {\n                case 1: return createUnaryTypeEraser(sources[0]);\n                case 2: return createBinaryTypeEraser(sources[0], sources[1]);\n            }\n            return function (t) {\n                for (var i = 0; i < sources.length; i++) {\n                    if (t === sources[i])\n                        return anyType;\n                }\n                return t;\n            };\n        }\n        function createInferenceMapper(context) {\n            return function (t) {\n                for (var i = 0; i < context.typeParameters.length; i++) {\n                    if (t === context.typeParameters[i]) {\n                        return getInferredType(context, i);\n                    }\n                }\n                return t;\n            };\n        }\n        function identityMapper(type) {\n            return type;\n        }\n        function combineTypeMappers(mapper1, mapper2) {\n            return function (t) { return mapper2(mapper1(t)); };\n        }\n        function instantiateTypeParameter(typeParameter, mapper) {\n            var result = createType(512 /* TypeParameter */);\n            result.symbol = typeParameter.symbol;\n            if (typeParameter.constraint) {\n                result.constraint = instantiateType(typeParameter.constraint, mapper);\n            }\n            else {\n                result.target = typeParameter;\n                result.mapper = mapper;\n            }\n            return result;\n        }\n        function instantiateSignature(signature, mapper, eraseTypeParameters) {\n            if (signature.typeParameters && !eraseTypeParameters) {\n                var freshTypeParameters = instantiateList(signature.typeParameters, mapper, instantiateTypeParameter);\n                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);\n            }\n            var result = createSignature(signature.declaration, freshTypeParameters, instantiateList(signature.parameters, mapper, instantiateSymbol), signature.resolvedReturnType ? instantiateType(signature.resolvedReturnType, mapper) : undefined, signature.minArgumentCount, signature.hasRestParameter, signature.hasStringLiterals);\n            result.target = signature;\n            result.mapper = mapper;\n            return result;\n        }\n        function instantiateSymbol(symbol, mapper) {\n            if (symbol.flags & 67108864 /* Instantiated */) {\n                var links = getSymbolLinks(symbol);\n                // If symbol being instantiated is itself a instantiation, fetch the original target and combine the\n                // type mappers. This ensures that original type identities are properly preserved and that aliases\n                // always reference a non-aliases.\n                symbol = links.target;\n                mapper = combineTypeMappers(links.mapper, mapper);\n            }\n            // Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and \n            // also transient so that we can just store data on it directly.\n            var result = createSymbol(67108864 /* Instantiated */ | 268435456 /* Transient */ | symbol.flags, symbol.name);\n            result.declarations = symbol.declarations;\n            result.parent = symbol.parent;\n            result.target = symbol;\n            result.mapper = mapper;\n            if (symbol.valueDeclaration) {\n                result.valueDeclaration = symbol.valueDeclaration;\n            }\n            return result;\n        }\n        function instantiateAnonymousType(type, mapper) {\n            var result = createObjectType(32768 /* Anonymous */, type.symbol);\n            result.properties = instantiateList(getPropertiesOfObjectType(type), mapper, instantiateSymbol);\n            result.members = createSymbolTable(result.properties);\n            result.callSignatures = instantiateList(getSignaturesOfType(type, 0 /* Call */), mapper, instantiateSignature);\n            result.constructSignatures = instantiateList(getSignaturesOfType(type, 1 /* Construct */), mapper, instantiateSignature);\n            var stringIndexType = getIndexTypeOfType(type, 0 /* String */);\n            var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);\n            if (stringIndexType)\n                result.stringIndexType = instantiateType(stringIndexType, mapper);\n            if (numberIndexType)\n                result.numberIndexType = instantiateType(numberIndexType, mapper);\n            return result;\n        }\n        function instantiateType(type, mapper) {\n            if (mapper !== identityMapper) {\n                if (type.flags & 512 /* TypeParameter */) {\n                    return mapper(type);\n                }\n                if (type.flags & 32768 /* Anonymous */) {\n                    return type.symbol && type.symbol.flags & (16 /* Function */ | 8192 /* Method */ | 2048 /* TypeLiteral */ | 4096 /* ObjectLiteral */) ? instantiateAnonymousType(type, mapper) : type;\n                }\n                if (type.flags & 4096 /* Reference */) {\n                    return createTypeReference(type.target, instantiateList(type.typeArguments, mapper, instantiateType));\n                }\n                if (type.flags & 8192 /* Tuple */) {\n                    return createTupleType(instantiateList(type.elementTypes, mapper, instantiateType));\n                }\n                if (type.flags & 16384 /* Union */) {\n                    return getUnionType(instantiateList(type.types, mapper, instantiateType), true);\n                }\n            }\n            return type;\n        }\n        // Returns true if the given expression contains (at any level of nesting) a function or arrow expression\n        // that is subject to contextual typing.\n        function isContextSensitive(node) {\n            ts.Debug.assert(node.kind !== 125 /* Method */ || ts.isObjectLiteralMethod(node));\n            switch (node.kind) {\n                case 150 /* FunctionExpression */:\n                case 151 /* ArrowFunction */:\n                    return isContextSensitiveFunctionLikeDeclaration(node);\n                case 142 /* ObjectLiteralExpression */:\n                    return ts.forEach(node.properties, isContextSensitive);\n                case 141 /* ArrayLiteralExpression */:\n                    return ts.forEach(node.elements, isContextSensitive);\n                case 158 /* ConditionalExpression */:\n                    return isContextSensitive(node.whenTrue) || isContextSensitive(node.whenFalse);\n                case 157 /* BinaryExpression */:\n                    return node.operator === 48 /* BarBarToken */ && (isContextSensitive(node.left) || isContextSensitive(node.right));\n                case 198 /* PropertyAssignment */:\n                    return isContextSensitive(node.initializer);\n                case 125 /* Method */:\n                    return isContextSensitiveFunctionLikeDeclaration(node);\n            }\n            return false;\n        }\n        function isContextSensitiveFunctionLikeDeclaration(node) {\n            return !node.typeParameters && !ts.forEach(node.parameters, function (p) { return p.type; });\n        }\n        function getTypeWithoutConstructors(type) {\n            if (type.flags & 48128 /* ObjectType */) {\n                var resolved = resolveObjectOrUnionTypeMembers(type);\n                if (resolved.constructSignatures.length) {\n                    var result = createObjectType(32768 /* Anonymous */, type.symbol);\n                    result.members = resolved.members;\n                    result.properties = resolved.properties;\n                    result.callSignatures = resolved.callSignatures;\n                    result.constructSignatures = emptyArray;\n                    type = result;\n                }\n            }\n            return type;\n        }\n        // TYPE CHECKING\n        var subtypeRelation = {};\n        var assignableRelation = {};\n        var identityRelation = {};\n        function isTypeIdenticalTo(source, target) {\n            return checkTypeRelatedTo(source, target, identityRelation, undefined);\n        }\n        function compareTypes(source, target) {\n            return checkTypeRelatedTo(source, target, identityRelation, undefined) ? -1 /* True */ : 0 /* False */;\n        }\n        function isTypeSubtypeOf(source, target) {\n            return checkTypeSubtypeOf(source, target, undefined);\n        }\n        function isTypeAssignableTo(source, target) {\n            return checkTypeAssignableTo(source, target, undefined);\n        }\n        function checkTypeSubtypeOf(source, target, errorNode, headMessage, containingMessageChain) {\n            return checkTypeRelatedTo(source, target, subtypeRelation, errorNode, headMessage, containingMessageChain);\n        }\n        function checkTypeAssignableTo(source, target, errorNode, headMessage) {\n            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage);\n        }\n        function isSignatureAssignableTo(source, target) {\n            var sourceType = getOrCreateTypeFromSignature(source);\n            var targetType = getOrCreateTypeFromSignature(target);\n            return checkTypeRelatedTo(sourceType, targetType, assignableRelation, undefined);\n        }\n        function checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain) {\n            var errorInfo;\n            var sourceStack;\n            var targetStack;\n            var maybeStack;\n            var expandingFlags;\n            var depth = 0;\n            var overflow = false;\n            ts.Debug.assert(relation !== identityRelation || !errorNode, \"no error reporting in identity checking\");\n            var result = isRelatedTo(source, target, errorNode !== undefined, headMessage);\n            if (overflow) {\n                error(errorNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));\n            }\n            else if (errorInfo) {\n                if (containingMessageChain) {\n                    errorInfo = ts.concatenateDiagnosticMessageChains(containingMessageChain, errorInfo);\n                }\n                addDiagnostic(ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo, program.getCompilerHost().getNewLine()));\n            }\n            return result !== 0 /* False */;\n            function reportError(message, arg0, arg1, arg2) {\n                errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2);\n            }\n            // Compare two types and return\n            // Ternary.True if they are related with no assumptions,\n            // Ternary.Maybe if they are related with assumptions of other relationships, or\n            // Ternary.False if they are not related.\n            function isRelatedTo(source, target, reportErrors, headMessage) {\n                var result;\n                if (relation === identityRelation) {\n                    // both types are the same - covers 'they are the same primitive type or both are Any' or the same type parameter cases\n                    if (source === target)\n                        return -1 /* True */;\n                }\n                else {\n                    if (source === target)\n                        return -1 /* True */;\n                    if (target.flags & 1 /* Any */)\n                        return -1 /* True */;\n                    if (source === undefinedType)\n                        return -1 /* True */;\n                    if (source === nullType && target !== undefinedType)\n                        return -1 /* True */;\n                    if (source.flags & 128 /* Enum */ && target === numberType)\n                        return -1 /* True */;\n                    if (source.flags & 256 /* StringLiteral */ && target === stringType)\n                        return -1 /* True */;\n                    if (relation === assignableRelation) {\n                        if (source.flags & 1 /* Any */)\n                            return -1 /* True */;\n                        if (source === numberType && target.flags & 128 /* Enum */)\n                            return -1 /* True */;\n                    }\n                }\n                if (source.flags & 16384 /* Union */) {\n                    if (result = unionTypeRelatedToType(source, target, reportErrors)) {\n                        return result;\n                    }\n                }\n                else if (target.flags & 16384 /* Union */) {\n                    if (result = typeRelatedToUnionType(source, target, reportErrors)) {\n                        return result;\n                    }\n                }\n                else if (source.flags & 512 /* TypeParameter */ && target.flags & 512 /* TypeParameter */) {\n                    if (result = typeParameterRelatedTo(source, target, reportErrors)) {\n                        return result;\n                    }\n                }\n                else {\n                    var saveErrorInfo = errorInfo;\n                    if (source.flags & 4096 /* Reference */ && target.flags & 4096 /* Reference */ && source.target === target.target) {\n                        // We have type references to same target type, see if relationship holds for all type arguments\n                        if (result = typesRelatedTo(source.typeArguments, target.typeArguments, reportErrors)) {\n                            return result;\n                        }\n                    }\n                    // Even if relationship doesn't hold for type arguments, it may hold in a structural comparison\n                    // Report structural errors only if we haven't reported any errors yet\n                    var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo;\n                    // identity relation does not use apparent type\n                    var sourceOrApparentType = relation === identityRelation ? source : getApparentType(source);\n                    if (sourceOrApparentType.flags & 48128 /* ObjectType */ && target.flags & 48128 /* ObjectType */ && (result = objectTypeRelatedTo(sourceOrApparentType, target, reportStructuralErrors))) {\n                        errorInfo = saveErrorInfo;\n                        return result;\n                    }\n                }\n                if (reportErrors) {\n                    headMessage = headMessage || ts.Diagnostics.Type_0_is_not_assignable_to_type_1;\n                    reportError(headMessage, typeToString(source), typeToString(target));\n                }\n                return 0 /* False */;\n            }\n            function typeRelatedToUnionType(source, target, reportErrors) {\n                var targetTypes = target.types;\n                for (var i = 0, len = targetTypes.length; i < len; i++) {\n                    var related = isRelatedTo(source, targetTypes[i], reportErrors && i === len - 1);\n                    if (related) {\n                        return related;\n                    }\n                }\n                return 0 /* False */;\n            }\n            function unionTypeRelatedToType(source, target, reportErrors) {\n                var result = -1 /* True */;\n                var sourceTypes = source.types;\n                for (var i = 0, len = sourceTypes.length; i < len; i++) {\n                    var related = isRelatedTo(sourceTypes[i], target, reportErrors);\n                    if (!related) {\n                        return 0 /* False */;\n                    }\n                    result &= related;\n                }\n                return result;\n            }\n            function typesRelatedTo(sources, targets, reportErrors) {\n                var result = -1 /* True */;\n                for (var i = 0, len = sources.length; i < len; i++) {\n                    var related = isRelatedTo(sources[i], targets[i], reportErrors);\n                    if (!related) {\n                        return 0 /* False */;\n                    }\n                    result &= related;\n                }\n                return result;\n            }\n            function typeParameterRelatedTo(source, target, reportErrors) {\n                if (relation === identityRelation) {\n                    if (source.symbol.name !== target.symbol.name) {\n                        return 0 /* False */;\n                    }\n                    // covers case when both type parameters does not have constraint (both equal to noConstraintType)\n                    if (source.constraint === target.constraint) {\n                        return -1 /* True */;\n                    }\n                    if (source.constraint === noConstraintType || target.constraint === noConstraintType) {\n                        return 0 /* False */;\n                    }\n                    return isRelatedTo(source.constraint, target.constraint, reportErrors);\n                }\n                else {\n                    while (true) {\n                        var constraint = getConstraintOfTypeParameter(source);\n                        if (constraint === target)\n                            return -1 /* True */;\n                        if (!(constraint && constraint.flags & 512 /* TypeParameter */))\n                            break;\n                        source = constraint;\n                    }\n                    return 0 /* False */;\n                }\n            }\n            // Determine if two object types are related by structure. First, check if the result is already available in the global cache.\n            // Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.\n            // Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are\n            // equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion\n            // and issue an error. Otherwise, actually compare the structure of the two types.\n            function objectTypeRelatedTo(source, target, reportErrors) {\n                if (overflow) {\n                    return 0 /* False */;\n                }\n                var id = source.id + \",\" + target.id;\n                var related = relation[id];\n                if (related !== undefined) {\n                    return related ? -1 /* True */ : 0 /* False */;\n                }\n                if (depth > 0) {\n                    for (var i = 0; i < depth; i++) {\n                        // If source and target are already being compared, consider them related with assumptions\n                        if (maybeStack[i][id]) {\n                            return 1 /* Maybe */;\n                        }\n                    }\n                    if (depth === 100) {\n                        overflow = true;\n                        return 0 /* False */;\n                    }\n                }\n                else {\n                    sourceStack = [];\n                    targetStack = [];\n                    maybeStack = [];\n                    expandingFlags = 0;\n                }\n                sourceStack[depth] = source;\n                targetStack[depth] = target;\n                maybeStack[depth] = {};\n                maybeStack[depth][id] = true;\n                depth++;\n                var saveExpandingFlags = expandingFlags;\n                if (!(expandingFlags & 1) && isDeeplyNestedGeneric(source, sourceStack))\n                    expandingFlags |= 1;\n                if (!(expandingFlags & 2) && isDeeplyNestedGeneric(target, targetStack))\n                    expandingFlags |= 2;\n                if (expandingFlags === 3) {\n                    var result = 1 /* Maybe */;\n                }\n                else {\n                    var result = propertiesRelatedTo(source, target, reportErrors);\n                    if (result) {\n                        result &= signaturesRelatedTo(source, target, 0 /* Call */, reportErrors);\n                        if (result) {\n                            result &= signaturesRelatedTo(source, target, 1 /* Construct */, reportErrors);\n                            if (result) {\n                                result &= stringIndexTypesRelatedTo(source, target, reportErrors);\n                                if (result) {\n                                    result &= numberIndexTypesRelatedTo(source, target, reportErrors);\n                                }\n                            }\n                        }\n                    }\n                }\n                expandingFlags = saveExpandingFlags;\n                depth--;\n                if (result) {\n                    var maybeCache = maybeStack[depth];\n                    // If result is definitely true, copy assumptions to global cache, else copy to next level up\n                    var destinationCache = result === -1 /* True */ || depth === 0 ? relation : maybeStack[depth - 1];\n                    for (var p in maybeCache) {\n                        destinationCache[p] = maybeCache[p];\n                    }\n                }\n                else {\n                    // A false result goes straight into global cache (when something is false under assumptions it\n                    // will also be false without assumptions)\n                    relation[id] = false;\n                }\n                return result;\n            }\n            // Return true if the given type is part of a deeply nested chain of generic instantiations. We consider this to be the case\n            // when structural type comparisons have been started for 10 or more instantiations of the same generic type. It is possible,\n            // though highly unlikely, for this test to be true in a situation where a chain of instantiations is not infinitely expanding.\n            // Effectively, we will generate a false positive when two types are structurally equal to at least 10 levels, but unequal at\n            // some level beyond that.\n            function isDeeplyNestedGeneric(type, stack) {\n                if (type.flags & 4096 /* Reference */ && depth >= 10) {\n                    var target = type.target;\n                    var count = 0;\n                    for (var i = 0; i < depth; i++) {\n                        var t = stack[i];\n                        if (t.flags & 4096 /* Reference */ && t.target === target) {\n                            count++;\n                            if (count >= 10)\n                                return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            function propertiesRelatedTo(source, target, reportErrors) {\n                if (relation === identityRelation) {\n                    return propertiesIdenticalTo(source, target);\n                }\n                var result = -1 /* True */;\n                var properties = getPropertiesOfObjectType(target);\n                for (var i = 0; i < properties.length; i++) {\n                    var targetProp = properties[i];\n                    var sourceProp = getPropertyOfType(source, targetProp.name);\n                    if (sourceProp !== targetProp) {\n                        if (!sourceProp) {\n                            if (relation === subtypeRelation || !isOptionalProperty(targetProp)) {\n                                if (reportErrors) {\n                                    reportError(ts.Diagnostics.Property_0_is_missing_in_type_1, symbolToString(targetProp), typeToString(source));\n                                }\n                                return 0 /* False */;\n                            }\n                        }\n                        else if (!(targetProp.flags & 536870912 /* Prototype */)) {\n                            var sourceFlags = getDeclarationFlagsFromSymbol(sourceProp);\n                            var targetFlags = getDeclarationFlagsFromSymbol(targetProp);\n                            if (sourceFlags & 32 /* Private */ || targetFlags & 32 /* Private */) {\n                                if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {\n                                    if (reportErrors) {\n                                        if (sourceFlags & 32 /* Private */ && targetFlags & 32 /* Private */) {\n                                            reportError(ts.Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp));\n                                        }\n                                        else {\n                                            reportError(ts.Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourceFlags & 32 /* Private */ ? source : target), typeToString(sourceFlags & 32 /* Private */ ? target : source));\n                                        }\n                                    }\n                                    return 0 /* False */;\n                                }\n                            }\n                            else if (targetFlags & 64 /* Protected */) {\n                                var sourceDeclaredInClass = sourceProp.parent && sourceProp.parent.flags & 32 /* Class */;\n                                var sourceClass = sourceDeclaredInClass ? getDeclaredTypeOfSymbol(sourceProp.parent) : undefined;\n                                var targetClass = getDeclaredTypeOfSymbol(targetProp.parent);\n                                if (!sourceClass || !hasBaseType(sourceClass, targetClass)) {\n                                    if (reportErrors) {\n                                        reportError(ts.Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(sourceClass || source), typeToString(targetClass));\n                                    }\n                                    return 0 /* False */;\n                                }\n                            }\n                            else if (sourceFlags & 64 /* Protected */) {\n                                if (reportErrors) {\n                                    reportError(ts.Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));\n                                }\n                                return 0 /* False */;\n                            }\n                            var related = isRelatedTo(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);\n                            if (!related) {\n                                if (reportErrors) {\n                                    reportError(ts.Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp));\n                                }\n                                return 0 /* False */;\n                            }\n                            result &= related;\n                            if (isOptionalProperty(sourceProp) && !isOptionalProperty(targetProp)) {\n                                // TypeScript 1.0 spec (April 2014): 3.8.3\n                                // S is a subtype of a type T, and T is a supertype of S if ...\n                                // S' and T are object types and, for each member M in T..\n                                // M is a property and S' contains a property N where\n                                // if M is a required property, N is also a required property \n                                // (M - property in T)\n                                // (N - property in S)\n                                if (reportErrors) {\n                                    reportError(ts.Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));\n                                }\n                                return 0 /* False */;\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            function propertiesIdenticalTo(source, target) {\n                var sourceProperties = getPropertiesOfObjectType(source);\n                var targetProperties = getPropertiesOfObjectType(target);\n                if (sourceProperties.length !== targetProperties.length) {\n                    return 0 /* False */;\n                }\n                var result = -1 /* True */;\n                for (var i = 0, len = sourceProperties.length; i < len; ++i) {\n                    var sourceProp = sourceProperties[i];\n                    var targetProp = getPropertyOfObjectType(target, sourceProp.name);\n                    if (!targetProp) {\n                        return 0 /* False */;\n                    }\n                    var related = compareProperties(sourceProp, targetProp, isRelatedTo);\n                    if (!related) {\n                        return 0 /* False */;\n                    }\n                    result &= related;\n                }\n                return result;\n            }\n            function signaturesRelatedTo(source, target, kind, reportErrors) {\n                if (relation === identityRelation) {\n                    return signaturesIdenticalTo(source, target, kind);\n                }\n                if (target === anyFunctionType || source === anyFunctionType) {\n                    return -1 /* True */;\n                }\n                var sourceSignatures = getSignaturesOfType(source, kind);\n                var targetSignatures = getSignaturesOfType(target, kind);\n                var result = -1 /* True */;\n                var saveErrorInfo = errorInfo;\n                outer: for (var i = 0; i < targetSignatures.length; i++) {\n                    var t = targetSignatures[i];\n                    if (!t.hasStringLiterals || target.flags & 65536 /* FromSignature */) {\n                        var localErrors = reportErrors;\n                        for (var j = 0; j < sourceSignatures.length; j++) {\n                            var s = sourceSignatures[j];\n                            if (!s.hasStringLiterals || source.flags & 65536 /* FromSignature */) {\n                                var related = signatureRelatedTo(s, t, localErrors);\n                                if (related) {\n                                    result &= related;\n                                    errorInfo = saveErrorInfo;\n                                    continue outer;\n                                }\n                                // Only report errors from the first failure\n                                localErrors = false;\n                            }\n                        }\n                        return 0 /* False */;\n                    }\n                }\n                return result;\n            }\n            function signatureRelatedTo(source, target, reportErrors) {\n                if (source === target) {\n                    return -1 /* True */;\n                }\n                if (!target.hasRestParameter && source.minArgumentCount > target.parameters.length) {\n                    return 0 /* False */;\n                }\n                var sourceMax = source.parameters.length;\n                var targetMax = target.parameters.length;\n                var checkCount;\n                if (source.hasRestParameter && target.hasRestParameter) {\n                    checkCount = sourceMax > targetMax ? sourceMax : targetMax;\n                    sourceMax--;\n                    targetMax--;\n                }\n                else if (source.hasRestParameter) {\n                    sourceMax--;\n                    checkCount = targetMax;\n                }\n                else if (target.hasRestParameter) {\n                    targetMax--;\n                    checkCount = sourceMax;\n                }\n                else {\n                    checkCount = sourceMax < targetMax ? sourceMax : targetMax;\n                }\n                // Spec 1.0 Section 3.8.3 & 3.8.4:\n                // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N\n                source = getErasedSignature(source);\n                target = getErasedSignature(target);\n                var result = -1 /* True */;\n                for (var i = 0; i < checkCount; i++) {\n                    var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);\n                    var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);\n                    var saveErrorInfo = errorInfo;\n                    var related = isRelatedTo(s, t, reportErrors);\n                    if (!related) {\n                        related = isRelatedTo(t, s, false);\n                        if (!related) {\n                            if (reportErrors) {\n                                reportError(ts.Diagnostics.Types_of_parameters_0_and_1_are_incompatible, source.parameters[i < sourceMax ? i : sourceMax].name, target.parameters[i < targetMax ? i : targetMax].name);\n                            }\n                            return 0 /* False */;\n                        }\n                        errorInfo = saveErrorInfo;\n                    }\n                    result &= related;\n                }\n                var t = getReturnTypeOfSignature(target);\n                if (t === voidType)\n                    return result;\n                var s = getReturnTypeOfSignature(source);\n                return result & isRelatedTo(s, t, reportErrors);\n            }\n            function signaturesIdenticalTo(source, target, kind) {\n                var sourceSignatures = getSignaturesOfType(source, kind);\n                var targetSignatures = getSignaturesOfType(target, kind);\n                if (sourceSignatures.length !== targetSignatures.length) {\n                    return 0 /* False */;\n                }\n                var result = -1 /* True */;\n                for (var i = 0, len = sourceSignatures.length; i < len; ++i) {\n                    var related = compareSignatures(sourceSignatures[i], targetSignatures[i], true, isRelatedTo);\n                    if (!related) {\n                        return 0 /* False */;\n                    }\n                    result &= related;\n                }\n                return result;\n            }\n            function stringIndexTypesRelatedTo(source, target, reportErrors) {\n                if (relation === identityRelation) {\n                    return indexTypesIdenticalTo(0 /* String */, source, target);\n                }\n                var targetType = getIndexTypeOfType(target, 0 /* String */);\n                if (targetType) {\n                    var sourceType = getIndexTypeOfType(source, 0 /* String */);\n                    if (!sourceType) {\n                        if (reportErrors) {\n                            reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));\n                        }\n                        return 0 /* False */;\n                    }\n                    var related = isRelatedTo(sourceType, targetType, reportErrors);\n                    if (!related) {\n                        if (reportErrors) {\n                            reportError(ts.Diagnostics.Index_signatures_are_incompatible);\n                        }\n                        return 0 /* False */;\n                    }\n                    return related;\n                }\n                return -1 /* True */;\n            }\n            function numberIndexTypesRelatedTo(source, target, reportErrors) {\n                if (relation === identityRelation) {\n                    return indexTypesIdenticalTo(1 /* Number */, source, target);\n                }\n                var targetType = getIndexTypeOfType(target, 1 /* Number */);\n                if (targetType) {\n                    var sourceStringType = getIndexTypeOfType(source, 0 /* String */);\n                    var sourceNumberType = getIndexTypeOfType(source, 1 /* Number */);\n                    if (!(sourceStringType || sourceNumberType)) {\n                        if (reportErrors) {\n                            reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));\n                        }\n                        return 0 /* False */;\n                    }\n                    if (sourceStringType && sourceNumberType) {\n                        // If we know for sure we're testing both string and numeric index types then only report errors from the second one\n                        var related = isRelatedTo(sourceStringType, targetType, false) || isRelatedTo(sourceNumberType, targetType, reportErrors);\n                    }\n                    else {\n                        var related = isRelatedTo(sourceStringType || sourceNumberType, targetType, reportErrors);\n                    }\n                    if (!related) {\n                        if (reportErrors) {\n                            reportError(ts.Diagnostics.Index_signatures_are_incompatible);\n                        }\n                        return 0 /* False */;\n                    }\n                    return related;\n                }\n                return -1 /* True */;\n            }\n            function indexTypesIdenticalTo(indexKind, source, target) {\n                var targetType = getIndexTypeOfType(target, indexKind);\n                var sourceType = getIndexTypeOfType(source, indexKind);\n                if (!sourceType && !targetType) {\n                    return -1 /* True */;\n                }\n                if (sourceType && targetType) {\n                    return isRelatedTo(sourceType, targetType);\n                }\n                return 0 /* False */;\n            }\n        }\n        function isPropertyIdenticalTo(sourceProp, targetProp) {\n            return compareProperties(sourceProp, targetProp, compareTypes) !== 0 /* False */;\n        }\n        function compareProperties(sourceProp, targetProp, compareTypes) {\n            // Two members are considered identical when\n            // - they are public properties with identical names, optionality, and types,\n            // - they are private or protected properties originating in the same declaration and having identical types\n            if (sourceProp === targetProp) {\n                return -1 /* True */;\n            }\n            var sourcePropAccessibility = getDeclarationFlagsFromSymbol(sourceProp) & (32 /* Private */ | 64 /* Protected */);\n            var targetPropAccessibility = getDeclarationFlagsFromSymbol(targetProp) & (32 /* Private */ | 64 /* Protected */);\n            if (sourcePropAccessibility !== targetPropAccessibility) {\n                return 0 /* False */;\n            }\n            if (sourcePropAccessibility) {\n                if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {\n                    return 0 /* False */;\n                }\n            }\n            else {\n                if (isOptionalProperty(sourceProp) !== isOptionalProperty(targetProp)) {\n                    return 0 /* False */;\n                }\n            }\n            return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));\n        }\n        function compareSignatures(source, target, compareReturnTypes, compareTypes) {\n            if (source === target) {\n                return -1 /* True */;\n            }\n            if (source.parameters.length !== target.parameters.length || source.minArgumentCount !== target.minArgumentCount || source.hasRestParameter !== target.hasRestParameter) {\n                return 0 /* False */;\n            }\n            var result = -1 /* True */;\n            if (source.typeParameters && target.typeParameters) {\n                if (source.typeParameters.length !== target.typeParameters.length) {\n                    return 0 /* False */;\n                }\n                for (var i = 0, len = source.typeParameters.length; i < len; ++i) {\n                    var related = compareTypes(source.typeParameters[i], target.typeParameters[i]);\n                    if (!related) {\n                        return 0 /* False */;\n                    }\n                    result &= related;\n                }\n            }\n            else if (source.typeParameters || source.typeParameters) {\n                return 0 /* False */;\n            }\n            // Spec 1.0 Section 3.8.3 & 3.8.4:\n            // M and N (the signatures) are instantiated using type Any as the type argument for all type parameters declared by M and N\n            source = getErasedSignature(source);\n            target = getErasedSignature(target);\n            for (var i = 0, len = source.parameters.length; i < len; i++) {\n                var s = source.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(source) : getTypeOfSymbol(source.parameters[i]);\n                var t = target.hasRestParameter && i === len - 1 ? getRestTypeOfSignature(target) : getTypeOfSymbol(target.parameters[i]);\n                var related = compareTypes(s, t);\n                if (!related) {\n                    return 0 /* False */;\n                }\n                result &= related;\n            }\n            if (compareReturnTypes) {\n                result &= compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));\n            }\n            return result;\n        }\n        function isSupertypeOfEach(candidate, types) {\n            for (var i = 0, len = types.length; i < len; i++) {\n                if (candidate !== types[i] && !isTypeSubtypeOf(types[i], candidate))\n                    return false;\n            }\n            return true;\n        }\n        function getCommonSupertype(types) {\n            return ts.forEach(types, function (t) { return isSupertypeOfEach(t, types) ? t : undefined; });\n        }\n        function reportNoCommonSupertypeError(types, errorLocation, errorMessageChainHead) {\n            var bestSupertype;\n            var bestSupertypeDownfallType; // The type that caused bestSupertype not to be the common supertype\n            var bestSupertypeScore = 0;\n            for (var i = 0; i < types.length; i++) {\n                var score = 0;\n                var downfallType = undefined;\n                for (var j = 0; j < types.length; j++) {\n                    if (isTypeSubtypeOf(types[j], types[i])) {\n                        score++;\n                    }\n                    else if (!downfallType) {\n                        downfallType = types[j];\n                    }\n                }\n                if (score > bestSupertypeScore) {\n                    bestSupertype = types[i];\n                    bestSupertypeDownfallType = downfallType;\n                    bestSupertypeScore = score;\n                }\n                // types.length - 1 is the maximum score, given that getCommonSupertype returned false\n                if (bestSupertypeScore === types.length - 1) {\n                    break;\n                }\n            }\n            // In the following errors, the {1} slot is before the {0} slot because checkTypeSubtypeOf supplies the\n            // subtype as the first argument to the error\n            checkTypeSubtypeOf(bestSupertypeDownfallType, bestSupertype, errorLocation, ts.Diagnostics.Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0, errorMessageChainHead);\n        }\n        function isTypeOfObjectLiteral(type) {\n            return (type.flags & 32768 /* Anonymous */) && type.symbol && (type.symbol.flags & 4096 /* ObjectLiteral */) ? true : false;\n        }\n        function isArrayType(type) {\n            return type.flags & 4096 /* Reference */ && type.target === globalArrayType;\n        }\n        function getInnermostTypeOfNestedArrayTypes(type) {\n            while (isArrayType(type)) {\n                type = type.typeArguments[0];\n            }\n            return type;\n        }\n        /* If we are widening on a literal, then we may need to the 'node' parameter for reporting purposes */\n        function getWidenedType(type, suppressNoImplicitAnyErrors) {\n            if (type.flags & (32 /* Undefined */ | 64 /* Null */)) {\n                return anyType;\n            }\n            if (type.flags & 16384 /* Union */) {\n                return getWidenedTypeOfUnion(type);\n            }\n            if (isTypeOfObjectLiteral(type)) {\n                return getWidenedTypeOfObjectLiteral(type);\n            }\n            if (isArrayType(type)) {\n                return getWidenedTypeOfArrayLiteral(type);\n            }\n            return type;\n            function getWidenedTypeOfUnion(type) {\n                return getUnionType(ts.map(type.types, function (t) { return getWidenedType(t, suppressNoImplicitAnyErrors); }));\n            }\n            function getWidenedTypeOfObjectLiteral(type) {\n                var properties = getPropertiesOfObjectType(type);\n                if (properties.length) {\n                    var widenedTypes = [];\n                    var propTypeWasWidened = false;\n                    ts.forEach(properties, function (p) {\n                        var propType = getTypeOfSymbol(p);\n                        var widenedType = getWidenedType(propType);\n                        if (propType !== widenedType) {\n                            propTypeWasWidened = true;\n                            if (!suppressNoImplicitAnyErrors && compilerOptions.noImplicitAny && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {\n                                error(p.valueDeclaration, ts.Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, p.name, typeToString(widenedType));\n                            }\n                        }\n                        widenedTypes.push(widenedType);\n                    });\n                    if (propTypeWasWidened) {\n                        var members = {};\n                        var index = 0;\n                        ts.forEach(properties, function (p) {\n                            var symbol = createSymbol(4 /* Property */ | 268435456 /* Transient */ | p.flags, p.name);\n                            symbol.declarations = p.declarations;\n                            symbol.parent = p.parent;\n                            symbol.type = widenedTypes[index++];\n                            symbol.target = p;\n                            if (p.valueDeclaration)\n                                symbol.valueDeclaration = p.valueDeclaration;\n                            members[symbol.name] = symbol;\n                        });\n                        var stringIndexType = getIndexTypeOfType(type, 0 /* String */);\n                        var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);\n                        if (stringIndexType)\n                            stringIndexType = getWidenedType(stringIndexType);\n                        if (numberIndexType)\n                            numberIndexType = getWidenedType(numberIndexType);\n                        type = createAnonymousType(type.symbol, members, emptyArray, emptyArray, stringIndexType, numberIndexType);\n                    }\n                }\n                return type;\n            }\n            function getWidenedTypeOfArrayLiteral(type) {\n                var elementType = type.typeArguments[0];\n                var widenedType = getWidenedType(elementType, suppressNoImplicitAnyErrors);\n                type = elementType !== widenedType ? createArrayType(widenedType) : type;\n                return type;\n            }\n        }\n        function forEachMatchingParameterType(source, target, callback) {\n            var sourceMax = source.parameters.length;\n            var targetMax = target.parameters.length;\n            var count;\n            if (source.hasRestParameter && target.hasRestParameter) {\n                count = sourceMax > targetMax ? sourceMax : targetMax;\n                sourceMax--;\n                targetMax--;\n            }\n            else if (source.hasRestParameter) {\n                sourceMax--;\n                count = targetMax;\n            }\n            else if (target.hasRestParameter) {\n                targetMax--;\n                count = sourceMax;\n            }\n            else {\n                count = sourceMax < targetMax ? sourceMax : targetMax;\n            }\n            for (var i = 0; i < count; i++) {\n                var s = i < sourceMax ? getTypeOfSymbol(source.parameters[i]) : getRestTypeOfSignature(source);\n                var t = i < targetMax ? getTypeOfSymbol(target.parameters[i]) : getRestTypeOfSignature(target);\n                callback(s, t);\n            }\n        }\n        function createInferenceContext(typeParameters, inferUnionTypes) {\n            var inferences = [];\n            for (var i = 0; i < typeParameters.length; i++) {\n                inferences.push({ primary: undefined, secondary: undefined });\n            }\n            return {\n                typeParameters: typeParameters,\n                inferUnionTypes: inferUnionTypes,\n                inferenceCount: 0,\n                inferences: inferences,\n                inferredTypes: new Array(typeParameters.length),\n            };\n        }\n        function inferTypes(context, source, target) {\n            var sourceStack;\n            var targetStack;\n            var depth = 0;\n            var inferiority = 0;\n            inferFromTypes(source, target);\n            function isInProcess(source, target) {\n                for (var i = 0; i < depth; i++) {\n                    if (source === sourceStack[i] && target === targetStack[i])\n                        return true;\n                }\n                return false;\n            }\n            function isWithinDepthLimit(type, stack) {\n                if (depth >= 5) {\n                    var target = type.target;\n                    var count = 0;\n                    for (var i = 0; i < depth; i++) {\n                        var t = stack[i];\n                        if (t.flags & 4096 /* Reference */ && t.target === target)\n                            count++;\n                    }\n                    return count < 5;\n                }\n                return true;\n            }\n            function inferFromTypes(source, target) {\n                if (target.flags & 512 /* TypeParameter */) {\n                    // If target is a type parameter, make an inference\n                    var typeParameters = context.typeParameters;\n                    for (var i = 0; i < typeParameters.length; i++) {\n                        if (target === typeParameters[i]) {\n                            var inferences = context.inferences[i];\n                            var candidates = inferiority ? inferences.secondary || (inferences.secondary = []) : inferences.primary || (inferences.primary = []);\n                            if (!ts.contains(candidates, source))\n                                candidates.push(source);\n                            break;\n                        }\n                    }\n                }\n                else if (source.flags & 4096 /* Reference */ && target.flags & 4096 /* Reference */ && source.target === target.target) {\n                    // If source and target are references to the same generic type, infer from type arguments\n                    var sourceTypes = source.typeArguments;\n                    var targetTypes = target.typeArguments;\n                    for (var i = 0; i < sourceTypes.length; i++) {\n                        inferFromTypes(sourceTypes[i], targetTypes[i]);\n                    }\n                }\n                else if (target.flags & 16384 /* Union */) {\n                    var targetTypes = target.types;\n                    var typeParameterCount = 0;\n                    var typeParameter;\n                    for (var i = 0; i < targetTypes.length; i++) {\n                        var t = targetTypes[i];\n                        if (t.flags & 512 /* TypeParameter */ && ts.contains(context.typeParameters, t)) {\n                            typeParameter = t;\n                            typeParameterCount++;\n                        }\n                        else {\n                            inferFromTypes(source, t);\n                        }\n                    }\n                    // If union contains a single naked type parameter, make a secondary inference to that type parameter\n                    if (typeParameterCount === 1) {\n                        inferiority++;\n                        inferFromTypes(source, typeParameter);\n                        inferiority--;\n                    }\n                }\n                else if (source.flags & 16384 /* Union */) {\n                    // Source is a union type, infer from each consituent type\n                    var sourceTypes = source.types;\n                    for (var i = 0; i < sourceTypes.length; i++) {\n                        inferFromTypes(sourceTypes[i], target);\n                    }\n                }\n                else if (source.flags & 48128 /* ObjectType */ && (target.flags & (4096 /* Reference */ | 8192 /* Tuple */) || (target.flags & 32768 /* Anonymous */) && target.symbol && target.symbol.flags & (8192 /* Method */ | 2048 /* TypeLiteral */))) {\n                    // If source is an object type, and target is a type reference, a tuple type, the type of a method, or a type literal, infer from members\n                    if (!isInProcess(source, target) && isWithinDepthLimit(source, sourceStack) && isWithinDepthLimit(target, targetStack)) {\n                        if (depth === 0) {\n                            sourceStack = [];\n                            targetStack = [];\n                        }\n                        sourceStack[depth] = source;\n                        targetStack[depth] = target;\n                        depth++;\n                        inferFromProperties(source, target);\n                        inferFromSignatures(source, target, 0 /* Call */);\n                        inferFromSignatures(source, target, 1 /* Construct */);\n                        inferFromIndexTypes(source, target, 0 /* String */, 0 /* String */);\n                        inferFromIndexTypes(source, target, 1 /* Number */, 1 /* Number */);\n                        inferFromIndexTypes(source, target, 0 /* String */, 1 /* Number */);\n                        depth--;\n                    }\n                }\n            }\n            function inferFromProperties(source, target) {\n                var properties = getPropertiesOfObjectType(target);\n                for (var i = 0; i < properties.length; i++) {\n                    var targetProp = properties[i];\n                    var sourceProp = getPropertyOfObjectType(source, targetProp.name);\n                    if (sourceProp) {\n                        inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));\n                    }\n                }\n            }\n            function inferFromSignatures(source, target, kind) {\n                var sourceSignatures = getSignaturesOfType(source, kind);\n                var targetSignatures = getSignaturesOfType(target, kind);\n                var sourceLen = sourceSignatures.length;\n                var targetLen = targetSignatures.length;\n                var len = sourceLen < targetLen ? sourceLen : targetLen;\n                for (var i = 0; i < len; i++) {\n                    inferFromSignature(getErasedSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]));\n                }\n            }\n            function inferFromSignature(source, target) {\n                forEachMatchingParameterType(source, target, inferFromTypes);\n                inferFromTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));\n            }\n            function inferFromIndexTypes(source, target, sourceKind, targetKind) {\n                var targetIndexType = getIndexTypeOfType(target, targetKind);\n                if (targetIndexType) {\n                    var sourceIndexType = getIndexTypeOfType(source, sourceKind);\n                    if (sourceIndexType) {\n                        inferFromTypes(sourceIndexType, targetIndexType);\n                    }\n                }\n            }\n        }\n        function getInferenceCandidates(context, index) {\n            var inferences = context.inferences[index];\n            return inferences.primary || inferences.secondary || emptyArray;\n        }\n        function getInferredType(context, index) {\n            var inferredType = context.inferredTypes[index];\n            if (!inferredType) {\n                var inferences = getInferenceCandidates(context, index);\n                if (inferences.length) {\n                    // Infer widened union or supertype, or the undefined type for no common supertype\n                    var unionOrSuperType = context.inferUnionTypes ? getUnionType(inferences) : getCommonSupertype(inferences);\n                    inferredType = unionOrSuperType ? getWidenedType(unionOrSuperType) : inferenceFailureType;\n                }\n                else {\n                    // Infer the empty object type when no inferences were made\n                    inferredType = emptyObjectType;\n                }\n                if (inferredType !== inferenceFailureType) {\n                    var constraint = getConstraintOfTypeParameter(context.typeParameters[index]);\n                    inferredType = constraint && !isTypeAssignableTo(inferredType, constraint) ? constraint : inferredType;\n                }\n                context.inferredTypes[index] = inferredType;\n            }\n            return inferredType;\n        }\n        function getInferredTypes(context) {\n            for (var i = 0; i < context.inferredTypes.length; i++) {\n                getInferredType(context, i);\n            }\n            return context.inferredTypes;\n        }\n        function hasAncestor(node, kind) {\n            return ts.getAncestor(node, kind) !== undefined;\n        }\n        // EXPRESSION TYPE CHECKING\n        function getResolvedSymbol(node) {\n            var links = getNodeLinks(node);\n            if (!links.resolvedSymbol) {\n                links.resolvedSymbol = (ts.getFullWidth(node) > 0 && resolveName(node, node.text, 107455 /* Value */ | 4194304 /* ExportValue */, ts.Diagnostics.Cannot_find_name_0, node)) || unknownSymbol;\n            }\n            return links.resolvedSymbol;\n        }\n        function isInTypeQuery(node) {\n            while (node) {\n                switch (node.kind) {\n                    case 135 /* TypeQuery */:\n                        return true;\n                    case 63 /* Identifier */:\n                    case 120 /* QualifiedName */:\n                        node = node.parent;\n                        continue;\n                    default:\n                        return false;\n                }\n            }\n            ts.Debug.fail(\"should not get here\");\n        }\n        // Remove one or more primitive types from a union type\n        function subtractPrimitiveTypes(type, subtractMask) {\n            if (type.flags & 16384 /* Union */) {\n                var types = type.types;\n                if (ts.forEach(types, function (t) { return t.flags & subtractMask; })) {\n                    return getUnionType(ts.filter(types, function (t) { return !(t.flags & subtractMask); }));\n                }\n            }\n            return type;\n        }\n        // Check if a given variable is assigned within a given syntax node\n        function isVariableAssignedWithin(symbol, node) {\n            var links = getNodeLinks(node);\n            if (links.assignmentChecks) {\n                var cachedResult = links.assignmentChecks[symbol.id];\n                if (cachedResult !== undefined) {\n                    return cachedResult;\n                }\n            }\n            else {\n                links.assignmentChecks = {};\n            }\n            return links.assignmentChecks[symbol.id] = isAssignedIn(node);\n            function isAssignedInBinaryExpression(node) {\n                if (node.operator >= 51 /* FirstAssignment */ && node.operator <= 62 /* LastAssignment */) {\n                    var n = node.left;\n                    while (n.kind === 149 /* ParenthesizedExpression */) {\n                        n = n.expression;\n                    }\n                    if (n.kind === 63 /* Identifier */ && getResolvedSymbol(n) === symbol) {\n                        return true;\n                    }\n                }\n                return ts.forEachChild(node, isAssignedIn);\n            }\n            function isAssignedInVariableDeclaration(node) {\n                if (getSymbolOfNode(node) === symbol && node.initializer) {\n                    return true;\n                }\n                return ts.forEachChild(node, isAssignedIn);\n            }\n            function isAssignedIn(node) {\n                switch (node.kind) {\n                    case 157 /* BinaryExpression */:\n                        return isAssignedInBinaryExpression(node);\n                    case 183 /* VariableDeclaration */:\n                        return isAssignedInVariableDeclaration(node);\n                    case 141 /* ArrayLiteralExpression */:\n                    case 142 /* ObjectLiteralExpression */:\n                    case 143 /* PropertyAccessExpression */:\n                    case 144 /* ElementAccessExpression */:\n                    case 145 /* CallExpression */:\n                    case 146 /* NewExpression */:\n                    case 148 /* TypeAssertionExpression */:\n                    case 149 /* ParenthesizedExpression */:\n                    case 155 /* PrefixUnaryExpression */:\n                    case 152 /* DeleteExpression */:\n                    case 153 /* TypeOfExpression */:\n                    case 154 /* VoidExpression */:\n                    case 156 /* PostfixUnaryExpression */:\n                    case 158 /* ConditionalExpression */:\n                    case 163 /* Block */:\n                    case 164 /* VariableStatement */:\n                    case 166 /* ExpressionStatement */:\n                    case 167 /* IfStatement */:\n                    case 168 /* DoStatement */:\n                    case 169 /* WhileStatement */:\n                    case 170 /* ForStatement */:\n                    case 171 /* ForInStatement */:\n                    case 174 /* ReturnStatement */:\n                    case 175 /* WithStatement */:\n                    case 176 /* SwitchStatement */:\n                    case 194 /* CaseClause */:\n                    case 195 /* DefaultClause */:\n                    case 177 /* LabeledStatement */:\n                    case 178 /* ThrowStatement */:\n                    case 179 /* TryStatement */:\n                    case 180 /* TryBlock */:\n                    case 197 /* CatchClause */:\n                    case 181 /* FinallyBlock */:\n                        return ts.forEachChild(node, isAssignedIn);\n                }\n                return false;\n            }\n        }\n        function resolveLocation(node) {\n            // Resolve location from top down towards node if it is a context sensitive expression\n            // That helps in making sure not assigning types as any when resolved out of order\n            var containerNodes = [];\n            for (var parent = node.parent; parent; parent = parent.parent) {\n                if ((ts.isExpression(parent) || ts.isObjectLiteralMethod(node)) && isContextSensitive(parent)) {\n                    containerNodes.unshift(parent);\n                }\n            }\n            ts.forEach(containerNodes, function (node) {\n                getTypeOfNode(node);\n            });\n        }\n        function getSymbolAtLocation(node) {\n            resolveLocation(node);\n            return getSymbolInfo(node);\n        }\n        function getTypeAtLocation(node) {\n            resolveLocation(node);\n            return getTypeOfNode(node);\n        }\n        function getTypeOfSymbolAtLocation(symbol, node) {\n            resolveLocation(node);\n            // Get the narrowed type of symbol at given location instead of just getting \n            // the type of the symbol.\n            // eg. \n            // function foo(a: string | number) {\n            //     if (typeof a === \"string\") {\n            //         a/**/\n            //     }\n            // }\n            // getTypeOfSymbol for a would return type of parameter symbol string | number\n            // Unless we provide location /**/, checker wouldn't know how to narrow the type\n            // By using getNarrowedTypeOfSymbol would return string since it would be able to narrow\n            // it by typeguard in the if true condition\n            return getNarrowedTypeOfSymbol(symbol, node);\n        }\n        // Get the narrowed type of a given symbol at a given location\n        function getNarrowedTypeOfSymbol(symbol, node) {\n            var type = getTypeOfSymbol(symbol);\n            // Only narrow when symbol is variable of an object, union, or type parameter type\n            if (node && symbol.flags & 3 /* Variable */ && type.flags & (48128 /* ObjectType */ | 16384 /* Union */ | 512 /* TypeParameter */)) {\n                loop: while (node.parent) {\n                    var child = node;\n                    node = node.parent;\n                    var narrowedType = type;\n                    switch (node.kind) {\n                        case 167 /* IfStatement */:\n                            // In a branch of an if statement, narrow based on controlling expression\n                            if (child !== node.expression) {\n                                narrowedType = narrowType(type, node.expression, child === node.thenStatement);\n                            }\n                            break;\n                        case 158 /* ConditionalExpression */:\n                            // In a branch of a conditional expression, narrow based on controlling condition\n                            if (child !== node.condition) {\n                                narrowedType = narrowType(type, node.condition, child === node.whenTrue);\n                            }\n                            break;\n                        case 157 /* BinaryExpression */:\n                            // In the right operand of an && or ||, narrow based on left operand\n                            if (child === node.right) {\n                                if (node.operator === 47 /* AmpersandAmpersandToken */) {\n                                    narrowedType = narrowType(type, node.left, true);\n                                }\n                                else if (node.operator === 48 /* BarBarToken */) {\n                                    narrowedType = narrowType(type, node.left, false);\n                                }\n                            }\n                            break;\n                        case 201 /* SourceFile */:\n                        case 189 /* ModuleDeclaration */:\n                        case 184 /* FunctionDeclaration */:\n                        case 125 /* Method */:\n                        case 127 /* GetAccessor */:\n                        case 128 /* SetAccessor */:\n                        case 126 /* Constructor */:\n                            break loop;\n                    }\n                    // Use narrowed type if it is a subtype and construct contains no assignments to variable\n                    if (narrowedType !== type && isTypeSubtypeOf(narrowedType, type)) {\n                        if (isVariableAssignedWithin(symbol, node)) {\n                            break;\n                        }\n                        type = narrowedType;\n                    }\n                }\n            }\n            return type;\n            function narrowTypeByEquality(type, expr, assumeTrue) {\n                // Check that we have 'typeof <symbol>' on the left and string literal on the right\n                if (expr.left.kind !== 153 /* TypeOfExpression */ || expr.right.kind !== 7 /* StringLiteral */) {\n                    return type;\n                }\n                var left = expr.left;\n                var right = expr.right;\n                if (left.expression.kind !== 63 /* Identifier */ || getResolvedSymbol(left.expression) !== symbol) {\n                    return type;\n                }\n                var t = right.text;\n                var checkType = t === \"string\" ? stringType : t === \"number\" ? numberType : t === \"boolean\" ? booleanType : emptyObjectType;\n                if (expr.operator === 30 /* ExclamationEqualsEqualsToken */) {\n                    assumeTrue = !assumeTrue;\n                }\n                if (assumeTrue) {\n                    // The assumed result is true. If check was for a primitive type, that type is the narrowed type. Otherwise we can\n                    // remove the primitive types from the narrowed type.\n                    return checkType === emptyObjectType ? subtractPrimitiveTypes(type, 2 /* String */ | 4 /* Number */ | 8 /* Boolean */) : checkType;\n                }\n                else {\n                    // The assumed result is false. If check was for a primitive type we can remove that type from the narrowed type.\n                    // Otherwise we don't have enough information to do anything.\n                    return checkType === emptyObjectType ? type : subtractPrimitiveTypes(type, checkType.flags);\n                }\n            }\n            function narrowTypeByAnd(type, expr, assumeTrue) {\n                if (assumeTrue) {\n                    // The assumed result is true, therefore we narrow assuming each operand to be true.\n                    return narrowType(narrowType(type, expr.left, true), expr.right, true);\n                }\n                else {\n                    // The assumed result is false. This means either the first operand was false, or the first operand was true\n                    // and the second operand was false. We narrow with those assumptions and union the two resulting types.\n                    return getUnionType([\n                        narrowType(type, expr.left, false),\n                        narrowType(narrowType(type, expr.left, true), expr.right, false)\n                    ]);\n                }\n            }\n            function narrowTypeByOr(type, expr, assumeTrue) {\n                if (assumeTrue) {\n                    // The assumed result is true. This means either the first operand was true, or the first operand was false\n                    // and the second operand was true. We narrow with those assumptions and union the two resulting types.\n                    return getUnionType([\n                        narrowType(type, expr.left, true),\n                        narrowType(narrowType(type, expr.left, false), expr.right, true)\n                    ]);\n                }\n                else {\n                    // The assumed result is false, therefore we narrow assuming each operand to be false.\n                    return narrowType(narrowType(type, expr.left, false), expr.right, false);\n                }\n            }\n            function narrowTypeByInstanceof(type, expr, assumeTrue) {\n                // Check that assumed result is true and we have variable symbol on the left\n                if (!assumeTrue || expr.left.kind !== 63 /* Identifier */ || getResolvedSymbol(expr.left) !== symbol) {\n                    return type;\n                }\n                // Check that right operand is a function type with a prototype property\n                var rightType = checkExpression(expr.right);\n                if (!isTypeSubtypeOf(rightType, globalFunctionType)) {\n                    return type;\n                }\n                var prototypeProperty = getPropertyOfType(rightType, \"prototype\");\n                if (!prototypeProperty) {\n                    return type;\n                }\n                var prototypeType = getTypeOfSymbol(prototypeProperty);\n                // Narrow to type of prototype property if it is a subtype of current type\n                return isTypeSubtypeOf(prototypeType, type) ? prototypeType : type;\n            }\n            // Narrow the given type based on the given expression having the assumed boolean value\n            function narrowType(type, expr, assumeTrue) {\n                switch (expr.kind) {\n                    case 149 /* ParenthesizedExpression */:\n                        return narrowType(type, expr.expression, assumeTrue);\n                    case 157 /* BinaryExpression */:\n                        var operator = expr.operator;\n                        if (operator === 29 /* EqualsEqualsEqualsToken */ || operator === 30 /* ExclamationEqualsEqualsToken */) {\n                            return narrowTypeByEquality(type, expr, assumeTrue);\n                        }\n                        else if (operator === 47 /* AmpersandAmpersandToken */) {\n                            return narrowTypeByAnd(type, expr, assumeTrue);\n                        }\n                        else if (operator === 48 /* BarBarToken */) {\n                            return narrowTypeByOr(type, expr, assumeTrue);\n                        }\n                        else if (operator === 85 /* InstanceOfKeyword */) {\n                            return narrowTypeByInstanceof(type, expr, assumeTrue);\n                        }\n                        break;\n                    case 155 /* PrefixUnaryExpression */:\n                        if (expr.operator === 45 /* ExclamationToken */) {\n                            return narrowType(type, expr.operand, !assumeTrue);\n                        }\n                        break;\n                }\n                return type;\n            }\n        }\n        function checkIdentifier(node) {\n            var symbol = getResolvedSymbol(node);\n            if (symbol.flags & 33554432 /* Import */) {\n                // Mark the import as referenced so that we emit it in the final .js file.\n                // exception: identifiers that appear in type queries, const enums, modules that contain only const enums\n                getSymbolLinks(symbol).referenced = getSymbolLinks(symbol).referenced || (!isInTypeQuery(node) && !isConstEnumOrConstEnumOnlyModule(resolveImport(symbol)));\n            }\n            checkCollisionWithCapturedSuperVariable(node, node);\n            checkCollisionWithCapturedThisVariable(node, node);\n            checkCollisionWithIndexVariableInGeneratedCode(node, node);\n            return getNarrowedTypeOfSymbol(getExportSymbolOfValueSymbolIfExported(symbol), node);\n        }\n        function captureLexicalThis(node, container) {\n            var classNode = container.parent && container.parent.kind === 185 /* ClassDeclaration */ ? container.parent : undefined;\n            getNodeLinks(node).flags |= 2 /* LexicalThis */;\n            if (container.kind === 124 /* Property */ || container.kind === 126 /* Constructor */) {\n                getNodeLinks(classNode).flags |= 4 /* CaptureThis */;\n            }\n            else {\n                getNodeLinks(container).flags |= 4 /* CaptureThis */;\n            }\n        }\n        function checkThisExpression(node) {\n            // Stop at the first arrow function so that we can\n            // tell whether 'this' needs to be captured.\n            var container = ts.getThisContainer(node, true);\n            var needToCaptureLexicalThis = false;\n            // Now skip arrow functions to get the \"real\" owner of 'this'.\n            if (container.kind === 151 /* ArrowFunction */) {\n                container = ts.getThisContainer(container, false);\n                needToCaptureLexicalThis = true;\n            }\n            switch (container.kind) {\n                case 189 /* ModuleDeclaration */:\n                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_module_body);\n                    break;\n                case 188 /* EnumDeclaration */:\n                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_current_location);\n                    break;\n                case 126 /* Constructor */:\n                    if (isInConstructorArgumentInitializer(node, container)) {\n                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_constructor_arguments);\n                    }\n                    break;\n                case 124 /* Property */:\n                    if (container.flags & 128 /* Static */) {\n                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_static_property_initializer);\n                    }\n                    break;\n            }\n            if (needToCaptureLexicalThis) {\n                captureLexicalThis(node, container);\n            }\n            var classNode = container.parent && container.parent.kind === 185 /* ClassDeclaration */ ? container.parent : undefined;\n            if (classNode) {\n                var symbol = getSymbolOfNode(classNode);\n                return container.flags & 128 /* Static */ ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol);\n            }\n            return anyType;\n        }\n        function getSuperContainer(node) {\n            while (true) {\n                node = node.parent;\n                if (!node)\n                    return node;\n                switch (node.kind) {\n                    case 184 /* FunctionDeclaration */:\n                    case 150 /* FunctionExpression */:\n                    case 151 /* ArrowFunction */:\n                    case 124 /* Property */:\n                    case 125 /* Method */:\n                    case 126 /* Constructor */:\n                    case 127 /* GetAccessor */:\n                    case 128 /* SetAccessor */:\n                        return node;\n                }\n            }\n        }\n        function isInConstructorArgumentInitializer(node, constructorDecl) {\n            for (var n = node; n && n !== constructorDecl; n = n.parent) {\n                if (n.kind === 123 /* Parameter */) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkSuperExpression(node) {\n            var isCallExpression = node.parent.kind === 145 /* CallExpression */ && node.parent.expression === node;\n            var enclosingClass = ts.getAncestor(node, 185 /* ClassDeclaration */);\n            var baseClass;\n            if (enclosingClass && ts.getClassBaseTypeNode(enclosingClass)) {\n                var classType = getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingClass));\n                baseClass = classType.baseTypes.length && classType.baseTypes[0];\n            }\n            if (!baseClass) {\n                error(node, ts.Diagnostics.super_can_only_be_referenced_in_a_derived_class);\n                return unknownType;\n            }\n            var container = getSuperContainer(node);\n            if (container) {\n                var canUseSuperExpression = false;\n                if (isCallExpression) {\n                    // TS 1.0 SPEC (April 2014): 4.8.1\n                    // Super calls are only permitted in constructors of derived classes\n                    canUseSuperExpression = container.kind === 126 /* Constructor */;\n                }\n                else {\n                    // TS 1.0 SPEC (April 2014)\n                    // 'super' property access is allowed\n                    // - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance\n                    // - In a static member function or static member accessor\n                    // super property access might appear in arrow functions with arbitrary deep nesting\n                    var needToCaptureLexicalThis = false;\n                    while (container && container.kind === 151 /* ArrowFunction */) {\n                        container = getSuperContainer(container);\n                        needToCaptureLexicalThis = true;\n                    }\n                    // topmost container must be something that is directly nested in the class declaration\n                    if (container && container.parent && container.parent.kind === 185 /* ClassDeclaration */) {\n                        if (container.flags & 128 /* Static */) {\n                            canUseSuperExpression = container.kind === 125 /* Method */ || container.kind === 127 /* GetAccessor */ || container.kind === 128 /* SetAccessor */;\n                        }\n                        else {\n                            canUseSuperExpression = container.kind === 125 /* Method */ || container.kind === 127 /* GetAccessor */ || container.kind === 128 /* SetAccessor */ || container.kind === 124 /* Property */ || container.kind === 126 /* Constructor */;\n                        }\n                    }\n                }\n                if (canUseSuperExpression) {\n                    var returnType;\n                    if ((container.flags & 128 /* Static */) || isCallExpression) {\n                        getNodeLinks(node).flags |= 32 /* SuperStatic */;\n                        returnType = getTypeOfSymbol(baseClass.symbol);\n                    }\n                    else {\n                        getNodeLinks(node).flags |= 16 /* SuperInstance */;\n                        returnType = baseClass;\n                    }\n                    if (container.kind === 126 /* Constructor */ && isInConstructorArgumentInitializer(node, container)) {\n                        // issue custom error message for super property access in constructor arguments (to be aligned with old compiler)\n                        error(node, ts.Diagnostics.super_cannot_be_referenced_in_constructor_arguments);\n                        returnType = unknownType;\n                    }\n                    if (!isCallExpression && needToCaptureLexicalThis) {\n                        // call expressions are allowed only in constructors so they should always capture correct 'this'\n                        // super property access expressions can also appear in arrow functions -\n                        // in this case they should also use correct lexical this\n                        captureLexicalThis(node.parent, container);\n                    }\n                    return returnType;\n                }\n            }\n            if (isCallExpression) {\n                error(node, ts.Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);\n            }\n            else {\n                error(node, ts.Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);\n            }\n            return unknownType;\n        }\n        // Return contextual type of parameter or undefined if no contextual type is available\n        function getContextuallyTypedParameterType(parameter) {\n            if (isFunctionExpressionOrArrowFunction(parameter.parent)) {\n                var func = parameter.parent;\n                if (isContextSensitive(func)) {\n                    var contextualSignature = getContextualSignature(func);\n                    if (contextualSignature) {\n                        var funcHasRestParameters = ts.hasRestParameters(func);\n                        var len = func.parameters.length - (funcHasRestParameters ? 1 : 0);\n                        var indexOfParameter = ts.indexOf(func.parameters, parameter);\n                        if (indexOfParameter < len) {\n                            return getTypeAtPosition(contextualSignature, indexOfParameter);\n                        }\n                        // If last parameter is contextually rest parameter get its type\n                        if (indexOfParameter === (func.parameters.length - 1) && funcHasRestParameters && contextualSignature.hasRestParameter && func.parameters.length >= contextualSignature.parameters.length) {\n                            return getTypeOfSymbol(contextualSignature.parameters[contextualSignature.parameters.length - 1]);\n                        }\n                    }\n                }\n            }\n            return undefined;\n        }\n        // In a variable, parameter or property declaration with a type annotation, the contextual type of an initializer\n        // expression is the type of the variable, parameter or property. In a parameter declaration of a contextually\n        // typed function expression, the contextual type of an initializer expression is the contextual type of the\n        // parameter.\n        function getContextualTypeForInitializerExpression(node) {\n            var declaration = node.parent;\n            if (node === declaration.initializer) {\n                if (declaration.type) {\n                    return getTypeFromTypeNode(declaration.type);\n                }\n                if (declaration.kind === 123 /* Parameter */) {\n                    return getContextuallyTypedParameterType(declaration);\n                }\n            }\n            return undefined;\n        }\n        function getContextualTypeForReturnExpression(node) {\n            var func = ts.getContainingFunction(node);\n            if (func) {\n                // If the containing function has a return type annotation, is a constructor, or is a get accessor whose\n                // corresponding set accessor has a type annotation, return statements in the function are contextually typed\n                if (func.type || func.kind === 126 /* Constructor */ || func.kind === 127 /* GetAccessor */ && getSetAccessorTypeAnnotationNode(ts.getDeclarationOfKind(func.symbol, 128 /* SetAccessor */))) {\n                    return getReturnTypeOfSignature(getSignatureFromDeclaration(func));\n                }\n                // Otherwise, if the containing function is contextually typed by a function type with exactly one call signature\n                // and that call signature is non-generic, return statements are contextually typed by the return type of the signature\n                var signature = getContextualSignatureForFunctionLikeDeclaration(func);\n                if (signature) {\n                    return getReturnTypeOfSignature(signature);\n                }\n            }\n            return undefined;\n        }\n        // In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.\n        function getContextualTypeForArgument(callTarget, arg) {\n            var args = getEffectiveCallArguments(callTarget);\n            var argIndex = ts.indexOf(args, arg);\n            if (argIndex >= 0) {\n                var signature = getResolvedSignature(callTarget);\n                return getTypeAtPosition(signature, argIndex);\n            }\n            return undefined;\n        }\n        function getContextualTypeForSubstitutionExpression(template, substitutionExpression) {\n            if (template.parent.kind === 147 /* TaggedTemplateExpression */) {\n                return getContextualTypeForArgument(template.parent, substitutionExpression);\n            }\n            return undefined;\n        }\n        function getContextualTypeForBinaryOperand(node) {\n            var binaryExpression = node.parent;\n            var operator = binaryExpression.operator;\n            if (operator >= 51 /* FirstAssignment */ && operator <= 62 /* LastAssignment */) {\n                // In an assignment expression, the right operand is contextually typed by the type of the left operand.\n                if (node === binaryExpression.right) {\n                    return checkExpression(binaryExpression.left);\n                }\n            }\n            else if (operator === 48 /* BarBarToken */) {\n                // When an || expression has a contextual type, the operands are contextually typed by that type. When an ||\n                // expression has no contextual type, the right operand is contextually typed by the type of the left operand.\n                var type = getContextualType(binaryExpression);\n                if (!type && node === binaryExpression.right) {\n                    type = checkExpression(binaryExpression.left);\n                }\n                return type;\n            }\n            return undefined;\n        }\n        // Apply a mapping function to a contextual type and return the resulting type. If the contextual type\n        // is a union type, the mapping function is applied to each constituent type and a union of the resulting\n        // types is returned.\n        function applyToContextualType(type, mapper) {\n            if (!(type.flags & 16384 /* Union */)) {\n                return mapper(type);\n            }\n            var types = type.types;\n            var mappedType;\n            var mappedTypes;\n            for (var i = 0; i < types.length; i++) {\n                var t = mapper(types[i]);\n                if (t) {\n                    if (!mappedType) {\n                        mappedType = t;\n                    }\n                    else if (!mappedTypes) {\n                        mappedTypes = [mappedType, t];\n                    }\n                    else {\n                        mappedTypes.push(t);\n                    }\n                }\n            }\n            return mappedTypes ? getUnionType(mappedTypes) : mappedType;\n        }\n        function getTypeOfPropertyOfContextualType(type, name) {\n            return applyToContextualType(type, function (t) {\n                var prop = getPropertyOfObjectType(t, name);\n                return prop ? getTypeOfSymbol(prop) : undefined;\n            });\n        }\n        function getIndexTypeOfContextualType(type, kind) {\n            return applyToContextualType(type, function (t) { return getIndexTypeOfObjectOrUnionType(t, kind); });\n        }\n        // Return true if the given contextual type is a tuple-like type\n        function contextualTypeIsTupleType(type) {\n            return !!(type.flags & 16384 /* Union */ ? ts.forEach(type.types, function (t) { return getPropertyOfObjectType(t, \"0\"); }) : getPropertyOfObjectType(type, \"0\"));\n        }\n        // Return true if the given contextual type provides an index signature of the given kind\n        function contextualTypeHasIndexSignature(type, kind) {\n            return !!(type.flags & 16384 /* Union */ ? ts.forEach(type.types, function (t) { return getIndexTypeOfObjectOrUnionType(t, kind); }) : getIndexTypeOfObjectOrUnionType(type, kind));\n        }\n        // In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of\n        // the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one\n        // exists. Otherwise, it is the type of the string index signature in T, if one exists.\n        function getContextualTypeForObjectLiteralMethod(node) {\n            ts.Debug.assert(ts.isObjectLiteralMethod(node));\n            if (isInsideWithStatementBody(node)) {\n                // We cannot answer semantic questions within a with block, do not proceed any further\n                return undefined;\n            }\n            return getContextualTypeForObjectLiteralElement(node);\n        }\n        function getContextualTypeForObjectLiteralElement(element) {\n            var objectLiteral = element.parent;\n            var type = getContextualType(objectLiteral);\n            // TODO(jfreeman): Handle this case for computed names and symbols\n            var name = element.name.text;\n            if (type && name) {\n                return getTypeOfPropertyOfContextualType(type, name) || isNumericName(name) && getIndexTypeOfContextualType(type, 1 /* Number */) || getIndexTypeOfContextualType(type, 0 /* String */);\n            }\n            return undefined;\n        }\n        // In an array literal contextually typed by a type T, the contextual type of an element expression at index N is\n        // the type of the property with the numeric name N in T, if one exists. Otherwise, it is the type of the numeric\n        // index signature in T, if one exists.\n        function getContextualTypeForElementExpression(node) {\n            var arrayLiteral = node.parent;\n            var type = getContextualType(arrayLiteral);\n            if (type) {\n                var index = ts.indexOf(arrayLiteral.elements, node);\n                return getTypeOfPropertyOfContextualType(type, \"\" + index) || getIndexTypeOfContextualType(type, 1 /* Number */);\n            }\n            return undefined;\n        }\n        // In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.\n        function getContextualTypeForConditionalOperand(node) {\n            var conditional = node.parent;\n            return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional) : undefined;\n        }\n        // Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily\n        // be \"pushed\" onto a node using the contextualType property.\n        function getContextualType(node) {\n            if (isInsideWithStatementBody(node)) {\n                // We cannot answer semantic questions within a with block, do not proceed any further\n                return undefined;\n            }\n            if (node.contextualType) {\n                return node.contextualType;\n            }\n            var parent = node.parent;\n            switch (parent.kind) {\n                case 183 /* VariableDeclaration */:\n                case 123 /* Parameter */:\n                case 124 /* Property */:\n                    return getContextualTypeForInitializerExpression(node);\n                case 151 /* ArrowFunction */:\n                case 174 /* ReturnStatement */:\n                    return getContextualTypeForReturnExpression(node);\n                case 145 /* CallExpression */:\n                case 146 /* NewExpression */:\n                    return getContextualTypeForArgument(parent, node);\n                case 148 /* TypeAssertionExpression */:\n                    return getTypeFromTypeNode(parent.type);\n                case 157 /* BinaryExpression */:\n                    return getContextualTypeForBinaryOperand(node);\n                case 198 /* PropertyAssignment */:\n                    return getContextualTypeForObjectLiteralElement(parent);\n                case 141 /* ArrayLiteralExpression */:\n                    return getContextualTypeForElementExpression(node);\n                case 158 /* ConditionalExpression */:\n                    return getContextualTypeForConditionalOperand(node);\n                case 162 /* TemplateSpan */:\n                    ts.Debug.assert(parent.parent.kind === 159 /* TemplateExpression */);\n                    return getContextualTypeForSubstitutionExpression(parent.parent, node);\n            }\n            return undefined;\n        }\n        // If the given type is an object or union type, if that type has a single signature, and if\n        // that signature is non-generic, return the signature. Otherwise return undefined.\n        function getNonGenericSignature(type) {\n            var signatures = getSignaturesOfObjectOrUnionType(type, 0 /* Call */);\n            if (signatures.length === 1) {\n                var signature = signatures[0];\n                if (!signature.typeParameters) {\n                    return signature;\n                }\n            }\n        }\n        function isFunctionExpressionOrArrowFunction(node) {\n            return node.kind === 150 /* FunctionExpression */ || node.kind === 151 /* ArrowFunction */;\n        }\n        function getContextualSignatureForFunctionLikeDeclaration(node) {\n            // Only function expressions and arrow functions are contextually typed.\n            return isFunctionExpressionOrArrowFunction(node) ? getContextualSignature(node) : undefined;\n        }\n        // Return the contextual signature for a given expression node. A contextual type provides a\n        // contextual signature if it has a single call signature and if that call signature is non-generic.\n        // If the contextual type is a union type, get the signature from each type possible and if they are \n        // all identical ignoring their return type, the result is same signature but with return type as \n        // union type of return types from these signatures\n        function getContextualSignature(node) {\n            ts.Debug.assert(node.kind !== 125 /* Method */ || ts.isObjectLiteralMethod(node));\n            var type = ts.isObjectLiteralMethod(node) ? getContextualTypeForObjectLiteralMethod(node) : getContextualType(node);\n            if (!type) {\n                return undefined;\n            }\n            if (!(type.flags & 16384 /* Union */)) {\n                return getNonGenericSignature(type);\n            }\n            var signatureList;\n            var types = type.types;\n            for (var i = 0; i < types.length; i++) {\n                // The signature set of all constituent type with call signatures should match\n                // So number of signatures allowed is either 0 or 1\n                if (signatureList && getSignaturesOfObjectOrUnionType(types[i], 0 /* Call */).length > 1) {\n                    return undefined;\n                }\n                var signature = getNonGenericSignature(types[i]);\n                if (signature) {\n                    if (!signatureList) {\n                        // This signature will contribute to contextual union signature\n                        signatureList = [signature];\n                    }\n                    else if (!compareSignatures(signatureList[0], signature, false, compareTypes)) {\n                        // Signatures arent identical, do not use\n                        return undefined;\n                    }\n                    else {\n                        // Use this signature for contextual union signature\n                        signatureList.push(signature);\n                    }\n                }\n            }\n            // Result is union of signatures collected (return type is union of return types of this signature set)\n            var result;\n            if (signatureList) {\n                result = cloneSignature(signatureList[0]);\n                // Clear resolved return type we possibly got from cloneSignature\n                result.resolvedReturnType = undefined;\n                result.unionSignatures = signatureList;\n            }\n            return result;\n        }\n        // Presence of a contextual type mapper indicates inferential typing, except the identityMapper object is\n        // used as a special marker for other purposes.\n        function isInferentialContext(mapper) {\n            return mapper && mapper !== identityMapper;\n        }\n        function checkArrayLiteral(node, contextualMapper) {\n            var elements = node.elements;\n            if (!elements.length) {\n                return createArrayType(undefinedType);\n            }\n            var elementTypes = ts.map(elements, function (e) { return checkExpression(e, contextualMapper); });\n            var contextualType = getContextualType(node);\n            if (contextualType && contextualTypeIsTupleType(contextualType)) {\n                return createTupleType(elementTypes);\n            }\n            return createArrayType(getUnionType(elementTypes));\n        }\n        function isNumericName(name) {\n            // The intent of numeric names is that\n            //     - they are names with text in a numeric form, and that\n            //     - setting properties/indexing with them is always equivalent to doing so with the numeric literal 'numLit',\n            //         acquired by applying the abstract 'ToNumber' operation on the name's text.\n            //\n            // The subtlety is in the latter portion, as we cannot reliably say that anything that looks like a numeric literal is a numeric name.\n            // In fact, it is the case that the text of the name must be equal to 'ToString(numLit)' for this to hold.\n            //\n            // Consider the property name '\"0xF00D\"'. When one indexes with '0xF00D', they are actually indexing with the value of 'ToString(0xF00D)'\n            // according to the ECMAScript specification, so it is actually as if the user indexed with the string '\"61453\"'.\n            // Thus, the text of all numeric literals equivalent to '61543' such as '0xF00D', '0xf00D', '0170015', etc. are not valid numeric names\n            // because their 'ToString' representation is not equal to their original text.\n            // This is motivated by ECMA-262 sections 9.3.1, 9.8.1, 11.1.5, and 11.2.1.\n            //\n            // Here, we test whether 'ToString(ToNumber(name))' is exactly equal to 'name'.\n            // The '+' prefix operator is equivalent here to applying the abstract ToNumber operation.\n            // Applying the 'toString()' method on a number gives us the abstract ToString operation on a number.\n            //\n            // Note that this accepts the values 'Infinity', '-Infinity', and 'NaN', and that this is intentional.\n            // This is desired behavior, because when indexing with them as numeric entities, you are indexing\n            // with the strings '\"Infinity\"', '\"-Infinity\"', and '\"NaN\"' respectively.\n            return (+name).toString() === name;\n        }\n        function checkObjectLiteral(node, contextualMapper) {\n            var members = node.symbol.members;\n            var properties = {};\n            var contextualType = getContextualType(node);\n            for (var id in members) {\n                if (ts.hasProperty(members, id)) {\n                    var member = members[id];\n                    if (member.flags & 4 /* Property */ || ts.isObjectLiteralMethod(member.declarations[0])) {\n                        var memberDecl = member.declarations[0];\n                        var type;\n                        if (memberDecl.kind === 198 /* PropertyAssignment */) {\n                            type = checkExpression(memberDecl.initializer, contextualMapper);\n                        }\n                        else if (memberDecl.kind === 125 /* Method */) {\n                            type = checkObjectLiteralMethod(memberDecl, contextualMapper);\n                        }\n                        else {\n                            ts.Debug.assert(memberDecl.kind === 199 /* ShorthandPropertyAssignment */);\n                            type = memberDecl.name.kind === 121 /* ComputedPropertyName */ ? unknownType : checkExpression(memberDecl.name, contextualMapper);\n                        }\n                        var prop = createSymbol(4 /* Property */ | 268435456 /* Transient */ | member.flags, member.name);\n                        prop.declarations = member.declarations;\n                        prop.parent = member.parent;\n                        if (member.valueDeclaration) {\n                            prop.valueDeclaration = member.valueDeclaration;\n                        }\n                        prop.type = type;\n                        prop.target = member;\n                        member = prop;\n                    }\n                    else {\n                        // TypeScript 1.0 spec (April 2014)\n                        // A get accessor declaration is processed in the same manner as \n                        // an ordinary function declaration(section 6.1) with no parameters.\n                        // A set accessor declaration is processed in the same manner \n                        // as an ordinary function declaration with a single parameter and a Void return type.\n                        var getAccessor = ts.getDeclarationOfKind(member, 127 /* GetAccessor */);\n                        if (getAccessor) {\n                            checkAccessorDeclaration(getAccessor);\n                        }\n                        var setAccessor = ts.getDeclarationOfKind(member, 128 /* SetAccessor */);\n                        if (setAccessor) {\n                            checkAccessorDeclaration(setAccessor);\n                        }\n                    }\n                    properties[member.name] = member;\n                }\n            }\n            var stringIndexType = getIndexType(0 /* String */);\n            var numberIndexType = getIndexType(1 /* Number */);\n            return createAnonymousType(node.symbol, properties, emptyArray, emptyArray, stringIndexType, numberIndexType);\n            function getIndexType(kind) {\n                if (contextualType && contextualTypeHasIndexSignature(contextualType, kind)) {\n                    var propTypes = [];\n                    for (var id in properties) {\n                        if (ts.hasProperty(properties, id)) {\n                            if (kind === 0 /* String */ || isNumericName(id)) {\n                                var type = getTypeOfSymbol(properties[id]);\n                                if (!ts.contains(propTypes, type)) {\n                                    propTypes.push(type);\n                                }\n                            }\n                        }\n                    }\n                    return propTypes.length ? getUnionType(propTypes) : undefinedType;\n                }\n                return undefined;\n            }\n        }\n        // If a symbol is a synthesized symbol with no value declaration, we assume it is a property. Example of this are the synthesized\n        // '.prototype' property as well as synthesized tuple index properties.\n        function getDeclarationKindFromSymbol(s) {\n            return s.valueDeclaration ? s.valueDeclaration.kind : 124 /* Property */;\n        }\n        function getDeclarationFlagsFromSymbol(s) {\n            return s.valueDeclaration ? s.valueDeclaration.flags : s.flags & 536870912 /* Prototype */ ? 16 /* Public */ | 128 /* Static */ : 0;\n        }\n        function checkClassPropertyAccess(node, left, type, prop) {\n            var flags = getDeclarationFlagsFromSymbol(prop);\n            // Public properties are always accessible\n            if (!(flags & (32 /* Private */ | 64 /* Protected */))) {\n                return;\n            }\n            // Property is known to be private or protected at this point\n            // Get the declaring and enclosing class instance types\n            var enclosingClassDeclaration = ts.getAncestor(node, 185 /* ClassDeclaration */);\n            var enclosingClass = enclosingClassDeclaration ? getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingClassDeclaration)) : undefined;\n            var declaringClass = getDeclaredTypeOfSymbol(prop.parent);\n            // Private property is accessible if declaring and enclosing class are the same\n            if (flags & 32 /* Private */) {\n                if (declaringClass !== enclosingClass) {\n                    error(node, ts.Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(declaringClass));\n                }\n                return;\n            }\n            // Property is known to be protected at this point\n            // All protected properties of a supertype are accessible in a super access\n            if (left.kind === 89 /* SuperKeyword */) {\n                return;\n            }\n            // A protected property is accessible in the declaring class and classes derived from it\n            if (!enclosingClass || !hasBaseType(enclosingClass, declaringClass)) {\n                error(node, ts.Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(declaringClass));\n                return;\n            }\n            // No further restrictions for static properties\n            if (flags & 128 /* Static */) {\n                return;\n            }\n            // An instance property must be accessed through an instance of the enclosing class\n            if (!(getTargetType(type).flags & (1024 /* Class */ | 2048 /* Interface */) && hasBaseType(type, enclosingClass))) {\n                error(node, ts.Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1, symbolToString(prop), typeToString(enclosingClass));\n            }\n        }\n        function checkPropertyAccessExpression(node) {\n            return checkPropertyAccessExpressionOrQualifiedName(node, node.expression, node.name);\n        }\n        function checkQualifiedName(node) {\n            return checkPropertyAccessExpressionOrQualifiedName(node, node.left, node.right);\n        }\n        function checkPropertyAccessExpressionOrQualifiedName(node, left, right) {\n            var type = checkExpressionOrQualifiedName(left);\n            if (type === unknownType)\n                return type;\n            if (type !== anyType) {\n                var apparentType = getApparentType(getWidenedType(type));\n                if (apparentType === unknownType) {\n                    // handle cases when type is Type parameter with invalid constraint\n                    return unknownType;\n                }\n                var prop = getPropertyOfType(apparentType, right.text);\n                if (!prop) {\n                    if (right.text) {\n                        error(right, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(right), typeToString(type));\n                    }\n                    return unknownType;\n                }\n                getNodeLinks(node).resolvedSymbol = prop;\n                if (prop.parent && prop.parent.flags & 32 /* Class */) {\n                    // TS 1.0 spec (April 2014): 4.8.2\n                    // - In a constructor, instance member function, instance member accessor, or \n                    //   instance member variable initializer where this references a derived class instance, \n                    //   a super property access is permitted and must specify a public instance member function of the base class.\n                    // - In a static member function or static member accessor \n                    //   where this references the constructor function object of a derived class, \n                    //   a super property access is permitted and must specify a public static member function of the base class.\n                    if (left.kind === 89 /* SuperKeyword */ && getDeclarationKindFromSymbol(prop) !== 125 /* Method */) {\n                        error(right, ts.Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);\n                    }\n                    else {\n                        checkClassPropertyAccess(node, left, type, prop);\n                    }\n                }\n                return getTypeOfSymbol(prop);\n            }\n            return anyType;\n        }\n        function isValidPropertyAccess(node, propertyName) {\n            var left = node.kind === 143 /* PropertyAccessExpression */ ? node.expression : node.left;\n            var type = checkExpressionOrQualifiedName(left);\n            if (type !== unknownType && type !== anyType) {\n                var prop = getPropertyOfType(getWidenedType(type), propertyName);\n                if (prop && prop.parent && prop.parent.flags & 32 /* Class */) {\n                    if (left.kind === 89 /* SuperKeyword */ && getDeclarationKindFromSymbol(prop) !== 125 /* Method */) {\n                        return false;\n                    }\n                    else {\n                        var diagnosticsCount = diagnostics.length;\n                        checkClassPropertyAccess(node, left, type, prop);\n                        return diagnostics.length === diagnosticsCount;\n                    }\n                }\n            }\n            return true;\n        }\n        function checkIndexedAccess(node) {\n            // Obtain base constraint such that we can bail out if the constraint is an unknown type\n            var objectType = getApparentType(checkExpression(node.expression));\n            var indexType = node.argumentExpression ? checkExpression(node.argumentExpression) : unknownType;\n            if (objectType === unknownType) {\n                return unknownType;\n            }\n            if (isConstEnumObjectType(objectType) && node.argumentExpression && node.argumentExpression.kind !== 7 /* StringLiteral */) {\n                error(node.argumentExpression, ts.Diagnostics.Index_expression_arguments_in_const_enums_must_be_of_type_string);\n            }\n            // TypeScript 1.0 spec (April 2014): 4.10 Property Access\n            // - If IndexExpr is a string literal or a numeric literal and ObjExpr's apparent type has a property with the name \n            //    given by that literal(converted to its string representation in the case of a numeric literal), the property access is of the type of that property.\n            // - Otherwise, if ObjExpr's apparent type has a numeric index signature and IndexExpr is of type Any, the Number primitive type, or an enum type, \n            //    the property access is of the type of that index signature.\n            // - Otherwise, if ObjExpr's apparent type has a string index signature and IndexExpr is of type Any, the String or Number primitive type, or an enum type, \n            //    the property access is of the type of that index signature.\n            // - Otherwise, if IndexExpr is of type Any, the String or Number primitive type, or an enum type, the property access is of type Any.\n            // See if we can index as a property.\n            if (node.argumentExpression) {\n                if (node.argumentExpression.kind === 7 /* StringLiteral */ || node.argumentExpression.kind === 6 /* NumericLiteral */) {\n                    var name = node.argumentExpression.text;\n                    var prop = getPropertyOfType(objectType, name);\n                    if (prop) {\n                        getNodeLinks(node).resolvedSymbol = prop;\n                        return getTypeOfSymbol(prop);\n                    }\n                }\n            }\n            // Check for compatible indexer types.\n            if (indexType.flags & (1 /* Any */ | 258 /* StringLike */ | 132 /* NumberLike */)) {\n                // Try to use a number indexer.\n                if (indexType.flags & (1 /* Any */ | 132 /* NumberLike */)) {\n                    var numberIndexType = getIndexTypeOfType(objectType, 1 /* Number */);\n                    if (numberIndexType) {\n                        return numberIndexType;\n                    }\n                }\n                // Try to use string indexing.\n                var stringIndexType = getIndexTypeOfType(objectType, 0 /* String */);\n                if (stringIndexType) {\n                    return stringIndexType;\n                }\n                // Fall back to any.\n                if (compilerOptions.noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors && objectType !== anyType) {\n                    error(node, ts.Diagnostics.Index_signature_of_object_type_implicitly_has_an_any_type);\n                }\n                return anyType;\n            }\n            // REVIEW: Users should know the type that was actually used.\n            error(node, ts.Diagnostics.An_index_expression_argument_must_be_of_type_string_number_or_any);\n            return unknownType;\n        }\n        function resolveUntypedCall(node) {\n            if (node.kind === 147 /* TaggedTemplateExpression */) {\n                checkExpression(node.template);\n            }\n            else {\n                ts.forEach(node.arguments, function (argument) {\n                    checkExpression(argument);\n                });\n            }\n            return anySignature;\n        }\n        function resolveErrorCall(node) {\n            resolveUntypedCall(node);\n            return unknownSignature;\n        }\n        function hasCorrectArity(node, args, signature) {\n            var adjustedArgCount;\n            var typeArguments;\n            var callIsIncomplete;\n            if (node.kind === 147 /* TaggedTemplateExpression */) {\n                var tagExpression = node;\n                // Even if the call is incomplete, we'll have a missing expression as our last argument,\n                // so we can say the count is just the arg list length\n                adjustedArgCount = args.length;\n                typeArguments = undefined;\n                if (tagExpression.template.kind === 159 /* TemplateExpression */) {\n                    // If a tagged template expression lacks a tail literal, the call is incomplete.\n                    // Specifically, a template only can end in a TemplateTail or a Missing literal.\n                    var templateExpression = tagExpression.template;\n                    var lastSpan = ts.lastOrUndefined(templateExpression.templateSpans);\n                    ts.Debug.assert(lastSpan !== undefined); // we should always have at least one span.\n                    callIsIncomplete = ts.getFullWidth(lastSpan.literal) === 0 || !!lastSpan.literal.isUnterminated;\n                }\n                else {\n                    // If the template didn't end in a backtick, or its beginning occurred right prior to EOF,\n                    // then this might actually turn out to be a TemplateHead in the future;\n                    // so we consider the call to be incomplete.\n                    var templateLiteral = tagExpression.template;\n                    ts.Debug.assert(templateLiteral.kind === 9 /* NoSubstitutionTemplateLiteral */);\n                    callIsIncomplete = !!templateLiteral.isUnterminated;\n                }\n            }\n            else {\n                var callExpression = node;\n                if (!callExpression.arguments) {\n                    // This only happens when we have something of the form: 'new C'\n                    ts.Debug.assert(callExpression.kind === 146 /* NewExpression */);\n                    return signature.minArgumentCount === 0;\n                }\n                // For IDE scenarios we may have an incomplete call, so a trailing comma is tantamount to adding another argument.\n                adjustedArgCount = callExpression.arguments.hasTrailingComma ? args.length + 1 : args.length;\n                // If we are missing the close paren, the call is incomplete.\n                callIsIncomplete = callExpression.arguments.end === callExpression.end;\n                typeArguments = callExpression.typeArguments;\n            }\n            ts.Debug.assert(adjustedArgCount !== undefined, \"'adjustedArgCount' undefined\");\n            ts.Debug.assert(callIsIncomplete !== undefined, \"'callIsIncomplete' undefined\");\n            return checkArity(adjustedArgCount, typeArguments, callIsIncomplete, signature);\n            /**\n             * @param adjustedArgCount The \"apparent\" number of arguments that we will have in this call.\n             * @param typeArguments    Type arguments node of the call if it exists; undefined otherwise.\n             * @param callIsIncomplete Whether or not a call is unfinished, and we should be \"lenient\" when we have too few arguments.\n             * @param signature        The signature whose arity we are comparing.\n             */\n            function checkArity(adjustedArgCount, typeArguments, callIsIncomplete, signature) {\n                // Too many arguments implies incorrect arity.\n                if (!signature.hasRestParameter && adjustedArgCount > signature.parameters.length) {\n                    return false;\n                }\n                // If the user supplied type arguments, but the number of type arguments does not match\n                // the declared number of type parameters, the call has an incorrect arity.\n                var hasRightNumberOfTypeArgs = !typeArguments || (signature.typeParameters && typeArguments.length === signature.typeParameters.length);\n                if (!hasRightNumberOfTypeArgs) {\n                    return false;\n                }\n                // If the call is incomplete, we should skip the lower bound check.\n                var hasEnoughArguments = adjustedArgCount >= signature.minArgumentCount;\n                return callIsIncomplete || hasEnoughArguments;\n            }\n        }\n        // If type has a single call signature and no other members, return that signature. Otherwise, return undefined.\n        function getSingleCallSignature(type) {\n            if (type.flags & 48128 /* ObjectType */) {\n                var resolved = resolveObjectOrUnionTypeMembers(type);\n                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 && resolved.properties.length === 0 && !resolved.stringIndexType && !resolved.numberIndexType) {\n                    return resolved.callSignatures[0];\n                }\n            }\n            return undefined;\n        }\n        // Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)\n        function instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper) {\n            var context = createInferenceContext(signature.typeParameters, true);\n            forEachMatchingParameterType(contextualSignature, signature, function (source, target) {\n                // Type parameters from outer context referenced by source type are fixed by instantiation of the source type\n                inferTypes(context, instantiateType(source, contextualMapper), target);\n            });\n            return getSignatureInstantiation(signature, getInferredTypes(context));\n        }\n        function inferTypeArguments(signature, args, excludeArgument) {\n            var typeParameters = signature.typeParameters;\n            var context = createInferenceContext(typeParameters, false);\n            var mapper = createInferenceMapper(context);\n            for (var i = 0; i < args.length; i++) {\n                if (args[i].kind === 161 /* OmittedExpression */) {\n                    continue;\n                }\n                if (!excludeArgument || excludeArgument[i] === undefined) {\n                    var parameterType = getTypeAtPosition(signature, i);\n                    if (i === 0 && args[i].parent.kind === 147 /* TaggedTemplateExpression */) {\n                        inferTypes(context, globalTemplateStringsArrayType, parameterType);\n                        continue;\n                    }\n                    inferTypes(context, checkExpressionWithContextualType(args[i], parameterType, mapper), parameterType);\n                }\n            }\n            // Next, infer from those context sensitive arguments that are no longer excluded\n            if (excludeArgument) {\n                for (var i = 0; i < args.length; i++) {\n                    if (args[i].kind === 161 /* OmittedExpression */) {\n                        continue;\n                    }\n                    // No need to special-case tagged templates; their excludeArgument value will be 'undefined'.\n                    if (excludeArgument[i] === false) {\n                        var parameterType = getTypeAtPosition(signature, i);\n                        inferTypes(context, checkExpressionWithContextualType(args[i], parameterType, mapper), parameterType);\n                    }\n                }\n            }\n            var inferredTypes = getInferredTypes(context);\n            // Inference has failed if the inferenceFailureType type is in list of inferences\n            context.failedTypeParameterIndex = ts.indexOf(inferredTypes, inferenceFailureType);\n            for (var i = 0; i < inferredTypes.length; i++) {\n                if (inferredTypes[i] === inferenceFailureType) {\n                    inferredTypes[i] = unknownType;\n                }\n            }\n            return context;\n        }\n        function checkTypeArguments(signature, typeArguments, typeArgumentResultTypes, reportErrors) {\n            var typeParameters = signature.typeParameters;\n            var typeArgumentsAreAssignable = true;\n            for (var i = 0; i < typeParameters.length; i++) {\n                var typeArgNode = typeArguments[i];\n                var typeArgument = getTypeFromTypeNode(typeArgNode);\n                // Do not push on this array! It has a preallocated length\n                typeArgumentResultTypes[i] = typeArgument;\n                if (typeArgumentsAreAssignable) {\n                    var constraint = getConstraintOfTypeParameter(typeParameters[i]);\n                    if (constraint) {\n                        typeArgumentsAreAssignable = checkTypeAssignableTo(typeArgument, constraint, reportErrors ? typeArgNode : undefined, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);\n                    }\n                }\n            }\n            return typeArgumentsAreAssignable;\n        }\n        function checkApplicableSignature(node, args, signature, relation, excludeArgument, reportErrors) {\n            for (var i = 0; i < args.length; i++) {\n                var arg = args[i];\n                var argType;\n                if (arg.kind === 161 /* OmittedExpression */) {\n                    continue;\n                }\n                var paramType = getTypeAtPosition(signature, i);\n                if (i === 0 && node.kind === 147 /* TaggedTemplateExpression */) {\n                    // A tagged template expression has something of a\n                    // \"virtual\" parameter with the \"cooked\" strings array type.\n                    argType = globalTemplateStringsArrayType;\n                }\n                else {\n                    // String literals get string literal types unless we're reporting errors\n                    argType = arg.kind === 7 /* StringLiteral */ && !reportErrors ? getStringLiteralType(arg) : checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);\n                }\n                // Use argument expression as error location when reporting errors\n                var isValidArgument = checkTypeRelatedTo(argType, paramType, relation, reportErrors ? arg : undefined, ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1);\n                if (!isValidArgument) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Returns the effective arguments for an expression that works like a function invocation.\n         *\n         * If 'node' is a CallExpression or a NewExpression, then its argument list is returned.\n         * If 'node' is a TaggedTemplateExpression, a new argument list is constructed from the substitution\n         *    expressions, where the first element of the list is the template for error reporting purposes.\n         */\n        function getEffectiveCallArguments(node) {\n            var args;\n            if (node.kind === 147 /* TaggedTemplateExpression */) {\n                var template = node.template;\n                args = [template];\n                if (template.kind === 159 /* TemplateExpression */) {\n                    ts.forEach(template.templateSpans, function (span) {\n                        args.push(span.expression);\n                    });\n                }\n            }\n            else {\n                args = node.arguments || emptyArray;\n            }\n            return args;\n        }\n        function resolveCall(node, signatures, candidatesOutArray) {\n            var isTaggedTemplate = node.kind === 147 /* TaggedTemplateExpression */;\n            var typeArguments = isTaggedTemplate ? undefined : node.typeArguments;\n            ts.forEach(typeArguments, checkSourceElement);\n            var candidates = candidatesOutArray || [];\n            // collectCandidates fills up the candidates array directly\n            collectCandidates();\n            if (!candidates.length) {\n                error(node, ts.Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);\n                return resolveErrorCall(node);\n            }\n            var args = getEffectiveCallArguments(node);\n            // The following applies to any value of 'excludeArgument[i]':\n            //    - true:      the argument at 'i' is susceptible to a one-time permanent contextual typing.\n            //    - undefined: the argument at 'i' is *not* susceptible to permanent contextual typing.\n            //    - false:     the argument at 'i' *was* and *has been* permanently contextually typed.\n            //\n            // The idea is that we will perform type argument inference & assignability checking once\n            // without using the susceptible parameters that are functions, and once more for each of those\n            // parameters, contextually typing each as we go along.\n            //\n            // For a tagged template, then the first argument be 'undefined' if necessary\n            // because it represents a TemplateStringsArray.\n            var excludeArgument;\n            for (var i = isTaggedTemplate ? 1 : 0; i < args.length; i++) {\n                if (isContextSensitive(args[i])) {\n                    if (!excludeArgument) {\n                        excludeArgument = new Array(args.length);\n                    }\n                    excludeArgument[i] = true;\n                }\n            }\n            // The following variables are captured and modified by calls to chooseOverload.\n            // If overload resolution or type argument inference fails, we want to report the\n            // best error possible. The best error is one which says that an argument was not\n            // assignable to a parameter. This implies that everything else about the overload\n            // was fine. So if there is any overload that is only incorrect because of an\n            // argument, we will report an error on that one.\n            //\n            //     function foo(s: string) {}\n            //     function foo(n: number) {} // Report argument error on this overload\n            //     function foo() {}\n            //     foo(true);\n            //\n            // If none of the overloads even made it that far, there are two possibilities.\n            // There was a problem with type arguments for some overload, in which case\n            // report an error on that. Or none of the overloads even had correct arity,\n            // in which case give an arity error.\n            //\n            //     function foo<T>(x: T, y: T) {} // Report type argument inference error\n            //     function foo() {}\n            //     foo(0, true);\n            //\n            var candidateForArgumentError;\n            var candidateForTypeArgumentError;\n            var resultOfFailedInference;\n            var result;\n            // Section 4.12.1:\n            // if the candidate list contains one or more signatures for which the type of each argument\n            // expression is a subtype of each corresponding parameter type, the return type of the first\n            // of those signatures becomes the return type of the function call.\n            // Otherwise, the return type of the first signature in the candidate list becomes the return\n            // type of the function call.\n            //\n            // Whether the call is an error is determined by assignability of the arguments. The subtype pass\n            // is just important for choosing the best signature. So in the case where there is only one\n            // signature, the subtype pass is useless. So skipping it is an optimization.\n            if (candidates.length > 1) {\n                result = chooseOverload(candidates, subtypeRelation);\n            }\n            if (!result) {\n                // Reinitialize these pointers for round two\n                candidateForArgumentError = undefined;\n                candidateForTypeArgumentError = undefined;\n                resultOfFailedInference = undefined;\n                result = chooseOverload(candidates, assignableRelation);\n            }\n            if (result) {\n                return result;\n            }\n            // No signatures were applicable. Now report errors based on the last applicable signature with\n            // no arguments excluded from assignability checks.\n            // If candidate is undefined, it means that no candidates had a suitable arity. In that case,\n            // skip the checkApplicableSignature check.\n            if (candidateForArgumentError) {\n                // excludeArgument is undefined, in this case also equivalent to [undefined, undefined, ...]\n                // The importance of excludeArgument is to prevent us from typing function expression parameters\n                // in arguments too early. If possible, we'd like to only type them once we know the correct\n                // overload. However, this matters for the case where the call is correct. When the call is\n                // an error, we don't need to exclude any arguments, although it would cause no harm to do so.\n                checkApplicableSignature(node, args, candidateForArgumentError, assignableRelation, undefined, true);\n            }\n            else if (candidateForTypeArgumentError) {\n                if (!isTaggedTemplate && node.typeArguments) {\n                    checkTypeArguments(candidateForTypeArgumentError, node.typeArguments, [], true);\n                }\n                else {\n                    ts.Debug.assert(resultOfFailedInference.failedTypeParameterIndex >= 0);\n                    var failedTypeParameter = candidateForTypeArgumentError.typeParameters[resultOfFailedInference.failedTypeParameterIndex];\n                    var inferenceCandidates = getInferenceCandidates(resultOfFailedInference, resultOfFailedInference.failedTypeParameterIndex);\n                    var diagnosticChainHead = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly, typeToString(failedTypeParameter));\n                    reportNoCommonSupertypeError(inferenceCandidates, node.expression || node.tag, diagnosticChainHead);\n                }\n            }\n            else {\n                error(node, ts.Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);\n            }\n            // No signature was applicable. We have already reported the errors for the invalid signature.\n            // If this is a type resolution session, e.g. Language Service, try to get better information that anySignature.\n            // Pick the first candidate that matches the arity. This way we can get a contextual type for cases like:\n            //  declare function f(a: { xa: number; xb: number; });\n            //  f({ |\n            if (!fullTypeCheck) {\n                for (var i = 0, n = candidates.length; i < n; i++) {\n                    if (hasCorrectArity(node, args, candidates[i])) {\n                        return candidates[i];\n                    }\n                }\n            }\n            return resolveErrorCall(node);\n            function chooseOverload(candidates, relation) {\n                for (var i = 0; i < candidates.length; i++) {\n                    if (!hasCorrectArity(node, args, candidates[i])) {\n                        continue;\n                    }\n                    var originalCandidate = candidates[i];\n                    var inferenceResult;\n                    while (true) {\n                        var candidate = originalCandidate;\n                        if (candidate.typeParameters) {\n                            var typeArgumentTypes;\n                            var typeArgumentsAreValid;\n                            if (typeArguments) {\n                                typeArgumentTypes = new Array(candidate.typeParameters.length);\n                                typeArgumentsAreValid = checkTypeArguments(candidate, typeArguments, typeArgumentTypes, false);\n                            }\n                            else {\n                                inferenceResult = inferTypeArguments(candidate, args, excludeArgument);\n                                typeArgumentsAreValid = inferenceResult.failedTypeParameterIndex < 0;\n                                typeArgumentTypes = inferenceResult.inferredTypes;\n                            }\n                            if (!typeArgumentsAreValid) {\n                                break;\n                            }\n                            candidate = getSignatureInstantiation(candidate, typeArgumentTypes);\n                        }\n                        if (!checkApplicableSignature(node, args, candidate, relation, excludeArgument, false)) {\n                            break;\n                        }\n                        var index = excludeArgument ? ts.indexOf(excludeArgument, true) : -1;\n                        if (index < 0) {\n                            return candidate;\n                        }\n                        excludeArgument[index] = false;\n                    }\n                    // A post-mortem of this iteration of the loop. The signature was not applicable,\n                    // so we want to track it as a candidate for reporting an error. If the candidate\n                    // had no type parameters, or had no issues related to type arguments, we can\n                    // report an error based on the arguments. If there was an issue with type\n                    // arguments, then we can only report an error based on the type arguments.\n                    if (originalCandidate.typeParameters) {\n                        var instantiatedCandidate = candidate;\n                        if (typeArgumentsAreValid) {\n                            candidateForArgumentError = instantiatedCandidate;\n                        }\n                        else {\n                            candidateForTypeArgumentError = originalCandidate;\n                            if (!typeArguments) {\n                                resultOfFailedInference = inferenceResult;\n                            }\n                        }\n                    }\n                    else {\n                        ts.Debug.assert(originalCandidate === candidate);\n                        candidateForArgumentError = originalCandidate;\n                    }\n                }\n                return undefined;\n            }\n            // The candidate list orders groups in reverse, but within a group signatures are kept in declaration order\n            // A nit here is that we reorder only signatures that belong to the same symbol,\n            // so order how inherited signatures are processed is still preserved.\n            // interface A { (x: string): void }\n            // interface B extends A { (x: 'foo'): string }\n            // var b: B;\n            // b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]\n            function collectCandidates() {\n                var result = candidates;\n                var lastParent;\n                var lastSymbol;\n                var cutoffPos = 0;\n                var pos;\n                ts.Debug.assert(!result.length);\n                for (var i = 0; i < signatures.length; i++) {\n                    var signature = signatures[i];\n                    var symbol = signature.declaration && getSymbolOfNode(signature.declaration);\n                    var parent = signature.declaration && signature.declaration.parent;\n                    if (!lastSymbol || symbol === lastSymbol) {\n                        if (lastParent && parent === lastParent) {\n                            pos++;\n                        }\n                        else {\n                            lastParent = parent;\n                            pos = cutoffPos;\n                        }\n                    }\n                    else {\n                        // current declaration belongs to a different symbol\n                        // set cutoffPos so re-orderings in the future won't change result set from 0 to cutoffPos\n                        pos = cutoffPos = result.length;\n                        lastParent = parent;\n                    }\n                    lastSymbol = symbol;\n                    for (var j = result.length; j > pos; j--) {\n                        result[j] = result[j - 1];\n                    }\n                    result[pos] = signature;\n                }\n            }\n        }\n        function resolveCallExpression(node, candidatesOutArray) {\n            if (node.expression.kind === 89 /* SuperKeyword */) {\n                var superType = checkSuperExpression(node.expression);\n                if (superType !== unknownType) {\n                    return resolveCall(node, getSignaturesOfType(superType, 1 /* Construct */), candidatesOutArray);\n                }\n                return resolveUntypedCall(node);\n            }\n            var funcType = checkExpression(node.expression);\n            var apparentType = getApparentType(funcType);\n            if (apparentType === unknownType) {\n                // Another error has already been reported\n                return resolveErrorCall(node);\n            }\n            // Technically, this signatures list may be incomplete. We are taking the apparent type,\n            // but we are not including call signatures that may have been added to the Object or\n            // Function interface, since they have none by default. This is a bit of a leap of faith\n            // that the user will not add any.\n            var callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);\n            var constructSignatures = getSignaturesOfType(apparentType, 1 /* Construct */);\n            // TS 1.0 spec: 4.12\n            // If FuncExpr is of type Any, or of an object type that has no call or construct signatures\n            // but is a subtype of the Function interface, the call is an untyped function call. In an\n            // untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual\n            // types are provided for the argument expressions, and the result is always of type Any.\n            // We exclude union types because we may have a union of function types that happen to have\n            // no common signatures.\n            if (funcType === anyType || (!callSignatures.length && !constructSignatures.length && !(funcType.flags & 16384 /* Union */) && isTypeAssignableTo(funcType, globalFunctionType))) {\n                if (node.typeArguments) {\n                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);\n                }\n                return resolveUntypedCall(node);\n            }\n            // If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.\n            // TypeScript employs overload resolution in typed function calls in order to support functions\n            // with multiple call signatures.\n            if (!callSignatures.length) {\n                if (constructSignatures.length) {\n                    error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));\n                }\n                else {\n                    error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);\n                }\n                return resolveErrorCall(node);\n            }\n            return resolveCall(node, callSignatures, candidatesOutArray);\n        }\n        function resolveNewExpression(node, candidatesOutArray) {\n            var expressionType = checkExpression(node.expression);\n            // TS 1.0 spec: 4.11\n            // If ConstructExpr is of type Any, Args can be any argument\n            // list and the result of the operation is of type Any.\n            if (expressionType === anyType) {\n                if (node.typeArguments) {\n                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);\n                }\n                return resolveUntypedCall(node);\n            }\n            // If ConstructExpr's apparent type(section 3.8.1) is an object type with one or\n            // more construct signatures, the expression is processed in the same manner as a\n            // function call, but using the construct signatures as the initial set of candidate\n            // signatures for overload resolution.The result type of the function call becomes\n            // the result type of the operation.\n            expressionType = getApparentType(expressionType);\n            if (expressionType === unknownType) {\n                // Another error has already been reported\n                return resolveErrorCall(node);\n            }\n            // Technically, this signatures list may be incomplete. We are taking the apparent type,\n            // but we are not including construct signatures that may have been added to the Object or\n            // Function interface, since they have none by default. This is a bit of a leap of faith\n            // that the user will not add any.\n            var constructSignatures = getSignaturesOfType(expressionType, 1 /* Construct */);\n            if (constructSignatures.length) {\n                return resolveCall(node, constructSignatures, candidatesOutArray);\n            }\n            // If ConstructExpr's apparent type is an object type with no construct signatures but\n            // one or more call signatures, the expression is processed as a function call. A compile-time\n            // error occurs if the result of the function call is not Void. The type of the result of the\n            // operation is Any.\n            var callSignatures = getSignaturesOfType(expressionType, 0 /* Call */);\n            if (callSignatures.length) {\n                var signature = resolveCall(node, callSignatures, candidatesOutArray);\n                if (getReturnTypeOfSignature(signature) !== voidType) {\n                    error(node, ts.Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);\n                }\n                return signature;\n            }\n            error(node, ts.Diagnostics.Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature);\n            return resolveErrorCall(node);\n        }\n        function resolveTaggedTemplateExpression(node, candidatesOutArray) {\n            var tagType = checkExpression(node.tag);\n            var apparentType = getApparentType(tagType);\n            if (apparentType === unknownType) {\n                // Another error has already been reported\n                return resolveErrorCall(node);\n            }\n            var callSignatures = getSignaturesOfType(apparentType, 0 /* Call */);\n            if (tagType === anyType || (!callSignatures.length && !(tagType.flags & 16384 /* Union */) && isTypeAssignableTo(tagType, globalFunctionType))) {\n                return resolveUntypedCall(node);\n            }\n            if (!callSignatures.length) {\n                error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature);\n                return resolveErrorCall(node);\n            }\n            return resolveCall(node, callSignatures, candidatesOutArray);\n        }\n        // candidatesOutArray is passed by signature help in the language service, and collectCandidates\n        // must fill it up with the appropriate candidate signatures\n        function getResolvedSignature(node, candidatesOutArray) {\n            var links = getNodeLinks(node);\n            // If getResolvedSignature has already been called, we will have cached the resolvedSignature.\n            // However, it is possible that either candidatesOutArray was not passed in the first time,\n            // or that a different candidatesOutArray was passed in. Therefore, we need to redo the work\n            // to correctly fill the candidatesOutArray.\n            if (!links.resolvedSignature || candidatesOutArray) {\n                links.resolvedSignature = anySignature;\n                if (node.kind === 145 /* CallExpression */) {\n                    links.resolvedSignature = resolveCallExpression(node, candidatesOutArray);\n                }\n                else if (node.kind === 146 /* NewExpression */) {\n                    links.resolvedSignature = resolveNewExpression(node, candidatesOutArray);\n                }\n                else if (node.kind === 147 /* TaggedTemplateExpression */) {\n                    links.resolvedSignature = resolveTaggedTemplateExpression(node, candidatesOutArray);\n                }\n                else {\n                    ts.Debug.fail(\"Branch in 'getResolvedSignature' should be unreachable.\");\n                }\n            }\n            return links.resolvedSignature;\n        }\n        function checkCallExpression(node) {\n            var signature = getResolvedSignature(node);\n            if (node.expression.kind === 89 /* SuperKeyword */) {\n                return voidType;\n            }\n            if (node.kind === 146 /* NewExpression */) {\n                var declaration = signature.declaration;\n                if (declaration && declaration.kind !== 126 /* Constructor */ && declaration.kind !== 130 /* ConstructSignature */ && declaration.kind !== 134 /* ConstructorType */) {\n                    // When resolved signature is a call signature (and not a construct signature) the result type is any\n                    if (compilerOptions.noImplicitAny) {\n                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);\n                    }\n                    return anyType;\n                }\n            }\n            return getReturnTypeOfSignature(signature);\n        }\n        function checkTaggedTemplateExpression(node) {\n            return getReturnTypeOfSignature(getResolvedSignature(node));\n        }\n        function checkTypeAssertion(node) {\n            var exprType = checkExpression(node.expression);\n            var targetType = getTypeFromTypeNode(node.type);\n            if (fullTypeCheck && targetType !== unknownType) {\n                var widenedType = getWidenedType(exprType, true);\n                if (!(isTypeAssignableTo(targetType, widenedType))) {\n                    checkTypeAssignableTo(exprType, targetType, node, ts.Diagnostics.Neither_type_0_nor_type_1_is_assignable_to_the_other);\n                }\n            }\n            return targetType;\n        }\n        function getTypeAtPosition(signature, pos) {\n            return signature.hasRestParameter ? pos < signature.parameters.length - 1 ? getTypeOfSymbol(signature.parameters[pos]) : getRestTypeOfSignature(signature) : pos < signature.parameters.length ? getTypeOfSymbol(signature.parameters[pos]) : anyType;\n        }\n        function assignContextualParameterTypes(signature, context, mapper) {\n            var len = signature.parameters.length - (signature.hasRestParameter ? 1 : 0);\n            for (var i = 0; i < len; i++) {\n                var parameter = signature.parameters[i];\n                var links = getSymbolLinks(parameter);\n                links.type = instantiateType(getTypeAtPosition(context, i), mapper);\n            }\n            if (signature.hasRestParameter && context.hasRestParameter && signature.parameters.length >= context.parameters.length) {\n                var parameter = signature.parameters[signature.parameters.length - 1];\n                var links = getSymbolLinks(parameter);\n                links.type = instantiateType(getTypeOfSymbol(context.parameters[context.parameters.length - 1]), mapper);\n            }\n        }\n        function getReturnTypeFromBody(func, contextualMapper) {\n            var contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);\n            if (func.body.kind !== 163 /* Block */) {\n                var unwidenedType = checkAndMarkExpression(func.body, contextualMapper);\n                var widenedType = getWidenedType(unwidenedType);\n                if (fullTypeCheck && compilerOptions.noImplicitAny && !contextualSignature && widenedType !== unwidenedType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {\n                    error(func, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeToString(widenedType));\n                }\n                return widenedType;\n            }\n            // Aggregate the types of expressions within all the return statements.\n            var types = checkAndAggregateReturnExpressionTypes(func.body, contextualMapper);\n            // Try to return the best common type if we have any return expressions.\n            if (types.length > 0) {\n                // When return statements are contextually typed we allow the return type to be a union type. Otherwise we require the\n                // return expressions to have a best common supertype.\n                var commonType = contextualSignature ? getUnionType(types) : getCommonSupertype(types);\n                if (!commonType) {\n                    error(func, ts.Diagnostics.No_best_common_type_exists_among_return_expressions);\n                    return unknownType;\n                }\n                var widenedType = getWidenedType(commonType);\n                // Check and report for noImplicitAny if the best common type implicitly gets widened to an 'any'/arrays-of-'any' type.\n                if (fullTypeCheck && compilerOptions.noImplicitAny && !contextualSignature && widenedType !== commonType && getInnermostTypeOfNestedArrayTypes(widenedType) === anyType) {\n                    var typeName = typeToString(widenedType);\n                    if (func.name) {\n                        error(func, ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, ts.declarationNameToString(func.name), typeName);\n                    }\n                    else {\n                        error(func, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);\n                    }\n                }\n                return widenedType;\n            }\n            return voidType;\n        }\n        /// Returns a set of types relating to every return expression relating to a function block.\n        function checkAndAggregateReturnExpressionTypes(body, contextualMapper) {\n            var aggregatedTypes = [];\n            ts.forEachReturnStatement(body, function (returnStatement) {\n                var expr = returnStatement.expression;\n                if (expr) {\n                    var type = checkAndMarkExpression(expr, contextualMapper);\n                    if (!ts.contains(aggregatedTypes, type)) {\n                        aggregatedTypes.push(type);\n                    }\n                }\n            });\n            return aggregatedTypes;\n        }\n        function bodyContainsAReturnStatement(funcBody) {\n            return ts.forEachReturnStatement(funcBody, function (returnStatement) {\n                return true;\n            });\n        }\n        function bodyContainsSingleThrowStatement(body) {\n            return (body.statements.length === 1) && (body.statements[0].kind === 178 /* ThrowStatement */);\n        }\n        // TypeScript Specification 1.0 (6.3) - July 2014\n        // An explicitly typed function whose return type isn't the Void or the Any type\n        // must have at least one return statement somewhere in its body.\n        // An exception to this rule is if the function implementation consists of a single 'throw' statement.\n        function checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(func, returnType) {\n            if (!fullTypeCheck) {\n                return;\n            }\n            // Functions that return 'void' or 'any' don't need any return expressions.\n            if (returnType === voidType || returnType === anyType) {\n                return;\n            }\n            // If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.\n            if (!func.body || func.body.kind !== 163 /* Block */) {\n                return;\n            }\n            var bodyBlock = func.body;\n            // Ensure the body has at least one return expression.\n            if (bodyContainsAReturnStatement(bodyBlock)) {\n                return;\n            }\n            // If there are no return expressions, then we need to check if\n            // the function body consists solely of a throw statement;\n            // this is to make an exception for unimplemented functions.\n            if (bodyContainsSingleThrowStatement(bodyBlock)) {\n                return;\n            }\n            // This function does not conform to the specification.\n            error(func.type, ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_or_consist_of_a_single_throw_statement);\n        }\n        function checkFunctionExpressionOrObjectLiteralMethod(node, contextualMapper) {\n            ts.Debug.assert(node.kind !== 125 /* Method */ || ts.isObjectLiteralMethod(node));\n            // The identityMapper object is used to indicate that function expressions are wildcards\n            if (contextualMapper === identityMapper) {\n                return anyFunctionType;\n            }\n            var links = getNodeLinks(node);\n            var type = getTypeOfSymbol(node.symbol);\n            // Check if function expression is contextually typed and assign parameter types if so\n            if (!(links.flags & 64 /* ContextChecked */)) {\n                var contextualSignature = getContextualSignature(node);\n                // If a type check is started at a function expression that is an argument of a function call, obtaining the\n                // contextual type may recursively get back to here during overload resolution of the call. If so, we will have\n                // already assigned contextual types.\n                if (!(links.flags & 64 /* ContextChecked */)) {\n                    links.flags |= 64 /* ContextChecked */;\n                    if (contextualSignature) {\n                        var signature = getSignaturesOfType(type, 0 /* Call */)[0];\n                        if (isContextSensitive(node)) {\n                            assignContextualParameterTypes(signature, contextualSignature, contextualMapper || identityMapper);\n                        }\n                        if (!node.type) {\n                            signature.resolvedReturnType = resolvingType;\n                            var returnType = getReturnTypeFromBody(node, contextualMapper);\n                            if (signature.resolvedReturnType === resolvingType) {\n                                signature.resolvedReturnType = returnType;\n                            }\n                        }\n                    }\n                    checkSignatureDeclaration(node);\n                }\n            }\n            if (fullTypeCheck && node.kind !== 125 /* Method */) {\n                checkCollisionWithCapturedSuperVariable(node, node.name);\n                checkCollisionWithCapturedThisVariable(node, node.name);\n            }\n            return type;\n        }\n        function checkFunctionExpressionOrObjectLiteralMethodBody(node) {\n            ts.Debug.assert(node.kind !== 125 /* Method */ || ts.isObjectLiteralMethod(node));\n            if (node.type) {\n                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));\n            }\n            if (node.body) {\n                if (node.body.kind === 163 /* Block */) {\n                    checkSourceElement(node.body);\n                }\n                else {\n                    var exprType = checkExpression(node.body);\n                    if (node.type) {\n                        checkTypeAssignableTo(exprType, getTypeFromTypeNode(node.type), node.body, undefined);\n                    }\n                    checkFunctionExpressionBodies(node.body);\n                }\n            }\n        }\n        function checkArithmeticOperandType(operand, type, diagnostic) {\n            if (!(type.flags & (1 /* Any */ | 132 /* NumberLike */))) {\n                error(operand, diagnostic);\n                return false;\n            }\n            return true;\n        }\n        function checkReferenceExpression(n, invalidReferenceMessage, constantVarianleMessage) {\n            function findSymbol(n) {\n                var symbol = getNodeLinks(n).resolvedSymbol;\n                // Because we got the symbol from the resolvedSymbol property, it might be of kind\n                // SymbolFlags.ExportValue. In this case it is necessary to get the actual export\n                // symbol, which will have the correct flags set on it.\n                return symbol && getExportSymbolOfValueSymbolIfExported(symbol);\n            }\n            function isReferenceOrErrorExpression(n) {\n                switch (n.kind) {\n                    case 63 /* Identifier */:\n                        var symbol = findSymbol(n);\n                        // TypeScript 1.0 spec (April 2014): 4.3\n                        // An identifier expression that references a variable or parameter is classified as a reference. \n                        // An identifier expression that references any other kind of entity is classified as a value(and therefore cannot be the target of an assignment).\n                        return !symbol || symbol === unknownSymbol || symbol === argumentsSymbol || (symbol.flags & 3 /* Variable */) !== 0;\n                    case 143 /* PropertyAccessExpression */:\n                        var symbol = findSymbol(n);\n                        // TypeScript 1.0 spec (April 2014): 4.10\n                        // A property access expression is always classified as a reference.\n                        // NOTE (not in spec): assignment to enum members should not be allowed\n                        return !symbol || symbol === unknownSymbol || (symbol.flags & ~8 /* EnumMember */) !== 0;\n                    case 144 /* ElementAccessExpression */:\n                        //  old compiler doesn't check indexed assess\n                        return true;\n                    case 149 /* ParenthesizedExpression */:\n                        return isReferenceOrErrorExpression(n.expression);\n                    default:\n                        return false;\n                }\n            }\n            function isConstVariableReference(n) {\n                switch (n.kind) {\n                    case 63 /* Identifier */:\n                    case 143 /* PropertyAccessExpression */:\n                        var symbol = findSymbol(n);\n                        return symbol && (symbol.flags & 3 /* Variable */) !== 0 && (getDeclarationFlagsFromSymbol(symbol) & 4096 /* Const */) !== 0;\n                    case 144 /* ElementAccessExpression */:\n                        var index = n.argumentExpression;\n                        var symbol = findSymbol(n.expression);\n                        if (symbol && index && index.kind === 7 /* StringLiteral */) {\n                            var name = index.text;\n                            var prop = getPropertyOfType(getTypeOfSymbol(symbol), name);\n                            return prop && (prop.flags & 3 /* Variable */) !== 0 && (getDeclarationFlagsFromSymbol(prop) & 4096 /* Const */) !== 0;\n                        }\n                        return false;\n                    case 149 /* ParenthesizedExpression */:\n                        return isConstVariableReference(n.expression);\n                    default:\n                        return false;\n                }\n            }\n            if (!isReferenceOrErrorExpression(n)) {\n                error(n, invalidReferenceMessage);\n                return false;\n            }\n            if (isConstVariableReference(n)) {\n                error(n, constantVarianleMessage);\n                return false;\n            }\n            return true;\n        }\n        function checkDeleteExpression(node) {\n            var operandType = checkExpression(node.expression);\n            return booleanType;\n        }\n        function checkTypeOfExpression(node) {\n            var operandType = checkExpression(node.expression);\n            return stringType;\n        }\n        function checkVoidExpression(node) {\n            var operandType = checkExpression(node.expression);\n            return undefinedType;\n        }\n        function checkPrefixUnaryExpression(node) {\n            var operandType = checkExpression(node.operand);\n            switch (node.operator) {\n                case 32 /* PlusToken */:\n                case 33 /* MinusToken */:\n                case 46 /* TildeToken */:\n                    return numberType;\n                case 45 /* ExclamationToken */:\n                    return booleanType;\n                case 37 /* PlusPlusToken */:\n                case 38 /* MinusMinusToken */:\n                    var ok = checkArithmeticOperandType(node.operand, operandType, ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);\n                    if (ok) {\n                        // run check only if former checks succeeded to avoid reporting cascading errors\n                        checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant);\n                    }\n                    return numberType;\n            }\n            return unknownType;\n        }\n        function checkPostfixUnaryExpression(node) {\n            var operandType = checkExpression(node.operand);\n            var ok = checkArithmeticOperandType(node.operand, operandType, ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);\n            if (ok) {\n                // run check only if former checks succeeded to avoid reporting cascading errors\n                checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_cannot_be_a_constant);\n            }\n            return numberType;\n        }\n        // Return true if type an object type, a type parameter, or a union type composed of only those kinds of types\n        function isStructuredType(type) {\n            if (type.flags & 16384 /* Union */) {\n                return !ts.forEach(type.types, function (t) { return !isStructuredType(t); });\n            }\n            return (type.flags & (48128 /* ObjectType */ | 512 /* TypeParameter */)) !== 0;\n        }\n        function isConstEnumObjectType(type) {\n            return type.flags & (48128 /* ObjectType */ | 32768 /* Anonymous */) && type.symbol && isConstEnumSymbol(type.symbol);\n        }\n        function isConstEnumSymbol(symbol) {\n            return (symbol.flags & 128 /* ConstEnum */) !== 0;\n        }\n        function checkInstanceOfExpression(node, leftType, rightType) {\n            // TypeScript 1.0 spec (April 2014): 4.15.4\n            // The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,\n            // and the right operand to be of type Any or a subtype of the 'Function' interface type. \n            // The result is always of the Boolean primitive type.\n            // NOTE: do not raise error if leftType is unknown as related error was already reported\n            if (!(leftType.flags & 1 /* Any */ || isStructuredType(leftType))) {\n                error(node.left, ts.Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);\n            }\n            // NOTE: do not raise error if right is unknown as related error was already reported\n            if (!(rightType.flags & 1 /* Any */ || isTypeSubtypeOf(rightType, globalFunctionType))) {\n                error(node.right, ts.Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);\n            }\n            return booleanType;\n        }\n        function checkInExpression(node, leftType, rightType) {\n            // TypeScript 1.0 spec (April 2014): 4.15.5\n            // The in operator requires the left operand to be of type Any, the String primitive type, or the Number primitive type,\n            // and the right operand to be of type Any, an object type, or a type parameter type.\n            // The result is always of the Boolean primitive type.\n            if (leftType !== anyType && leftType !== stringType && leftType !== numberType) {\n                error(node.left, ts.Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_types_any_string_or_number);\n            }\n            if (!(rightType.flags & 1 /* Any */ || isStructuredType(rightType))) {\n                error(node.right, ts.Diagnostics.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);\n            }\n            return booleanType;\n        }\n        function checkBinaryExpression(node, contextualMapper) {\n            var operator = node.operator;\n            var leftType = checkExpression(node.left, contextualMapper);\n            var rightType = checkExpression(node.right, contextualMapper);\n            switch (operator) {\n                case 34 /* AsteriskToken */:\n                case 54 /* AsteriskEqualsToken */:\n                case 35 /* SlashToken */:\n                case 55 /* SlashEqualsToken */:\n                case 36 /* PercentToken */:\n                case 56 /* PercentEqualsToken */:\n                case 33 /* MinusToken */:\n                case 53 /* MinusEqualsToken */:\n                case 39 /* LessThanLessThanToken */:\n                case 57 /* LessThanLessThanEqualsToken */:\n                case 40 /* GreaterThanGreaterThanToken */:\n                case 58 /* GreaterThanGreaterThanEqualsToken */:\n                case 41 /* GreaterThanGreaterThanGreaterThanToken */:\n                case 59 /* GreaterThanGreaterThanGreaterThanEqualsToken */:\n                case 43 /* BarToken */:\n                case 61 /* BarEqualsToken */:\n                case 44 /* CaretToken */:\n                case 62 /* CaretEqualsToken */:\n                case 42 /* AmpersandToken */:\n                case 60 /* AmpersandEqualsToken */:\n                    // TypeScript 1.0 spec (April 2014): 4.15.1\n                    // These operators require their operands to be of type Any, the Number primitive type,\n                    // or an enum type. Operands of an enum type are treated \n                    // as having the primitive type Number. If one operand is the null or undefined value,\n                    // it is treated as having the type of the other operand.\n                    // The result is always of the Number primitive type.\n                    if (leftType.flags & (32 /* Undefined */ | 64 /* Null */))\n                        leftType = rightType;\n                    if (rightType.flags & (32 /* Undefined */ | 64 /* Null */))\n                        rightType = leftType;\n                    var suggestedOperator;\n                    // if a user tries to apply a bitwise operator to 2 boolean operands \n                    // try and return them a helpful suggestion\n                    if ((leftType.flags & 8 /* Boolean */) && (rightType.flags & 8 /* Boolean */) && (suggestedOperator = getSuggestedBooleanOperator(node.operator)) !== undefined) {\n                        error(node, ts.Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, ts.tokenToString(node.operator), ts.tokenToString(suggestedOperator));\n                    }\n                    else {\n                        // otherwise just check each operand separately and report errors as normal \n                        var leftOk = checkArithmeticOperandType(node.left, leftType, ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);\n                        var rightOk = checkArithmeticOperandType(node.right, rightType, ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);\n                        if (leftOk && rightOk) {\n                            checkAssignmentOperator(numberType);\n                        }\n                    }\n                    return numberType;\n                case 32 /* PlusToken */:\n                case 52 /* PlusEqualsToken */:\n                    // TypeScript 1.0 spec (April 2014): 4.15.2\n                    // The binary + operator requires both operands to be of the Number primitive type or an enum type,\n                    // or at least one of the operands to be of type Any or the String primitive type.\n                    // If one operand is the null or undefined value, it is treated as having the type of the other operand.\n                    if (leftType.flags & (32 /* Undefined */ | 64 /* Null */))\n                        leftType = rightType;\n                    if (rightType.flags & (32 /* Undefined */ | 64 /* Null */))\n                        rightType = leftType;\n                    var resultType;\n                    if (leftType.flags & 132 /* NumberLike */ && rightType.flags & 132 /* NumberLike */) {\n                        // Operands of an enum type are treated as having the primitive type Number.\n                        // If both operands are of the Number primitive type, the result is of the Number primitive type.\n                        resultType = numberType;\n                    }\n                    else if (leftType.flags & 258 /* StringLike */ || rightType.flags & 258 /* StringLike */) {\n                        // If one or both operands are of the String primitive type, the result is of the String primitive type.\n                        resultType = stringType;\n                    }\n                    else if (leftType.flags & 1 /* Any */ || leftType === unknownType || rightType.flags & 1 /* Any */ || rightType === unknownType) {\n                        // Otherwise, the result is of type Any.\n                        // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.\n                        resultType = anyType;\n                    }\n                    if (!resultType) {\n                        reportOperatorError();\n                        return anyType;\n                    }\n                    if (operator === 52 /* PlusEqualsToken */) {\n                        checkAssignmentOperator(resultType);\n                    }\n                    return resultType;\n                case 27 /* EqualsEqualsToken */:\n                case 28 /* ExclamationEqualsToken */:\n                case 29 /* EqualsEqualsEqualsToken */:\n                case 30 /* ExclamationEqualsEqualsToken */:\n                case 23 /* LessThanToken */:\n                case 24 /* GreaterThanToken */:\n                case 25 /* LessThanEqualsToken */:\n                case 26 /* GreaterThanEqualsToken */:\n                    if (!isTypeAssignableTo(leftType, rightType) && !isTypeAssignableTo(rightType, leftType)) {\n                        reportOperatorError();\n                    }\n                    return booleanType;\n                case 85 /* InstanceOfKeyword */:\n                    return checkInstanceOfExpression(node, leftType, rightType);\n                case 84 /* InKeyword */:\n                    return checkInExpression(node, leftType, rightType);\n                case 47 /* AmpersandAmpersandToken */:\n                    return rightType;\n                case 48 /* BarBarToken */:\n                    return getUnionType([leftType, rightType]);\n                case 51 /* EqualsToken */:\n                    checkAssignmentOperator(rightType);\n                    return rightType;\n                case 22 /* CommaToken */:\n                    return rightType;\n            }\n            function getSuggestedBooleanOperator(operator) {\n                switch (operator) {\n                    case 43 /* BarToken */:\n                    case 61 /* BarEqualsToken */:\n                        return 48 /* BarBarToken */;\n                    case 44 /* CaretToken */:\n                    case 62 /* CaretEqualsToken */:\n                        return 30 /* ExclamationEqualsEqualsToken */;\n                    case 42 /* AmpersandToken */:\n                    case 60 /* AmpersandEqualsToken */:\n                        return 47 /* AmpersandAmpersandToken */;\n                    default:\n                        return undefined;\n                }\n            }\n            function checkAssignmentOperator(valueType) {\n                if (fullTypeCheck && operator >= 51 /* FirstAssignment */ && operator <= 62 /* LastAssignment */) {\n                    // TypeScript 1.0 spec (April 2014): 4.17\n                    // An assignment of the form\n                    //    VarExpr = ValueExpr\n                    // requires VarExpr to be classified as a reference\n                    // A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1) \n                    // and the type of the non - compound operation to be assignable to the type of VarExpr.\n                    var ok = checkReferenceExpression(node.left, ts.Diagnostics.Invalid_left_hand_side_of_assignment_expression, ts.Diagnostics.Left_hand_side_of_assignment_expression_cannot_be_a_constant);\n                    // Use default messages\n                    if (ok) {\n                        // to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported\n                        checkTypeAssignableTo(valueType, leftType, node.left, undefined);\n                    }\n                }\n            }\n            function reportOperatorError() {\n                error(node, ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, ts.tokenToString(node.operator), typeToString(leftType), typeToString(rightType));\n            }\n        }\n        function checkConditionalExpression(node, contextualMapper) {\n            checkExpression(node.condition);\n            var type1 = checkExpression(node.whenTrue, contextualMapper);\n            var type2 = checkExpression(node.whenFalse, contextualMapper);\n            return getUnionType([type1, type2]);\n        }\n        function checkTemplateExpression(node) {\n            // We just want to check each expressions, but we are unconcerned with\n            // the type of each expression, as any value may be coerced into a string.\n            // It is worth asking whether this is what we really want though.\n            // A place where we actually *are* concerned with the expressions' types are\n            // in tagged templates.\n            ts.forEach(node.templateSpans, function (templateSpan) {\n                checkExpression(templateSpan.expression);\n            });\n            return stringType;\n        }\n        function checkExpressionWithContextualType(node, contextualType, contextualMapper) {\n            var saveContextualType = node.contextualType;\n            node.contextualType = contextualType;\n            var result = checkExpression(node, contextualMapper);\n            node.contextualType = saveContextualType;\n            return result;\n        }\n        function checkAndMarkExpression(node, contextualMapper) {\n            var result = checkExpression(node, contextualMapper);\n            getNodeLinks(node).flags |= 1 /* TypeChecked */;\n            return result;\n        }\n        function checkObjectLiteralMethod(node, contextualMapper) {\n            var uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, contextualMapper);\n            return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, contextualMapper);\n        }\n        function instantiateTypeWithSingleGenericCallSignature(node, type, contextualMapper) {\n            if (contextualMapper && contextualMapper !== identityMapper) {\n                var signature = getSingleCallSignature(type);\n                if (signature && signature.typeParameters) {\n                    var contextualType = getContextualType(node);\n                    if (contextualType) {\n                        var contextualSignature = getSingleCallSignature(contextualType);\n                        if (contextualSignature && !contextualSignature.typeParameters) {\n                            return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper));\n                        }\n                    }\n                }\n            }\n            return type;\n        }\n        function checkExpression(node, contextualMapper) {\n            return checkExpressionOrQualifiedName(node, contextualMapper);\n        }\n        // Checks an expression and returns its type. The contextualMapper parameter serves two purposes: When\n        // contextualMapper is not undefined and not equal to the identityMapper function object it indicates that the\n        // expression is being inferentially typed (section 4.12.2 in spec) and provides the type mapper to use in\n        // conjunction with the generic contextual type. When contextualMapper is equal to the identityMapper function\n        // object, it serves as an indicator that all contained function and arrow expressions should be considered to\n        // have the wildcard function type; this form of type check is used during overload resolution to exclude\n        // contextually typed function and arrow expressions in the initial phase.\n        function checkExpressionOrQualifiedName(node, contextualMapper) {\n            var type;\n            if (node.kind == 120 /* QualifiedName */) {\n                type = checkQualifiedName(node);\n            }\n            else {\n                var uninstantiatedType = checkExpressionWorker(node, contextualMapper);\n                type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, contextualMapper);\n            }\n            if (isConstEnumObjectType(type)) {\n                // enum object type for const enums are only permitted in:\n                // - 'left' in property access \n                // - 'object' in indexed access\n                // - target in rhs of import statement\n                var ok = (node.parent.kind === 143 /* PropertyAccessExpression */ && node.parent.expression === node) || (node.parent.kind === 144 /* ElementAccessExpression */ && node.parent.expression === node) || ((node.kind === 63 /* Identifier */ || node.kind === 120 /* QualifiedName */) && isInRightSideOfImportOrExportAssignment(node));\n                if (!ok) {\n                    error(node, ts.Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment);\n                }\n            }\n            return type;\n        }\n        function checkExpressionWorker(node, contextualMapper) {\n            switch (node.kind) {\n                case 63 /* Identifier */:\n                    return checkIdentifier(node);\n                case 91 /* ThisKeyword */:\n                    return checkThisExpression(node);\n                case 89 /* SuperKeyword */:\n                    return checkSuperExpression(node);\n                case 87 /* NullKeyword */:\n                    return nullType;\n                case 93 /* TrueKeyword */:\n                case 78 /* FalseKeyword */:\n                    return booleanType;\n                case 6 /* NumericLiteral */:\n                    return numberType;\n                case 159 /* TemplateExpression */:\n                    return checkTemplateExpression(node);\n                case 7 /* StringLiteral */:\n                case 9 /* NoSubstitutionTemplateLiteral */:\n                    return stringType;\n                case 8 /* RegularExpressionLiteral */:\n                    return globalRegExpType;\n                case 141 /* ArrayLiteralExpression */:\n                    return checkArrayLiteral(node, contextualMapper);\n                case 142 /* ObjectLiteralExpression */:\n                    return checkObjectLiteral(node, contextualMapper);\n                case 143 /* PropertyAccessExpression */:\n                    return checkPropertyAccessExpression(node);\n                case 144 /* ElementAccessExpression */:\n                    return checkIndexedAccess(node);\n                case 145 /* CallExpression */:\n                case 146 /* NewExpression */:\n                    return checkCallExpression(node);\n                case 147 /* TaggedTemplateExpression */:\n                    return checkTaggedTemplateExpression(node);\n                case 148 /* TypeAssertionExpression */:\n                    return checkTypeAssertion(node);\n                case 149 /* ParenthesizedExpression */:\n                    return checkExpression(node.expression);\n                case 150 /* FunctionExpression */:\n                case 151 /* ArrowFunction */:\n                    return checkFunctionExpressionOrObjectLiteralMethod(node, contextualMapper);\n                case 153 /* TypeOfExpression */:\n                    return checkTypeOfExpression(node);\n                case 152 /* DeleteExpression */:\n                    return checkDeleteExpression(node);\n                case 154 /* VoidExpression */:\n                    return checkVoidExpression(node);\n                case 155 /* PrefixUnaryExpression */:\n                    return checkPrefixUnaryExpression(node);\n                case 156 /* PostfixUnaryExpression */:\n                    return checkPostfixUnaryExpression(node);\n                case 157 /* BinaryExpression */:\n                    return checkBinaryExpression(node, contextualMapper);\n                case 158 /* ConditionalExpression */:\n                    return checkConditionalExpression(node, contextualMapper);\n                case 161 /* OmittedExpression */:\n                    return undefinedType;\n            }\n            return unknownType;\n        }\n        // DECLARATION AND STATEMENT TYPE CHECKING\n        function checkTypeParameter(node) {\n            checkSourceElement(node.constraint);\n            if (fullTypeCheck) {\n                checkTypeParameterHasIllegalReferencesInConstraint(node);\n                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);\n            }\n            // TODO: Check multiple declarations are identical\n        }\n        function checkParameter(parameterDeclaration) {\n            checkVariableOrParameterDeclaration(parameterDeclaration);\n            if (fullTypeCheck) {\n                checkCollisionWithIndexVariableInGeneratedCode(parameterDeclaration, parameterDeclaration.name);\n                if (parameterDeclaration.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */) && !(parameterDeclaration.parent.kind === 126 /* Constructor */ && parameterDeclaration.parent.body)) {\n                    error(parameterDeclaration, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);\n                }\n                if (parameterDeclaration.dotDotDotToken) {\n                    if (!isArrayType(getTypeOfSymbol(parameterDeclaration.symbol))) {\n                        error(parameterDeclaration, ts.Diagnostics.A_rest_parameter_must_be_of_an_array_type);\n                    }\n                }\n                else {\n                    if (parameterDeclaration.initializer && !parameterDeclaration.parent.body) {\n                        error(parameterDeclaration, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);\n                    }\n                }\n            }\n            function checkReferencesInInitializer(n) {\n                if (n.kind === 63 /* Identifier */) {\n                    var referencedSymbol = getNodeLinks(n).resolvedSymbol;\n                    // check FunctionLikeDeclaration.locals (stores parameters\\function local variable) \n                    // if it contains entry with a specified name and if this entry matches the resolved symbol\n                    if (referencedSymbol && referencedSymbol !== unknownSymbol && getSymbol(parameterDeclaration.parent.locals, referencedSymbol.name, 107455 /* Value */) === referencedSymbol) {\n                        if (referencedSymbol.valueDeclaration.kind === 123 /* Parameter */) {\n                            if (referencedSymbol.valueDeclaration === parameterDeclaration) {\n                                error(n, ts.Diagnostics.Parameter_0_cannot_be_referenced_in_its_initializer, ts.declarationNameToString(parameterDeclaration.name));\n                                return;\n                            }\n                            var enclosingOrReferencedParameter = ts.forEach(parameterDeclaration.parent.parameters, function (p) { return p === parameterDeclaration || p === referencedSymbol.valueDeclaration ? p : undefined; });\n                            if (enclosingOrReferencedParameter === referencedSymbol.valueDeclaration) {\n                                // legal case - parameter initializer references some parameter strictly on left of current parameter declaration\n                                return;\n                            }\n                        }\n                        error(n, ts.Diagnostics.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, ts.declarationNameToString(parameterDeclaration.name), ts.declarationNameToString(n));\n                    }\n                }\n                else {\n                    ts.forEachChild(n, checkReferencesInInitializer);\n                }\n            }\n            if (parameterDeclaration.initializer) {\n                checkReferencesInInitializer(parameterDeclaration.initializer);\n            }\n        }\n        function checkSignatureDeclaration(node) {\n            checkTypeParameters(node.typeParameters);\n            ts.forEach(node.parameters, checkParameter);\n            if (node.type) {\n                checkSourceElement(node.type);\n            }\n            if (fullTypeCheck) {\n                checkCollisionWithArgumentsInGeneratedCode(node);\n                if (compilerOptions.noImplicitAny && !node.type) {\n                    switch (node.kind) {\n                        case 130 /* ConstructSignature */:\n                            error(node, ts.Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);\n                            break;\n                        case 129 /* CallSignature */:\n                            error(node, ts.Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);\n                            break;\n                    }\n                }\n            }\n            checkSpecializedSignatureDeclaration(node);\n        }\n        function checkTypeForDuplicateIndexSignatures(node) {\n            if (node.kind === 186 /* InterfaceDeclaration */) {\n                var nodeSymbol = getSymbolOfNode(node);\n                // in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration\n                // to prevent this run check only for the first declaration of a given kind\n                if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {\n                    return;\n                }\n            }\n            // TypeScript 1.0 spec (April 2014)\n            // 3.7.4: An object type can contain at most one string index signature and one numeric index signature.\n            // 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration\n            var indexSymbol = getIndexSymbol(getSymbolOfNode(node));\n            if (indexSymbol) {\n                var seenNumericIndexer = false;\n                var seenStringIndexer = false;\n                for (var i = 0, len = indexSymbol.declarations.length; i < len; ++i) {\n                    var declaration = indexSymbol.declarations[i];\n                    if (declaration.parameters.length == 1 && declaration.parameters[0].type) {\n                        switch (declaration.parameters[0].type.kind) {\n                            case 118 /* StringKeyword */:\n                                if (!seenStringIndexer) {\n                                    seenStringIndexer = true;\n                                }\n                                else {\n                                    error(declaration, ts.Diagnostics.Duplicate_string_index_signature);\n                                }\n                                break;\n                            case 116 /* NumberKeyword */:\n                                if (!seenNumericIndexer) {\n                                    seenNumericIndexer = true;\n                                }\n                                else {\n                                    error(declaration, ts.Diagnostics.Duplicate_number_index_signature);\n                                }\n                                break;\n                        }\n                    }\n                }\n            }\n        }\n        function checkPropertyDeclaration(node) {\n            if (fullTypeCheck) {\n                checkVariableOrParameterOrPropertyInFullTypeCheck(node);\n            }\n        }\n        function checkMethodDeclaration(node) {\n            checkFunctionLikeDeclaration(node);\n        }\n        function checkConstructorDeclaration(node) {\n            checkSignatureDeclaration(node);\n            checkSourceElement(node.body);\n            var symbol = getSymbolOfNode(node);\n            var firstDeclaration = ts.getDeclarationOfKind(symbol, node.kind);\n            // Only type check the symbol once\n            if (node === firstDeclaration) {\n                checkFunctionOrConstructorSymbol(symbol);\n            }\n            // exit early in the case of signature - super checks are not relevant to them\n            if (!node.body) {\n                return;\n            }\n            if (!fullTypeCheck) {\n                return;\n            }\n            function isSuperCallExpression(n) {\n                return n.kind === 145 /* CallExpression */ && n.expression.kind === 89 /* SuperKeyword */;\n            }\n            function containsSuperCall(n) {\n                if (isSuperCallExpression(n)) {\n                    return true;\n                }\n                switch (n.kind) {\n                    case 150 /* FunctionExpression */:\n                    case 184 /* FunctionDeclaration */:\n                    case 151 /* ArrowFunction */:\n                    case 142 /* ObjectLiteralExpression */: return false;\n                    default: return ts.forEachChild(n, containsSuperCall);\n                }\n            }\n            function markThisReferencesAsErrors(n) {\n                if (n.kind === 91 /* ThisKeyword */) {\n                    error(n, ts.Diagnostics.this_cannot_be_referenced_in_current_location);\n                }\n                else if (n.kind !== 150 /* FunctionExpression */ && n.kind !== 184 /* FunctionDeclaration */) {\n                    ts.forEachChild(n, markThisReferencesAsErrors);\n                }\n            }\n            function isInstancePropertyWithInitializer(n) {\n                return n.kind === 124 /* Property */ && !(n.flags & 128 /* Static */) && !!n.initializer;\n            }\n            // TS 1.0 spec (April 2014): 8.3.2\n            // Constructors of classes with no extends clause may not contain super calls, whereas \n            // constructors of derived classes must contain at least one super call somewhere in their function body.\n            if (ts.getClassBaseTypeNode(node.parent)) {\n                if (containsSuperCall(node.body)) {\n                    // The first statement in the body of a constructor must be a super call if both of the following are true:\n                    // - The containing class is a derived class.\n                    // - The constructor declares parameter properties \n                    //   or the containing class declares instance member variables with initializers.\n                    var superCallShouldBeFirst = ts.forEach(node.parent.members, isInstancePropertyWithInitializer) || ts.forEach(node.parameters, function (p) { return p.flags & (16 /* Public */ | 32 /* Private */ | 64 /* Protected */); });\n                    if (superCallShouldBeFirst) {\n                        var statements = node.body.statements;\n                        if (!statements.length || statements[0].kind !== 166 /* ExpressionStatement */ || !isSuperCallExpression(statements[0].expression)) {\n                            error(node, ts.Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties);\n                        }\n                        else {\n                            // In such a required super call, it is a compile-time error for argument expressions to reference this.\n                            markThisReferencesAsErrors(statements[0].expression);\n                        }\n                    }\n                }\n                else {\n                    error(node, ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);\n                }\n            }\n        }\n        function checkAccessorDeclaration(node) {\n            if (fullTypeCheck) {\n                if (node.kind === 127 /* GetAccessor */) {\n                    if (!ts.isInAmbientContext(node) && node.body && !(bodyContainsAReturnStatement(node.body) || bodyContainsSingleThrowStatement(node.body))) {\n                        error(node.name, ts.Diagnostics.A_get_accessor_must_return_a_value_or_consist_of_a_single_throw_statement);\n                    }\n                }\n                if (!ts.hasComputedNameButNotSymbol(node)) {\n                    // TypeScript 1.0 spec (April 2014): 8.4.3\n                    // Accessors for the same member name must specify the same accessibility.\n                    var otherKind = node.kind === 127 /* GetAccessor */ ? 128 /* SetAccessor */ : 127 /* GetAccessor */;\n                    var otherAccessor = ts.getDeclarationOfKind(node.symbol, otherKind);\n                    if (otherAccessor) {\n                        if (((node.flags & 112 /* AccessibilityModifier */) !== (otherAccessor.flags & 112 /* AccessibilityModifier */))) {\n                            error(node.name, ts.Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);\n                        }\n                        var currentAccessorType = getAnnotatedAccessorType(node);\n                        var otherAccessorType = getAnnotatedAccessorType(otherAccessor);\n                        // TypeScript 1.0 spec (April 2014): 4.5\n                        // If both accessors include type annotations, the specified types must be identical.\n                        if (currentAccessorType && otherAccessorType) {\n                            if (!isTypeIdenticalTo(currentAccessorType, otherAccessorType)) {\n                                error(node, ts.Diagnostics.get_and_set_accessor_must_have_the_same_type);\n                            }\n                        }\n                    }\n                    checkAndStoreTypeOfAccessors(getSymbolOfNode(node));\n                }\n            }\n            checkFunctionLikeDeclaration(node);\n        }\n        function checkTypeReference(node) {\n            var type = getTypeFromTypeReferenceNode(node);\n            if (type !== unknownType && node.typeArguments) {\n                // Do type argument local checks only if referenced type is successfully resolved\n                var len = node.typeArguments.length;\n                for (var i = 0; i < len; i++) {\n                    checkSourceElement(node.typeArguments[i]);\n                    var constraint = getConstraintOfTypeParameter(type.target.typeParameters[i]);\n                    if (fullTypeCheck && constraint) {\n                        var typeArgument = type.typeArguments[i];\n                        checkTypeAssignableTo(typeArgument, constraint, node, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);\n                    }\n                }\n            }\n        }\n        function checkTypeQuery(node) {\n            getTypeFromTypeQueryNode(node);\n        }\n        function checkTypeLiteral(node) {\n            ts.forEach(node.members, checkSourceElement);\n            if (fullTypeCheck) {\n                var type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);\n                checkIndexConstraints(type);\n                checkTypeForDuplicateIndexSignatures(node);\n            }\n        }\n        function checkArrayType(node) {\n            checkSourceElement(node.elementType);\n        }\n        function checkTupleType(node) {\n            ts.forEach(node.elementTypes, checkSourceElement);\n        }\n        function checkUnionType(node) {\n            ts.forEach(node.types, checkSourceElement);\n        }\n        function isPrivateWithinAmbient(node) {\n            return (node.flags & 32 /* Private */) && ts.isInAmbientContext(node);\n        }\n        function checkSpecializedSignatureDeclaration(signatureDeclarationNode) {\n            if (!fullTypeCheck) {\n                return;\n            }\n            var signature = getSignatureFromDeclaration(signatureDeclarationNode);\n            if (!signature.hasStringLiterals) {\n                return;\n            }\n            // TypeScript 1.0 spec (April 2014): 3.7.2.2\n            // Specialized signatures are not permitted in conjunction with a function body\n            if (signatureDeclarationNode.body) {\n                error(signatureDeclarationNode, ts.Diagnostics.A_signature_with_an_implementation_cannot_use_a_string_literal_type);\n                return;\n            }\n            // TypeScript 1.0 spec (April 2014): 3.7.2.4\n            // Every specialized call or construct signature in an object type must be assignable\n            // to at least one non-specialized call or construct signature in the same object type\n            var signaturesToCheck;\n            // Unnamed (call\\construct) signatures in interfaces are inherited and not shadowed so examining just node symbol won't give complete answer.\n            // Use declaring type to obtain full list of signatures.\n            if (!signatureDeclarationNode.name && signatureDeclarationNode.parent && signatureDeclarationNode.parent.kind === 186 /* InterfaceDeclaration */) {\n                ts.Debug.assert(signatureDeclarationNode.kind === 129 /* CallSignature */ || signatureDeclarationNode.kind === 130 /* ConstructSignature */);\n                var signatureKind = signatureDeclarationNode.kind === 129 /* CallSignature */ ? 0 /* Call */ : 1 /* Construct */;\n                var containingSymbol = getSymbolOfNode(signatureDeclarationNode.parent);\n                var containingType = getDeclaredTypeOfSymbol(containingSymbol);\n                signaturesToCheck = getSignaturesOfType(containingType, signatureKind);\n            }\n            else {\n                signaturesToCheck = getSignaturesOfSymbol(getSymbolOfNode(signatureDeclarationNode));\n            }\n            for (var i = 0; i < signaturesToCheck.length; i++) {\n                var otherSignature = signaturesToCheck[i];\n                if (!otherSignature.hasStringLiterals && isSignatureAssignableTo(signature, otherSignature)) {\n                    return;\n                }\n            }\n            error(signatureDeclarationNode, ts.Diagnostics.Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature);\n        }\n        function getEffectiveDeclarationFlags(n, flagsToCheck) {\n            var flags = n.flags;\n            if (n.parent.kind !== 186 /* InterfaceDeclaration */ && ts.isInAmbientContext(n)) {\n                if (!(flags & 2 /* Ambient */)) {\n                    // It is nested in an ambient context, which means it is automatically exported\n                    flags |= 1 /* Export */;\n                }\n                flags |= 2 /* Ambient */;\n            }\n            return flags & flagsToCheck;\n        }\n        function checkFunctionOrConstructorSymbol(symbol) {\n            if (!fullTypeCheck) {\n                return;\n            }\n            function getCanonicalOverload(overloads, implementation) {\n                // Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration\n                // Error on all deviations from this canonical set of flags\n                // The caveat is that if some overloads are defined in lib.d.ts, we don't want to\n                // report the errors on those. To achieve this, we will say that the implementation is\n                // the canonical signature only if it is in the same container as the first overload\n                var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;\n                return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];\n            }\n            function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck, someOverloadFlags, allOverloadFlags) {\n                // Error if some overloads have a flag that is not shared by all overloads. To find the\n                // deviations, we XOR someOverloadFlags with allOverloadFlags\n                var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;\n                if (someButNotAllOverloadFlags !== 0) {\n                    var canonicalFlags = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck);\n                    ts.forEach(overloads, function (o) {\n                        var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;\n                        if (deviation & 1 /* Export */) {\n                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_exported_or_not_exported);\n                        }\n                        else if (deviation & 2 /* Ambient */) {\n                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);\n                        }\n                        else if (deviation & (32 /* Private */ | 64 /* Protected */)) {\n                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);\n                        }\n                    });\n                }\n            }\n            function checkQuestionTokenAgreementBetweenOverloads(overloads, implementation, someHaveQuestionToken, allHaveQuestionToken) {\n                if (someHaveQuestionToken !== allHaveQuestionToken) {\n                    var canonicalHasQuestionToken = ts.hasQuestionToken(getCanonicalOverload(overloads, implementation));\n                    ts.forEach(overloads, function (o) {\n                        var deviation = ts.hasQuestionToken(o) !== canonicalHasQuestionToken;\n                        if (deviation) {\n                            error(o.name, ts.Diagnostics.Overload_signatures_must_all_be_optional_or_required);\n                        }\n                    });\n                }\n            }\n            var flagsToCheck = 1 /* Export */ | 2 /* Ambient */ | 32 /* Private */ | 64 /* Protected */;\n            var someNodeFlags = 0;\n            var allNodeFlags = flagsToCheck;\n            var someHaveQuestionToken = false;\n            var allHaveQuestionToken = true;\n            var hasOverloads = false;\n            var bodyDeclaration;\n            var lastSeenNonAmbientDeclaration;\n            var previousDeclaration;\n            var declarations = symbol.declarations;\n            var isConstructor = (symbol.flags & 16384 /* Constructor */) !== 0;\n            function reportImplementationExpectedError(node) {\n                if (node.name && ts.getFullWidth(node.name) === 0) {\n                    return;\n                }\n                var seen = false;\n                var subsequentNode = ts.forEachChild(node.parent, function (c) {\n                    if (seen) {\n                        return c;\n                    }\n                    else {\n                        seen = c === node;\n                    }\n                });\n                if (subsequentNode) {\n                    if (subsequentNode.kind === node.kind) {\n                        var errorNode = subsequentNode.name || subsequentNode;\n                        // TODO(jfreeman): These are methods, so handle computed name case\n                        if (node.name && subsequentNode.name && node.name.text === subsequentNode.name.text) {\n                            // the only situation when this is possible (same kind\\same name but different symbol) - mixed static and instance class members\n                            ts.Debug.assert(node.kind === 125 /* Method */);\n                            ts.Debug.assert((node.flags & 128 /* Static */) !== (subsequentNode.flags & 128 /* Static */));\n                            var diagnostic = node.flags & 128 /* Static */ ? ts.Diagnostics.Function_overload_must_be_static : ts.Diagnostics.Function_overload_must_not_be_static;\n                            error(errorNode, diagnostic);\n                            return;\n                        }\n                        else if (subsequentNode.body) {\n                            error(errorNode, ts.Diagnostics.Function_implementation_name_must_be_0, ts.declarationNameToString(node.name));\n                            return;\n                        }\n                    }\n                }\n                var errorNode = node.name || node;\n                if (isConstructor) {\n                    error(errorNode, ts.Diagnostics.Constructor_implementation_is_missing);\n                }\n                else {\n                    error(errorNode, ts.Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);\n                }\n            }\n            // when checking exported function declarations across modules check only duplicate implementations\n            // names and consistency of modifiers are verified when we check local symbol\n            var isExportSymbolInsideModule = symbol.parent && symbol.parent.flags & 1536 /* Module */;\n            var duplicateFunctionDeclaration = false;\n            var multipleConstructorImplementation = false;\n            for (var i = 0; i < declarations.length; i++) {\n                var node = declarations[i];\n                var inAmbientContext = ts.isInAmbientContext(node);\n                var inAmbientContextOrInterface = node.parent.kind === 186 /* InterfaceDeclaration */ || node.parent.kind === 136 /* TypeLiteral */ || inAmbientContext;\n                if (inAmbientContextOrInterface) {\n                    // check if declarations are consecutive only if they are non-ambient\n                    // 1. ambient declarations can be interleaved\n                    // i.e. this is legal\n                    //     declare function foo();\n                    //     declare function bar();\n                    //     declare function foo();\n                    // 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one\n                    previousDeclaration = undefined;\n                }\n                if (node.kind === 184 /* FunctionDeclaration */ || node.kind === 125 /* Method */ || node.kind === 126 /* Constructor */) {\n                    var currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);\n                    someNodeFlags |= currentNodeFlags;\n                    allNodeFlags &= currentNodeFlags;\n                    someHaveQuestionToken = someHaveQuestionToken || ts.hasQuestionToken(node);\n                    allHaveQuestionToken = allHaveQuestionToken && ts.hasQuestionToken(node);\n                    if (node.body && bodyDeclaration) {\n                        if (isConstructor) {\n                            multipleConstructorImplementation = true;\n                        }\n                        else {\n                            duplicateFunctionDeclaration = true;\n                        }\n                    }\n                    else if (!isExportSymbolInsideModule && previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {\n                        reportImplementationExpectedError(previousDeclaration);\n                    }\n                    if (node.body) {\n                        if (!bodyDeclaration) {\n                            bodyDeclaration = node;\n                        }\n                    }\n                    else {\n                        hasOverloads = true;\n                    }\n                    previousDeclaration = node;\n                    if (!inAmbientContextOrInterface) {\n                        lastSeenNonAmbientDeclaration = node;\n                    }\n                }\n            }\n            if (multipleConstructorImplementation) {\n                ts.forEach(declarations, function (declaration) {\n                    error(declaration, ts.Diagnostics.Multiple_constructor_implementations_are_not_allowed);\n                });\n            }\n            if (duplicateFunctionDeclaration) {\n                ts.forEach(declarations, function (declaration) {\n                    error(declaration.name, ts.Diagnostics.Duplicate_function_implementation);\n                });\n            }\n            if (!isExportSymbolInsideModule && lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body) {\n                reportImplementationExpectedError(lastSeenNonAmbientDeclaration);\n            }\n            if (hasOverloads) {\n                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);\n                checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);\n                if (bodyDeclaration) {\n                    var signatures = getSignaturesOfSymbol(symbol);\n                    var bodySignature = getSignatureFromDeclaration(bodyDeclaration);\n                    // If the implementation signature has string literals, we will have reported an error in\n                    // checkSpecializedSignatureDeclaration\n                    if (!bodySignature.hasStringLiterals) {\n                        for (var i = 0, len = signatures.length; i < len; ++i) {\n                            if (!signatures[i].hasStringLiterals && !isSignatureAssignableTo(bodySignature, signatures[i])) {\n                                error(signatures[i].declaration, ts.Diagnostics.Overload_signature_is_not_compatible_with_function_implementation);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function checkExportsOnMergedDeclarations(node) {\n            if (!fullTypeCheck) {\n                return;\n            }\n            var symbol;\n            // Exports should be checked only if enclosing module contains both exported and non exported declarations.\n            // In case if all declarations are non-exported check is unnecessary.\n            // if localSymbol is defined on node then node itself is exported - check is required\n            var symbol = node.localSymbol;\n            if (!symbol) {\n                // local symbol is undefined => this declaration is non-exported.\n                // however symbol might contain other declarations that are exported\n                symbol = getSymbolOfNode(node);\n                if (!(symbol.flags & 29360128 /* Export */)) {\n                    // this is a pure local symbol (all declarations are non-exported) - no need to check anything\n                    return;\n                }\n            }\n            // run the check only for the first declaration in the list\n            if (ts.getDeclarationOfKind(symbol, node.kind) !== node) {\n                return;\n            }\n            // we use SymbolFlags.ExportValue, SymbolFlags.ExportType and SymbolFlags.ExportNamespace \n            // to denote disjoint declarationSpaces (without making new enum type).\n            var exportedDeclarationSpaces = 0;\n            var nonExportedDeclarationSpaces = 0;\n            ts.forEach(symbol.declarations, function (d) {\n                var declarationSpaces = getDeclarationSpaces(d);\n                if (getEffectiveDeclarationFlags(d, 1 /* Export */)) {\n                    exportedDeclarationSpaces |= declarationSpaces;\n                }\n                else {\n                    nonExportedDeclarationSpaces |= declarationSpaces;\n                }\n            });\n            var commonDeclarationSpace = exportedDeclarationSpaces & nonExportedDeclarationSpaces;\n            if (commonDeclarationSpace) {\n                // declaration spaces for exported and non-exported declarations intersect\n                ts.forEach(symbol.declarations, function (d) {\n                    if (getDeclarationSpaces(d) & commonDeclarationSpace) {\n                        error(d.name, ts.Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, ts.declarationNameToString(d.name));\n                    }\n                });\n            }\n            function getDeclarationSpaces(d) {\n                switch (d.kind) {\n                    case 186 /* InterfaceDeclaration */:\n                        return 8388608 /* ExportType */;\n                    case 189 /* ModuleDeclaration */:\n                        return d.name.kind === 7 /* StringLiteral */ || ts.getModuleInstanceState(d) !== 0 /* NonInstantiated */ ? 16777216 /* ExportNamespace */ | 4194304 /* ExportValue */ : 16777216 /* ExportNamespace */;\n                    case 185 /* ClassDeclaration */:\n                    case 188 /* EnumDeclaration */:\n                        return 8388608 /* ExportType */ | 4194304 /* ExportValue */;\n                    case 191 /* ImportDeclaration */:\n                        var result = 0;\n                        var target = resolveImport(getSymbolOfNode(d));\n                        ts.forEach(target.declarations, function (d) {\n                            result |= getDeclarationSpaces(d);\n                        });\n                        return result;\n                    default:\n                        return 4194304 /* ExportValue */;\n                }\n            }\n        }\n        function checkFunctionDeclaration(node) {\n            checkFunctionLikeDeclaration(node);\n            if (fullTypeCheck) {\n                checkCollisionWithCapturedSuperVariable(node, node.name);\n                checkCollisionWithCapturedThisVariable(node, node.name);\n                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);\n            }\n        }\n        function checkFunctionLikeDeclaration(node) {\n            checkSignatureDeclaration(node);\n            if (!ts.hasComputedNameButNotSymbol(node)) {\n                // first we want to check the local symbol that contain this declaration\n                // - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol\n                // - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode\n                var symbol = getSymbolOfNode(node);\n                var localSymbol = node.localSymbol || symbol;\n                var firstDeclaration = ts.getDeclarationOfKind(localSymbol, node.kind);\n                // Only type check the symbol once\n                if (node === firstDeclaration) {\n                    checkFunctionOrConstructorSymbol(localSymbol);\n                }\n                if (symbol.parent) {\n                    // run check once for the first declaration\n                    if (ts.getDeclarationOfKind(symbol, node.kind) === node) {\n                        // run check on export symbol to check that modifiers agree across all exported declarations\n                        checkFunctionOrConstructorSymbol(symbol);\n                    }\n                }\n            }\n            checkSourceElement(node.body);\n            if (node.type && !isAccessor(node.kind)) {\n                checkIfNonVoidFunctionHasReturnExpressionsOrSingleThrowStatment(node, getTypeFromTypeNode(node.type));\n            }\n            // If there is no body and no explicit return type, then report an error.\n            if (fullTypeCheck && compilerOptions.noImplicitAny && !node.body && !node.type) {\n                // Ignore privates within ambient contexts; they exist purely for documentative purposes to avoid name clashing.\n                // (e.g. privates within .d.ts files do not expose type information)\n                if (!isPrivateWithinAmbient(node)) {\n                    var typeName = typeToString(anyType);\n                    if (node.name) {\n                        error(node, ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type, ts.declarationNameToString(node.name), typeName);\n                    }\n                    else {\n                        error(node, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeName);\n                    }\n                }\n            }\n        }\n        function checkBlock(node) {\n            ts.forEach(node.statements, checkSourceElement);\n            if (ts.isFunctionBlock(node) || node.kind === 190 /* ModuleBlock */) {\n                checkFunctionExpressionBodies(node);\n            }\n        }\n        function checkCollisionWithArgumentsInGeneratedCode(node) {\n            // no rest parameters \\ declaration context \\ overload - no codegen impact\n            if (!ts.hasRestParameters(node) || ts.isInAmbientContext(node) || !node.body) {\n                return;\n            }\n            ts.forEach(node.parameters, function (p) {\n                if (p.name && p.name.text === argumentsSymbol.name) {\n                    error(p, ts.Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);\n                }\n            });\n        }\n        function checkCollisionWithIndexVariableInGeneratedCode(node, name) {\n            if (!(name && name.text === \"_i\")) {\n                return;\n            }\n            if (node.kind === 123 /* Parameter */) {\n                // report error if parameter has name '_i' when:\n                // - function has implementation (not a signature)\n                // - function has rest parameters\n                // - context is not ambient (otherwise no codegen impact)\n                if (node.parent.body && ts.hasRestParameters(node.parent) && !ts.isInAmbientContext(node)) {\n                    error(node, ts.Diagnostics.Duplicate_identifier_i_Compiler_uses_i_to_initialize_rest_parameter);\n                }\n                return;\n            }\n            var symbol = getNodeLinks(node).resolvedSymbol;\n            if (symbol === unknownSymbol) {\n                return;\n            }\n            // we would like to discover cases like one below:\n            //\n            // var _i = \"!\";\n            // function foo(...a) {\n            //    function bar() {\n            //        var x = { get baz() { return _i; } }\n            //    }\n            // }\n            // \n            // at runtime '_i' referenced in getter will be resolved to the generated index variable '_i' used to initialize rest parameters.\n            // legitimate case: when '_i' is defined inside the function declaration with rest parameters.\n            // \n            // function foo(...a) {\n            //    var _i = \"!\";\n            //    function bar() {\n            //        var x = { get baz() { return _i; } }\n            //    }\n            // }\n            ////  if resolved symbol for node has more than one declaration - this is definitely an error\n            ////  (there is nothing value-like in the language that can be nested in function and consists of multiple declarations)\n            //if (symbol.declarations.length > 1) {\n            //    error(node, Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);\n            //    return;\n            //}\n            // short gist of the check:\n            // - otherwise\n            // - walk to the top of the tree starting from the 'node'\n            // - at every step check if 'current' node contains any declaration of original node\n            //   yes - return\n            //   no - check if current declaration is function with rest parameters\n            //        yes - report error since '_i' from this function will shadow '_i' defined in the outer scope\n            //        no - go up to the next level\n            var current = node;\n            while (current) {\n                var definedOnCurrentLevel = ts.forEach(symbol.declarations, function (d) { return d.parent === current ? d : undefined; });\n                if (definedOnCurrentLevel) {\n                    return;\n                }\n                switch (current.kind) {\n                    case 184 /* FunctionDeclaration */:\n                    case 150 /* FunctionExpression */:\n                    case 125 /* Method */:\n                    case 151 /* ArrowFunction */:\n                    case 126 /* Constructor */:\n                        if (ts.hasRestParameters(current)) {\n                            error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_i_that_compiler_uses_to_initialize_rest_parameter);\n                            return;\n                        }\n                        break;\n                }\n                current = current.parent;\n            }\n        }\n        function needCollisionCheckForIdentifier(node, identifier, name) {\n            if (!identifier || identifier.text !== name) {\n                return false;\n            }\n            if (node.kind === 124 /* Property */ || node.kind === 125 /* Method */ || node.kind === 127 /* GetAccessor */ || node.kind === 128 /* SetAccessor */) {\n                // it is ok to have member named '_super' or '_this' - member access is always qualified\n                return false;\n            }\n            if (ts.isInAmbientContext(node)) {\n                // ambient context - no codegen impact\n                return false;\n            }\n            if (node.kind === 123 /* Parameter */ && !node.parent.body) {\n                // just an overload - no codegen impact\n                return false;\n            }\n            return true;\n        }\n        function checkCollisionWithCapturedThisVariable(node, name) {\n            if (needCollisionCheckForIdentifier(node, name, \"_this\")) {\n                potentialThisCollisions.push(node);\n            }\n        }\n        // this function will run after checking the source file so 'CaptureThis' is correct for all nodes\n        function checkIfThisIsCapturedInEnclosingScope(node) {\n            var current = node;\n            while (current) {\n                if (getNodeCheckFlags(current) & 4 /* CaptureThis */) {\n                    var isDeclaration = node.kind !== 63 /* Identifier */;\n                    if (isDeclaration) {\n                        error(node.name, ts.Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);\n                    }\n                    else {\n                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);\n                    }\n                    return;\n                }\n                current = current.parent;\n            }\n        }\n        function checkCollisionWithCapturedSuperVariable(node, name) {\n            if (!needCollisionCheckForIdentifier(node, name, \"_super\")) {\n                return;\n            }\n            // bubble up and find containing type\n            var enclosingClass = ts.getAncestor(node, 185 /* ClassDeclaration */);\n            // if containing type was not found or it is ambient - exit (no codegen)\n            if (!enclosingClass || ts.isInAmbientContext(enclosingClass)) {\n                return;\n            }\n            if (ts.getClassBaseTypeNode(enclosingClass)) {\n                var isDeclaration = node.kind !== 63 /* Identifier */;\n                if (isDeclaration) {\n                    error(node, ts.Diagnostics.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference);\n                }\n                else {\n                    error(node, ts.Diagnostics.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference);\n                }\n            }\n        }\n        function checkCollisionWithRequireExportsInGeneratedCode(node, name) {\n            if (!needCollisionCheckForIdentifier(node, name, \"require\") && !needCollisionCheckForIdentifier(node, name, \"exports\")) {\n                return;\n            }\n            // Uninstantiated modules shouldnt do this check\n            if (node.kind === 189 /* ModuleDeclaration */ && ts.getModuleInstanceState(node) !== 1 /* Instantiated */) {\n                return;\n            }\n            // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent\n            var parent = node.kind === 183 /* VariableDeclaration */ ? node.parent.parent : node.parent;\n            if (parent.kind === 201 /* SourceFile */ && ts.isExternalModule(parent)) {\n                // If the declaration happens to be in external module, report error that require and exports are reserved keywords\n                error(name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_an_external_module, ts.declarationNameToString(name), ts.declarationNameToString(name));\n            }\n        }\n        function checkCollisionWithConstDeclarations(node) {\n            // Variable declarations are hoisted to the top of their function scope. They can shadow\n            // block scoped declarations, which bind tighter. this will not be flagged as duplicate definition\n            // by the binder as the declaration scope is different.\n            // A non-initialized declaration is a no-op as the block declaration will resolve before the var\n            // declaration. the problem is if the declaration has an initializer. this will act as a write to the\n            // block declared value. this is fine for let, but not const.\n            //\n            // Only consider declarations with initializers, uninitialized var declarations will not \n            // step on a const variable.\n            // Do not consider let and const declarations, as duplicate block-scoped declarations \n            // are handled by the binder.\n            // We are only looking for var declarations that step on const declarations from a \n            // different scope. e.g.:\n            //      var x = 0;\n            //      {\n            //          const x = 0;\n            //          var x = 0;\n            //      }\n            if (node.initializer && (node.flags & 6144 /* BlockScoped */) === 0) {\n                var symbol = getSymbolOfNode(node);\n                if (symbol.flags & 1 /* FunctionScopedVariable */) {\n                    var localDeclarationSymbol = resolveName(node, node.name.text, 3 /* Variable */, undefined, undefined);\n                    if (localDeclarationSymbol && localDeclarationSymbol !== symbol && localDeclarationSymbol.flags & 2 /* BlockScopedVariable */) {\n                        if (getDeclarationFlagsFromSymbol(localDeclarationSymbol) & 4096 /* Const */) {\n                            error(node, ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0, symbolToString(localDeclarationSymbol));\n                        }\n                    }\n                }\n            }\n        }\n        function checkVariableOrParameterOrPropertyInFullTypeCheck(node) {\n            ts.Debug.assert(fullTypeCheck);\n            checkSourceElement(node.type);\n            if (ts.hasComputedNameButNotSymbol(node)) {\n                // Just check the initializer, since this property won't contribute to the enclosing type\n                return node.initializer ? checkAndMarkExpression(node.initializer) : anyType;\n            }\n            var symbol = getSymbolOfNode(node);\n            var type;\n            if (symbol.valueDeclaration !== node) {\n                type = getTypeOfVariableOrParameterOrPropertyDeclaration(node);\n            }\n            else {\n                type = getTypeOfVariableOrParameterOrProperty(symbol);\n            }\n            if (node.initializer && !(getNodeLinks(node.initializer).flags & 1 /* TypeChecked */)) {\n                // Use default messages\n                checkTypeAssignableTo(checkAndMarkExpression(node.initializer), type, node, undefined);\n            }\n            return type;\n        }\n        function checkVariableOrParameterDeclaration(node) {\n            if (fullTypeCheck) {\n                var type = checkVariableOrParameterOrPropertyInFullTypeCheck(node);\n                checkExportsOnMergedDeclarations(node);\n                if (node.initializer) {\n                    checkCollisionWithConstDeclarations(node);\n                }\n                checkCollisionWithCapturedSuperVariable(node, node.name);\n                checkCollisionWithCapturedThisVariable(node, node.name);\n                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);\n                var symbol = getSymbolOfNode(node);\n                if (node !== symbol.valueDeclaration) {\n                    // TypeScript 1.0 spec (April 2014): 5.1\n                    // Multiple declarations for the same variable name in the same declaration space are permitted,\n                    // provided that each declaration associates the same type with the variable.\n                    var typeOfValueDeclaration = getTypeOfVariableOrParameterOrProperty(symbol);\n                    if (typeOfValueDeclaration !== unknownType && type !== unknownType && !isTypeIdenticalTo(typeOfValueDeclaration, type)) {\n                        error(node.name, ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, ts.declarationNameToString(node.name), typeToString(typeOfValueDeclaration), typeToString(type));\n                    }\n                }\n            }\n        }\n        function checkVariableStatement(node) {\n            ts.forEach(node.declarations, checkVariableOrParameterDeclaration);\n        }\n        function checkExpressionStatement(node) {\n            checkExpression(node.expression);\n        }\n        function checkIfStatement(node) {\n            checkExpression(node.expression);\n            checkSourceElement(node.thenStatement);\n            checkSourceElement(node.elseStatement);\n        }\n        function checkDoStatement(node) {\n            checkSourceElement(node.statement);\n            checkExpression(node.expression);\n        }\n        function checkWhileStatement(node) {\n            checkExpression(node.expression);\n            checkSourceElement(node.statement);\n        }\n        function checkForStatement(node) {\n            if (node.declarations)\n                ts.forEach(node.declarations, checkVariableOrParameterDeclaration);\n            if (node.initializer)\n                checkExpression(node.initializer);\n            if (node.condition)\n                checkExpression(node.condition);\n            if (node.iterator)\n                checkExpression(node.iterator);\n            checkSourceElement(node.statement);\n        }\n        function checkForInStatement(node) {\n            // TypeScript 1.0 spec  (April 2014): 5.4\n            // In a 'for-in' statement of the form\n            // for (var VarDecl in Expr) Statement\n            //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,\n            //   and Expr must be an expression of type Any, an object type, or a type parameter type.                        \n            if (node.declarations) {\n                if (node.declarations.length >= 1) {\n                    var decl = node.declarations[0];\n                    checkVariableOrParameterDeclaration(decl);\n                    if (decl.type) {\n                        error(decl, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation);\n                    }\n                }\n            }\n            // In a 'for-in' statement of the form\n            // for (Var in Expr) Statement\n            //   Var must be an expression classified as a reference of type Any or the String primitive type,\n            //   and Expr must be an expression of type Any, an object type, or a type parameter type.\n            if (node.variable) {\n                var exprType = checkExpression(node.variable);\n                if (exprType !== anyType && exprType !== stringType) {\n                    error(node.variable, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);\n                }\n                else {\n                    // run check only former check succeeded to avoid cascading errors\n                    checkReferenceExpression(node.variable, ts.Diagnostics.Invalid_left_hand_side_in_for_in_statement, ts.Diagnostics.Left_hand_side_of_assignment_expression_cannot_be_a_constant);\n                }\n            }\n            var exprType = checkExpression(node.expression);\n            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved\n            // in this case error about missing name is already reported - do not report extra one\n            if (!(exprType.flags & 1 /* Any */ || isStructuredType(exprType))) {\n                error(node.expression, ts.Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);\n            }\n            checkSourceElement(node.statement);\n        }\n        function checkBreakOrContinueStatement(node) {\n            // TODO: Check that target label is valid\n        }\n        function checkReturnStatement(node) {\n            if (node.expression && !(getNodeLinks(node.expression).flags & 1 /* TypeChecked */)) {\n                var func = ts.getContainingFunction(node);\n                if (func) {\n                    if (func.kind === 128 /* SetAccessor */) {\n                        if (node.expression) {\n                            error(node.expression, ts.Diagnostics.Setters_cannot_return_a_value);\n                        }\n                    }\n                    else {\n                        var returnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));\n                        // do assignability check only if we short circuited in determining return type\n                        // - function has explicit type annotation\n                        // - function is getter with no type annotation and setter parameter type is used\n                        // - function is a constructor (will be special cased below)\n                        var checkAssignability = func.type || (func.kind === 127 /* GetAccessor */ && getSetAccessorTypeAnnotationNode(ts.getDeclarationOfKind(func.symbol, 128 /* SetAccessor */)));\n                        if (checkAssignability) {\n                            checkTypeAssignableTo(checkExpression(node.expression), returnType, node.expression, undefined);\n                        }\n                        else if (func.kind == 126 /* Constructor */) {\n                            // constructor doesn't have explicit return type annotation and yet its return type is known - declaring type\n                            // handle constructors and issue specialized error message for them.\n                            if (!isTypeAssignableTo(checkExpression(node.expression), returnType)) {\n                                error(node.expression, ts.Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function checkWithStatement(node) {\n            checkExpression(node.expression);\n            error(node.expression, ts.Diagnostics.All_symbols_within_a_with_block_will_be_resolved_to_any);\n        }\n        function checkSwitchStatement(node) {\n            var expressionType = checkExpression(node.expression);\n            ts.forEach(node.clauses, function (clause) {\n                if (fullTypeCheck && clause.kind === 194 /* CaseClause */) {\n                    var caseClause = clause;\n                    // TypeScript 1.0 spec (April 2014):5.9\n                    // In a 'switch' statement, each 'case' expression must be of a type that is assignable to or from the type of the 'switch' expression.\n                    var caseType = checkExpression(caseClause.expression);\n                    if (!isTypeAssignableTo(expressionType, caseType)) {\n                        // check 'expressionType isAssignableTo caseType' failed, try the reversed check and report errors if it fails\n                        checkTypeAssignableTo(caseType, expressionType, caseClause.expression, undefined);\n                    }\n                }\n                ts.forEach(clause.statements, checkSourceElement);\n            });\n        }\n        function checkLabeledStatement(node) {\n            checkSourceElement(node.statement);\n        }\n        function checkThrowStatement(node) {\n            if (node.expression) {\n                checkExpression(node.expression);\n            }\n        }\n        function checkTryStatement(node) {\n            checkBlock(node.tryBlock);\n            if (node.catchClause)\n                checkBlock(node.catchClause.block);\n            if (node.finallyBlock)\n                checkBlock(node.finallyBlock);\n        }\n        function checkIndexConstraints(type) {\n            function checkIndexConstraintForProperty(prop, propertyType, indexDeclaration, indexType, indexKind) {\n                if (!indexType) {\n                    return;\n                }\n                // index is numeric and property name is not valid numeric literal\n                if (indexKind === 1 /* Number */ && !isNumericName(prop.name)) {\n                    return;\n                }\n                // perform property check if property or indexer is declared in 'type'\n                // this allows to rule out cases when both property and indexer are inherited from the base class\n                var errorNode;\n                if (prop.parent === type.symbol) {\n                    errorNode = prop.valueDeclaration;\n                }\n                else if (indexDeclaration) {\n                    errorNode = indexDeclaration;\n                }\n                else if (type.flags & 2048 /* Interface */) {\n                    // for interfaces property and indexer might be inherited from different bases\n                    // check if any base class already has both property and indexer.\n                    // check should be performed only if 'type' is the first type that brings property\\indexer together\n                    var someBaseClassHasBothPropertyAndIndexer = ts.forEach(type.baseTypes, function (base) { return getPropertyOfObjectType(base, prop.name) && getIndexTypeOfType(base, indexKind); });\n                    errorNode = someBaseClassHasBothPropertyAndIndexer ? undefined : type.symbol.declarations[0];\n                }\n                if (errorNode && !isTypeAssignableTo(propertyType, indexType)) {\n                    var errorMessage = indexKind === 0 /* String */ ? ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_string_index_type_2 : ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;\n                    error(errorNode, errorMessage, symbolToString(prop), typeToString(propertyType), typeToString(indexType));\n                }\n            }\n            var declaredNumberIndexer = getIndexDeclarationOfSymbol(type.symbol, 1 /* Number */);\n            var declaredStringIndexer = getIndexDeclarationOfSymbol(type.symbol, 0 /* String */);\n            var stringIndexType = getIndexTypeOfType(type, 0 /* String */);\n            var numberIndexType = getIndexTypeOfType(type, 1 /* Number */);\n            if (stringIndexType || numberIndexType) {\n                ts.forEach(getPropertiesOfObjectType(type), function (prop) {\n                    var propType = getTypeOfSymbol(prop);\n                    checkIndexConstraintForProperty(prop, propType, declaredStringIndexer, stringIndexType, 0 /* String */);\n                    checkIndexConstraintForProperty(prop, propType, declaredNumberIndexer, numberIndexType, 1 /* Number */);\n                });\n            }\n            var errorNode;\n            if (stringIndexType && numberIndexType) {\n                errorNode = declaredNumberIndexer || declaredStringIndexer;\n                // condition 'errorNode === undefined' may appear if types does not declare nor string neither number indexer\n                if (!errorNode && (type.flags & 2048 /* Interface */)) {\n                    var someBaseTypeHasBothIndexers = ts.forEach(type.baseTypes, function (base) { return getIndexTypeOfType(base, 0 /* String */) && getIndexTypeOfType(base, 1 /* Number */); });\n                    errorNode = someBaseTypeHasBothIndexers ? undefined : type.symbol.declarations[0];\n                }\n            }\n            if (errorNode && !isTypeAssignableTo(numberIndexType, stringIndexType)) {\n                error(errorNode, ts.Diagnostics.Numeric_index_type_0_is_not_assignable_to_string_index_type_1, typeToString(numberIndexType), typeToString(stringIndexType));\n            }\n        }\n        // TODO(jfreeman): Decide what to do for computed properties\n        function checkTypeNameIsReserved(name, message) {\n            switch (name.text) {\n                case \"any\":\n                case \"number\":\n                case \"boolean\":\n                case \"string\":\n                case \"void\":\n                    error(name, message, name.text);\n            }\n        }\n        // Check each type parameter and check that list has no duplicate type parameter declarations\n        function checkTypeParameters(typeParameterDeclarations) {\n            if (typeParameterDeclarations) {\n                for (var i = 0; i < typeParameterDeclarations.length; i++) {\n                    var node = typeParameterDeclarations[i];\n                    checkTypeParameter(node);\n                    if (fullTypeCheck) {\n                        for (var j = 0; j < i; j++) {\n                            if (typeParameterDeclarations[j].symbol === node.symbol) {\n                                error(node.name, ts.Diagnostics.Duplicate_identifier_0, ts.declarationNameToString(node.name));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function checkClassDeclaration(node) {\n            checkTypeNameIsReserved(node.name, ts.Diagnostics.Class_name_cannot_be_0);\n            checkTypeParameters(node.typeParameters);\n            checkCollisionWithCapturedThisVariable(node, node.name);\n            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);\n            checkExportsOnMergedDeclarations(node);\n            var symbol = getSymbolOfNode(node);\n            var type = getDeclaredTypeOfSymbol(symbol);\n            var staticType = getTypeOfSymbol(symbol);\n            var baseTypeNode = ts.getClassBaseTypeNode(node);\n            if (baseTypeNode) {\n                emitExtends = emitExtends || !ts.isInAmbientContext(node);\n                checkTypeReference(baseTypeNode);\n            }\n            if (type.baseTypes.length) {\n                if (fullTypeCheck) {\n                    var baseType = type.baseTypes[0];\n                    checkTypeAssignableTo(type, baseType, node.name, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1);\n                    var staticBaseType = getTypeOfSymbol(baseType.symbol);\n                    checkTypeAssignableTo(staticType, getTypeWithoutConstructors(staticBaseType), node.name, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);\n                    if (baseType.symbol !== resolveEntityName(node, baseTypeNode.typeName, 107455 /* Value */)) {\n                        error(baseTypeNode, ts.Diagnostics.Type_name_0_in_extends_clause_does_not_reference_constructor_function_for_0, typeToString(baseType));\n                    }\n                    checkKindsOfPropertyMemberOverrides(type, baseType);\n                }\n                // Check that base type can be evaluated as expression\n                checkExpressionOrQualifiedName(baseTypeNode.typeName);\n            }\n            var implementedTypeNodes = ts.getClassImplementedTypeNodes(node);\n            if (implementedTypeNodes) {\n                ts.forEach(implementedTypeNodes, function (typeRefNode) {\n                    checkTypeReference(typeRefNode);\n                    if (fullTypeCheck) {\n                        var t = getTypeFromTypeReferenceNode(typeRefNode);\n                        if (t !== unknownType) {\n                            var declaredType = (t.flags & 4096 /* Reference */) ? t.target : t;\n                            if (declaredType.flags & (1024 /* Class */ | 2048 /* Interface */)) {\n                                checkTypeAssignableTo(type, t, node.name, ts.Diagnostics.Class_0_incorrectly_implements_interface_1);\n                            }\n                            else {\n                                error(typeRefNode, ts.Diagnostics.A_class_may_only_implement_another_class_or_interface);\n                            }\n                        }\n                    }\n                });\n            }\n            ts.forEach(node.members, checkSourceElement);\n            if (fullTypeCheck) {\n                checkIndexConstraints(type);\n                checkTypeForDuplicateIndexSignatures(node);\n            }\n        }\n        function getTargetSymbol(s) {\n            // if symbol is instantiated its flags are not copied from the 'target'\n            // so we'll need to get back original 'target' symbol to work with correct set of flags\n            return s.flags & 67108864 /* Instantiated */ ? getSymbolLinks(s).target : s;\n        }\n        function checkKindsOfPropertyMemberOverrides(type, baseType) {\n            // TypeScript 1.0 spec (April 2014): 8.2.3\n            // A derived class inherits all members from its base class it doesn't override.\n            // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.\n            // Both public and private property members are inherited, but only public property members can be overridden.\n            // A property member in a derived class is said to override a property member in a base class\n            // when the derived class property member has the same name and kind(instance or static) \n            // as the base class property member.\n            // The type of an overriding property member must be assignable(section 3.8.4)\n            // to the type of the overridden property member, or otherwise a compile - time error occurs.\n            // Base class instance member functions can be overridden by derived class instance member functions,\n            // but not by other kinds of members.\n            // Base class instance member variables and accessors can be overridden by \n            // derived class instance member variables and accessors, but not by other kinds of members.\n            // NOTE: assignability is checked in checkClassDeclaration\n            var baseProperties = getPropertiesOfObjectType(baseType);\n            for (var i = 0, len = baseProperties.length; i < len; ++i) {\n                var base = getTargetSymbol(baseProperties[i]);\n                if (base.flags & 536870912 /* Prototype */) {\n                    continue;\n                }\n                var derived = getTargetSymbol(getPropertyOfObjectType(type, base.name));\n                if (derived) {\n                    var baseDeclarationFlags = getDeclarationFlagsFromSymbol(base);\n                    var derivedDeclarationFlags = getDeclarationFlagsFromSymbol(derived);\n                    if ((baseDeclarationFlags & 32 /* Private */) || (derivedDeclarationFlags & 32 /* Private */)) {\n                        continue;\n                    }\n                    if ((baseDeclarationFlags & 128 /* Static */) !== (derivedDeclarationFlags & 128 /* Static */)) {\n                        continue;\n                    }\n                    if ((base.flags & derived.flags & 8192 /* Method */) || ((base.flags & 98308 /* PropertyOrAccessor */) && (derived.flags & 98308 /* PropertyOrAccessor */))) {\n                        continue;\n                    }\n                    var errorMessage;\n                    if (base.flags & 8192 /* Method */) {\n                        if (derived.flags & 98304 /* Accessor */) {\n                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;\n                        }\n                        else {\n                            ts.Debug.assert((derived.flags & 4 /* Property */) !== 0);\n                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;\n                        }\n                    }\n                    else if (base.flags & 4 /* Property */) {\n                        ts.Debug.assert((derived.flags & 8192 /* Method */) !== 0);\n                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;\n                    }\n                    else {\n                        ts.Debug.assert((base.flags & 98304 /* Accessor */) !== 0);\n                        ts.Debug.assert((derived.flags & 8192 /* Method */) !== 0);\n                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;\n                    }\n                    error(derived.valueDeclaration.name, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));\n                }\n            }\n        }\n        function isAccessor(kind) {\n            return kind === 127 /* GetAccessor */ || kind === 128 /* SetAccessor */;\n        }\n        function areTypeParametersIdentical(list1, list2) {\n            if (!list1 && !list2) {\n                return true;\n            }\n            if (!list1 || !list2 || list1.length !== list2.length) {\n                return false;\n            }\n            for (var i = 0, len = list1.length; i < len; i++) {\n                var tp1 = list1[i];\n                var tp2 = list2[i];\n                if (tp1.name.text !== tp2.name.text) {\n                    return false;\n                }\n                if (!tp1.constraint && !tp2.constraint) {\n                    continue;\n                }\n                if (!tp1.constraint || !tp2.constraint) {\n                    return false;\n                }\n                if (!isTypeIdenticalTo(getTypeFromTypeNode(tp1.constraint), getTypeFromTypeNode(tp2.constraint))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function checkInheritedPropertiesAreIdentical(type, typeNode) {\n            if (!type.baseTypes.length || type.baseTypes.length === 1) {\n                return true;\n            }\n            var seen = {};\n            ts.forEach(type.declaredProperties, function (p) {\n                seen[p.name] = { prop: p, containingType: type };\n            });\n            var ok = true;\n            for (var i = 0, len = type.baseTypes.length; i < len; ++i) {\n                var base = type.baseTypes[i];\n                var properties = getPropertiesOfObjectType(base);\n                for (var j = 0, proplen = properties.length; j < proplen; ++j) {\n                    var prop = properties[j];\n                    if (!ts.hasProperty(seen, prop.name)) {\n                        seen[prop.name] = { prop: prop, containingType: base };\n                    }\n                    else {\n                        var existing = seen[prop.name];\n                        var isInheritedProperty = existing.containingType !== type;\n                        if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {\n                            ok = false;\n                            var typeName1 = typeToString(existing.containingType);\n                            var typeName2 = typeToString(base);\n                            var errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Named_properties_0_of_types_1_and_2_are_not_identical, prop.name, typeName1, typeName2);\n                            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);\n                            addDiagnostic(ts.createDiagnosticForNodeFromMessageChain(typeNode, errorInfo, program.getCompilerHost().getNewLine()));\n                        }\n                    }\n                }\n            }\n            return ok;\n        }\n        function checkInterfaceDeclaration(node) {\n            checkTypeParameters(node.typeParameters);\n            if (fullTypeCheck) {\n                checkTypeNameIsReserved(node.name, ts.Diagnostics.Interface_name_cannot_be_0);\n                checkExportsOnMergedDeclarations(node);\n                var symbol = getSymbolOfNode(node);\n                var firstInterfaceDecl = ts.getDeclarationOfKind(symbol, 186 /* InterfaceDeclaration */);\n                if (symbol.declarations.length > 1) {\n                    if (node !== firstInterfaceDecl && !areTypeParametersIdentical(firstInterfaceDecl.typeParameters, node.typeParameters)) {\n                        error(node.name, ts.Diagnostics.All_declarations_of_an_interface_must_have_identical_type_parameters);\n                    }\n                }\n                // Only check this symbol once\n                if (node === firstInterfaceDecl) {\n                    var type = getDeclaredTypeOfSymbol(symbol);\n                    // run subsequent checks only if first set succeeded\n                    if (checkInheritedPropertiesAreIdentical(type, node.name)) {\n                        ts.forEach(type.baseTypes, function (baseType) {\n                            checkTypeAssignableTo(type, baseType, node.name, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1);\n                        });\n                        checkIndexConstraints(type);\n                    }\n                }\n            }\n            ts.forEach(ts.getInterfaceBaseTypeNodes(node), checkTypeReference);\n            ts.forEach(node.members, checkSourceElement);\n            if (fullTypeCheck) {\n                checkTypeForDuplicateIndexSignatures(node);\n            }\n        }\n        function checkTypeAliasDeclaration(node) {\n            checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_alias_name_cannot_be_0);\n            checkSourceElement(node.type);\n        }\n        function computeEnumMemberValues(node) {\n            var nodeLinks = getNodeLinks(node);\n            if (!(nodeLinks.flags & 128 /* EnumValuesComputed */)) {\n                var enumSymbol = getSymbolOfNode(node);\n                var enumType = getDeclaredTypeOfSymbol(enumSymbol);\n                var autoValue = 0;\n                var ambient = ts.isInAmbientContext(node);\n                var enumIsConst = ts.isConst(node);\n                ts.forEach(node.members, function (member) {\n                    // TODO(jfreeman): Check that it is not a computed name\n                    if (isNumericName(member.name.text)) {\n                        error(member.name, ts.Diagnostics.An_enum_member_cannot_have_a_numeric_name);\n                    }\n                    var initializer = member.initializer;\n                    if (initializer) {\n                        autoValue = getConstantValueForEnumMemberInitializer(initializer, enumIsConst);\n                        if (autoValue === undefined) {\n                            if (enumIsConst) {\n                                error(initializer, ts.Diagnostics.In_const_enum_declarations_member_initializer_must_be_constant_expression);\n                            }\n                            else if (!ambient) {\n                                // Only here do we need to check that the initializer is assignable to the enum type.\n                                // If it is a constant value (not undefined), it is syntactically constrained to be a number. \n                                // Also, we do not need to check this for ambients because there is already\n                                // a syntax error if it is not a constant.\n                                checkTypeAssignableTo(checkExpression(initializer), enumType, initializer, undefined);\n                            }\n                        }\n                        else if (enumIsConst) {\n                            if (isNaN(autoValue)) {\n                                error(initializer, ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN);\n                            }\n                            else if (!isFinite(autoValue)) {\n                                error(initializer, ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value);\n                            }\n                        }\n                    }\n                    else if (ambient && !enumIsConst) {\n                        autoValue = undefined;\n                    }\n                    if (autoValue !== undefined) {\n                        getNodeLinks(member).enumMemberValue = autoValue++;\n                    }\n                });\n                nodeLinks.flags |= 128 /* EnumValuesComputed */;\n            }\n            function getConstantValueForEnumMemberInitializer(initializer, enumIsConst) {\n                return evalConstant(initializer);\n                function evalConstant(e) {\n                    switch (e.kind) {\n                        case 155 /* PrefixUnaryExpression */:\n                            var value = evalConstant(e.operand);\n                            if (value === undefined) {\n                                return undefined;\n                            }\n                            switch (e.operator) {\n                                case 32 /* PlusToken */: return value;\n                                case 33 /* MinusToken */: return -value;\n                                case 46 /* TildeToken */: return enumIsConst ? ~value : undefined;\n                            }\n                            return undefined;\n                        case 157 /* BinaryExpression */:\n                            if (!enumIsConst) {\n                                return undefined;\n                            }\n                            var left = evalConstant(e.left);\n                            if (left === undefined) {\n                                return undefined;\n                            }\n                            var right = evalConstant(e.right);\n                            if (right === undefined) {\n                                return undefined;\n                            }\n                            switch (e.operator) {\n                                case 43 /* BarToken */: return left | right;\n                                case 42 /* AmpersandToken */: return left & right;\n                                case 40 /* GreaterThanGreaterThanToken */: return left >> right;\n                                case 41 /* GreaterThanGreaterThanGreaterThanToken */: return left >>> right;\n                                case 39 /* LessThanLessThanToken */: return left << right;\n                                case 44 /* CaretToken */: return left ^ right;\n                                case 34 /* AsteriskToken */: return left * right;\n                                case 35 /* SlashToken */: return left / right;\n                                case 32 /* PlusToken */: return left + right;\n                                case 33 /* MinusToken */: return left - right;\n                                case 36 /* PercentToken */: return left % right;\n                            }\n                            return undefined;\n                        case 6 /* NumericLiteral */:\n                            return +e.text;\n                        case 149 /* ParenthesizedExpression */:\n                            return enumIsConst ? evalConstant(e.expression) : undefined;\n                        case 63 /* Identifier */:\n                        case 144 /* ElementAccessExpression */:\n                        case 143 /* PropertyAccessExpression */:\n                            if (!enumIsConst) {\n                                return undefined;\n                            }\n                            var member = initializer.parent;\n                            var currentType = getTypeOfSymbol(getSymbolOfNode(member.parent));\n                            var enumType;\n                            var propertyName;\n                            if (e.kind === 63 /* Identifier */) {\n                                // unqualified names can refer to member that reside in different declaration of the enum so just doing name resolution won't work.\n                                // instead pick current enum type and later try to fetch member from the type\n                                enumType = currentType;\n                                propertyName = e.text;\n                            }\n                            else {\n                                if (e.kind === 144 /* ElementAccessExpression */) {\n                                    if (e.argumentExpression === undefined || e.argumentExpression.kind !== 7 /* StringLiteral */) {\n                                        return undefined;\n                                    }\n                                    var enumType = getTypeOfNode(e.expression);\n                                    propertyName = e.argumentExpression.text;\n                                }\n                                else {\n                                    var enumType = getTypeOfNode(e.expression);\n                                    propertyName = e.name.text;\n                                }\n                                if (enumType !== currentType) {\n                                    return undefined;\n                                }\n                            }\n                            if (propertyName === undefined) {\n                                return undefined;\n                            }\n                            var property = getPropertyOfObjectType(enumType, propertyName);\n                            if (!property || !(property.flags & 8 /* EnumMember */)) {\n                                return undefined;\n                            }\n                            var propertyDecl = property.valueDeclaration;\n                            // self references are illegal\n                            if (member === propertyDecl) {\n                                return undefined;\n                            }\n                            // illegal case: forward reference\n                            if (!isDefinedBefore(propertyDecl, member)) {\n                                return undefined;\n                            }\n                            return getNodeLinks(propertyDecl).enumMemberValue;\n                    }\n                }\n            }\n        }\n        function checkEnumDeclaration(node) {\n            if (!fullTypeCheck) {\n                return;\n            }\n            checkTypeNameIsReserved(node.name, ts.Diagnostics.Enum_name_cannot_be_0);\n            checkCollisionWithCapturedThisVariable(node, node.name);\n            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);\n            checkExportsOnMergedDeclarations(node);\n            computeEnumMemberValues(node);\n            // Spec 2014 - Section 9.3:\n            // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,\n            // and when an enum type has multiple declarations, only one declaration is permitted to omit a value\n            // for the first member.\n            //\n            // Only perform this check once per symbol\n            var enumSymbol = getSymbolOfNode(node);\n            var firstDeclaration = ts.getDeclarationOfKind(enumSymbol, node.kind);\n            if (node === firstDeclaration) {\n                if (enumSymbol.declarations.length > 1) {\n                    var enumIsConst = ts.isConst(node);\n                    // check that const is placed\\omitted on all enum declarations\n                    ts.forEach(enumSymbol.declarations, function (decl) {\n                        if (ts.isConstEnumDeclaration(decl) !== enumIsConst) {\n                            error(decl.name, ts.Diagnostics.Enum_declarations_must_all_be_const_or_non_const);\n                        }\n                    });\n                }\n                var seenEnumMissingInitialInitializer = false;\n                ts.forEach(enumSymbol.declarations, function (declaration) {\n                    // return true if we hit a violation of the rule, false otherwise\n                    if (declaration.kind !== 188 /* EnumDeclaration */) {\n                        return false;\n                    }\n                    var enumDeclaration = declaration;\n                    if (!enumDeclaration.members.length) {\n                        return false;\n                    }\n                    var firstEnumMember = enumDeclaration.members[0];\n                    if (!firstEnumMember.initializer) {\n                        if (seenEnumMissingInitialInitializer) {\n                            error(firstEnumMember.name, ts.Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);\n                        }\n                        else {\n                            seenEnumMissingInitialInitializer = true;\n                        }\n                    }\n                });\n            }\n        }\n        function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {\n            var declarations = symbol.declarations;\n            for (var i = 0; i < declarations.length; i++) {\n                var declaration = declarations[i];\n                if ((declaration.kind === 185 /* ClassDeclaration */ || (declaration.kind === 184 /* FunctionDeclaration */ && declaration.body)) && !ts.isInAmbientContext(declaration)) {\n                    return declaration;\n                }\n            }\n            return undefined;\n        }\n        function checkModuleDeclaration(node) {\n            if (fullTypeCheck) {\n                checkCollisionWithCapturedThisVariable(node, node.name);\n                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);\n                checkExportsOnMergedDeclarations(node);\n                var symbol = getSymbolOfNode(node);\n                if (symbol.flags & 512 /* ValueModule */ && symbol.declarations.length > 1 && !ts.isInAmbientContext(node)) {\n                    var classOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);\n                    if (classOrFunc) {\n                        if (ts.getSourceFileOfNode(node) !== ts.getSourceFileOfNode(classOrFunc)) {\n                            error(node.name, ts.Diagnostics.A_module_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);\n                        }\n                        else if (node.pos < classOrFunc.pos) {\n                            error(node.name, ts.Diagnostics.A_module_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);\n                        }\n                    }\n                }\n                if (node.name.kind === 7 /* StringLiteral */) {\n                    if (!isGlobalSourceFile(node.parent)) {\n                        error(node.name, ts.Diagnostics.Ambient_external_modules_cannot_be_nested_in_other_modules);\n                    }\n                    if (isExternalModuleNameRelative(node.name.text)) {\n                        error(node.name, ts.Diagnostics.Ambient_external_module_declaration_cannot_specify_relative_module_name);\n                    }\n                }\n            }\n            checkSourceElement(node.body);\n        }\n        function getFirstIdentifier(node) {\n            while (node.kind === 120 /* QualifiedName */) {\n                node = node.left;\n            }\n            return node;\n        }\n        function checkImportDeclaration(node) {\n            checkCollisionWithCapturedThisVariable(node, node.name);\n            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);\n            var symbol = getSymbolOfNode(node);\n            var target;\n            if (ts.isInternalModuleImportDeclaration(node)) {\n                target = resolveImport(symbol);\n                // Import declaration for an internal module\n                if (target !== unknownSymbol) {\n                    if (target.flags & 107455 /* Value */) {\n                        // Target is a value symbol, check that it is not hidden by a local declaration with the same name and\n                        // ensure it can be evaluated as an expression\n                        var moduleName = getFirstIdentifier(node.moduleReference);\n                        if (resolveEntityName(node, moduleName, 107455 /* Value */ | 1536 /* Namespace */).flags & 1536 /* Namespace */) {\n                            checkExpressionOrQualifiedName(node.moduleReference);\n                        }\n                        else {\n                            error(moduleName, ts.Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, ts.declarationNameToString(moduleName));\n                        }\n                    }\n                    if (target.flags & 3152352 /* Type */) {\n                        checkTypeNameIsReserved(node.name, ts.Diagnostics.Import_name_cannot_be_0);\n                    }\n                }\n            }\n            else {\n                // Import declaration for an external module\n                if (node.parent.kind === 201 /* SourceFile */) {\n                    target = resolveImport(symbol);\n                }\n                else if (node.parent.kind === 190 /* ModuleBlock */ && node.parent.parent.name.kind === 7 /* StringLiteral */) {\n                    // TypeScript 1.0 spec (April 2013): 12.1.6\n                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference \n                    // other external modules only through top - level external module names.\n                    // Relative external module names are not permitted.\n                    if (ts.getExternalModuleImportDeclarationExpression(node).kind === 7 /* StringLiteral */) {\n                        if (isExternalModuleNameRelative(ts.getExternalModuleImportDeclarationExpression(node).text)) {\n                            error(node, ts.Diagnostics.Import_declaration_in_an_ambient_external_module_declaration_cannot_reference_external_module_through_relative_external_module_name);\n                            target = unknownSymbol;\n                        }\n                        else {\n                            target = resolveImport(symbol);\n                        }\n                    }\n                    else {\n                        target = unknownSymbol;\n                    }\n                }\n                else {\n                    // Parent is an internal module (syntax error is already reported)\n                    target = unknownSymbol;\n                }\n            }\n            if (target !== unknownSymbol) {\n                var excludedMeanings = (symbol.flags & 107455 /* Value */ ? 107455 /* Value */ : 0) | (symbol.flags & 3152352 /* Type */ ? 3152352 /* Type */ : 0) | (symbol.flags & 1536 /* Namespace */ ? 1536 /* Namespace */ : 0);\n                if (target.flags & excludedMeanings) {\n                    error(node, ts.Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0, symbolToString(symbol));\n                }\n            }\n        }\n        function checkExportAssignment(node) {\n            var container = node.parent;\n            if (container.kind !== 201 /* SourceFile */) {\n                // In a module, the immediate parent will be a block, so climb up one more parent\n                container = container.parent;\n            }\n            checkTypeOfExportAssignmentSymbol(getSymbolOfNode(container));\n        }\n        function checkSourceElement(node) {\n            if (!node)\n                return;\n            switch (node.kind) {\n                case 122 /* TypeParameter */:\n                    return checkTypeParameter(node);\n                case 123 /* Parameter */:\n                    return checkParameter(node);\n                case 124 /* Property */:\n                    return checkPropertyDeclaration(node);\n                case 133 /* FunctionType */:\n                case 134 /* ConstructorType */:\n                case 129 /* CallSignature */:\n                case 130 /* ConstructSignature */:\n                case 131 /* IndexSignature */:\n                    return checkSignatureDeclaration(node);\n                case 125 /* Method */:\n                    return checkMethodDeclaration(node);\n                case 126 /* Constructor */:\n                    return checkConstructorDeclaration(node);\n                case 127 /* GetAccessor */:\n                case 128 /* SetAccessor */:\n                    return checkAccessorDeclaration(node);\n                case 132 /* TypeReference */:\n                    return checkTypeReference(node);\n                case 135 /* TypeQuery */:\n                    return checkTypeQuery(node);\n                case 136 /* TypeLiteral */:\n                    return checkTypeLiteral(node);\n                case 137 /* ArrayType */:\n                    return checkArrayType(node);\n                case 138 /* TupleType */:\n                    return checkTupleType(node);\n                case 139 /* UnionType */:\n                    return checkUnionType(node);\n                case 140 /* ParenthesizedType */:\n                    return checkSourceElement(node.type);\n                case 184 /* FunctionDeclaration */:\n                    return checkFunctionDeclaration(node);\n                case 163 /* Block */:\n                case 190 /* ModuleBlock */:\n                    return checkBlock(node);\n                case 164 /* VariableStatement */:\n                    return checkVariableStatement(node);\n                case 166 /* ExpressionStatement */:\n                    return checkExpressionStatement(node);\n                case 167 /* IfStatement */:\n                    return checkIfStatement(node);\n                case 168 /* DoStatement */:\n                    return checkDoStatement(node);\n                case 169 /* WhileStatement */:\n                    return checkWhileStatement(node);\n                case 170 /* ForStatement */:\n                    return checkForStatement(node);\n                case 171 /* ForInStatement */:\n                    return checkForInStatement(node);\n                case 172 /* ContinueStatement */:\n                case 173 /* BreakStatement */:\n                    return checkBreakOrContinueStatement(node);\n                case 174 /* ReturnStatement */:\n                    return checkReturnStatement(node);\n                case 175 /* WithStatement */:\n                    return checkWithStatement(node);\n                case 176 /* SwitchStatement */:\n                    return checkSwitchStatement(node);\n                case 177 /* LabeledStatement */:\n                    return checkLabeledStatement(node);\n                case 178 /* ThrowStatement */:\n                    return checkThrowStatement(node);\n                case 179 /* TryStatement */:\n                    return checkTryStatement(node);\n                case 183 /* VariableDeclaration */:\n                    return ts.Debug.fail(\"Checker encountered variable declaration\");\n                case 185 /* ClassDeclaration */:\n                    return checkClassDeclaration(node);\n                case 186 /* InterfaceDeclaration */:\n                    return checkInterfaceDeclaration(node);\n                case 187 /* TypeAliasDeclaration */:\n                    return checkTypeAliasDeclaration(node);\n                case 188 /* EnumDeclaration */:\n                    return checkEnumDeclaration(node);\n                case 189 /* ModuleDeclaration */:\n                    return checkModuleDeclaration(node);\n                case 191 /* ImportDeclaration */:\n                    return checkImportDeclaration(node);\n                case 192 /* ExportAssignment */:\n                    return checkExportAssignment(node);\n            }\n        }\n        // Function expression bodies are checked after all statements in the enclosing body. This is to ensure\n        // constructs like the following are permitted:\n        //     var foo = function () {\n        //        var s = foo();\n        //        return \"hello\";\n        //     }\n        // Here, performing a full type check of the body of the function expression whilst in the process of\n        // determining the type of foo would cause foo to be given type any because of the recursive reference.\n        // Delaying the type check of the body ensures foo has been assigned a type.\n        function checkFunctionExpressionBodies(node) {\n            switch (node.kind) {\n                case 150 /* FunctionExpression */:\n                case 151 /* ArrowFunction */:\n                    ts.forEach(node.parameters, checkFunctionExpressionBodies);\n                    checkFunctionExpressionOrObjectLiteralMethodBody(node);\n                    break;\n                case 125 /* Method */:\n                    ts.forEach(node.parameters, checkFunctionExpressionBodies);\n                    if (ts.isObjectLiteralMethod(node)) {\n                        checkFunctionExpressionOrObjectLiteralMethodBody(node);\n                    }\n                    break;\n                case 126 /* Constructor */:\n                case 127 /* GetAccessor */:\n                case 128 /* SetAccessor */:\n                case 184 /* FunctionDeclaration */:\n                    ts.forEach(node.parameters, checkFunctionExpressionBodies);\n                    break;\n                case 175 /* WithStatement */:\n                    checkFunctionExpressionBodies(node.expression);\n                    break;\n                case 123 /* Parameter */:\n                case 124 /* Property */:\n                case 141 /* ArrayLiteralExpression */:\n                case 142 /* ObjectLiteralExpression */:\n                case 198 /* PropertyAssignment */:\n                case 143 /* PropertyAccessExpression */:\n                case 144 /* ElementAccessExpression */:\n                case 145 /* CallExpression */:\n                case 146 /* NewExpression */:\n                case 147 /* TaggedTemplateExpression */:\n                case 159 /* TemplateExpression */:\n                case 162 /* TemplateSpan */:\n                case 148 /* TypeAssertionExpression */:\n                case 149 /* ParenthesizedExpression */:\n                case 153 /* TypeOfExpression */:\n                case 154 /* VoidExpression */:\n                case 152 /* DeleteExpression */:\n                case 155 /* PrefixUnaryExpression */:\n                case 156 /* PostfixUnaryExpression */:\n                case 157 /* BinaryExpression */:\n                case 158 /* ConditionalExpression */:\n                case 163 /* Block */:\n                case 190 /* ModuleBlock */:\n                case 164 /* VariableStatement */:\n                case 166 /* ExpressionStatement */:\n                case 167 /* IfStatement */:\n                case 168 /* DoStatement */:\n                case 169 /* WhileStatement */:\n                case 170 /* ForStatement */:\n                case 171 /* ForInStatement */:\n                case 172 /* ContinueStatement */:\n                case 173 /* BreakStatement */:\n                case 174 /* ReturnStatement */:\n                case 176 /* SwitchStatement */:\n                case 194 /* CaseClause */:\n                case 195 /* DefaultClause */:\n                case 177 /* LabeledStatement */:\n                case 178 /* ThrowStatement */:\n                case 179 /* TryStatement */:\n                case 180 /* TryBlock */:\n                case 197 /* CatchClause */:\n                case 181 /* FinallyBlock */:\n                case 183 /* VariableDeclaration */:\n                case 185 /* ClassDeclaration */:\n                case 188 /* EnumDeclaration */:\n                case 200 /* EnumMember */:\n                case 201 /* SourceFile */:\n                    ts.forEachChild(node, checkFunctionExpressionBodies);\n                    break;\n            }\n        }\n        // Fully type check a source file and collect the relevant diagnostics.\n        function checkSourceFile(node) {\n            var links = getNodeLinks(node);\n            if (!(links.flags & 1 /* TypeChecked */)) {\n                emitExtends = false;\n                potentialThisCollisions.length = 0;\n                ts.forEach(node.statements, checkSourceElement);\n                checkFunctionExpressionBodies(node);\n                if (ts.isExternalModule(node)) {\n                    var symbol = getExportAssignmentSymbol(node.symbol);\n                    if (symbol && symbol.flags & 33554432 /* Import */) {\n                        // Mark the import as referenced so that we emit it in the final .js file.\n                        getSymbolLinks(symbol).referenced = true;\n                    }\n                }\n                if (potentialThisCollisions.length) {\n                    ts.forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);\n                    potentialThisCollisions.length = 0;\n                }\n                if (emitExtends) {\n                    links.flags |= 8 /* EmitExtends */;\n                }\n                links.flags |= 1 /* TypeChecked */;\n            }\n        }\n        function getSortedDiagnostics() {\n            ts.Debug.assert(fullTypeCheck, \"diagnostics are available only in the full typecheck mode\");\n            if (diagnosticsModified) {\n                diagnostics.sort(ts.compareDiagnostics);\n                diagnostics = ts.deduplicateSortedDiagnostics(diagnostics);\n                diagnosticsModified = false;\n            }\n            return diagnostics;\n        }\n        function getDiagnostics(sourceFile) {\n            if (sourceFile) {\n                checkSourceFile(sourceFile);\n                return ts.filter(getSortedDiagnostics(), function (d) { return d.file === sourceFile; });\n            }\n            ts.forEach(program.getSourceFiles(), checkSourceFile);\n            return getSortedDiagnostics();\n        }\n        function getDeclarationDiagnostics(targetSourceFile) {\n            var resolver = createResolver();\n            checkSourceFile(targetSourceFile);\n            return ts.getDeclarationDiagnostics(program, resolver, targetSourceFile);\n        }\n        function getGlobalDiagnostics() {\n            return ts.filter(getSortedDiagnostics(), function (d) { return !d.file; });\n        }\n        // Language service support\n        function isInsideWithStatementBody(node) {\n            if (node) {\n                while (node.parent) {\n                    if (node.parent.kind === 175 /* WithStatement */ && node.parent.statement === node) {\n                        return true;\n                    }\n                    node = node.parent;\n                }\n            }\n            return false;\n        }\n        function getSymbolsInScope(location, meaning) {\n            var symbols = {};\n            var memberFlags = 0;\n            function copySymbol(symbol, meaning) {\n                if (symbol.flags & meaning) {\n                    var id = symbol.name;\n                    if (!isReservedMemberName(id) && !ts.hasProperty(symbols, id)) {\n                        symbols[id] = symbol;\n                    }\n                }\n            }\n            function copySymbols(source, meaning) {\n                if (meaning) {\n                    for (var id in source) {\n                        if (ts.hasProperty(source, id)) {\n                            copySymbol(source[id], meaning);\n                        }\n                    }\n                }\n            }\n            if (isInsideWithStatementBody(location)) {\n                // We cannot answer semantic questions within a with block, do not proceed any further\n                return [];\n            }\n            while (location) {\n                if (location.locals && !isGlobalSourceFile(location)) {\n                    copySymbols(location.locals, meaning);\n                }\n                switch (location.kind) {\n                    case 201 /* SourceFile */:\n                        if (!ts.isExternalModule(location))\n                            break;\n                    case 189 /* ModuleDeclaration */:\n                        copySymbols(getSymbolOfNode(location).exports, meaning & 35653619 /* ModuleMember */);\n                        break;\n                    case 188 /* EnumDeclaration */:\n                        copySymbols(getSymbolOfNode(location).exports, meaning & 8 /* EnumMember */);\n                        break;\n                    case 185 /* ClassDeclaration */:\n                    case 186 /* InterfaceDeclaration */:\n                        if (!(memberFlags & 128 /* Static */)) {\n                            copySymbols(getSymbolOfNode(location).members, meaning & 3152352 /* Type */);\n                        }\n                        break;\n                    case 150 /* FunctionExpression */:\n                        if (location.name) {\n                            copySymbol(location.symbol, meaning);\n                        }\n                        break;\n                    case 197 /* CatchClause */:\n                        if (location.name.text) {\n                            copySymbol(location.symbol, meaning);\n                        }\n                        break;\n                }\n                memberFlags = location.flags;\n                location = location.parent;\n            }\n            copySymbols(globals, meaning);\n            return ts.mapToArray(symbols);\n        }\n        function isTypeDeclarationName(name) {\n            return name.kind == 63 /* Identifier */ && isTypeDeclaration(name.parent) && name.parent.name === name;\n        }\n        function isTypeDeclaration(node) {\n            switch (node.kind) {\n                case 122 /* TypeParameter */:\n                case 185 /* ClassDeclaration */:\n                case 186 /* InterfaceDeclaration */:\n                case 187 /* TypeAliasDeclaration */:\n                case 188 /* EnumDeclaration */:\n                    return true;\n            }\n        }\n        // True if the given identifier is part of a type reference\n        function isTypeReferenceIdentifier(entityName) {\n            var node = entityName;\n            while (node.parent && node.parent.kind === 120 /* QualifiedName */)\n                node = node.parent;\n            return node.parent && node.parent.kind === 132 /* TypeReference */;\n        }\n        function isTypeNode(node) {\n            if (132 /* FirstTypeNode */ <= node.kind && node.kind <= 140 /* LastTypeNode */) {\n                return true;\n            }\n            switch (node.kind) {\n                case 109 /* AnyKeyword */:\n                case 116 /* NumberKeyword */:\n                case 118 /* StringKeyword */:\n                case 110 /* BooleanKeyword */:\n                    return true;\n                case 97 /* VoidKeyword */:\n                    return node.parent.kind !== 154 /* VoidExpression */;\n                case 7 /* StringLiteral */:\n                    // Specialized signatures can have string literals as their parameters' type names\n                    return node.parent.kind === 123 /* Parameter */;\n                case 63 /* Identifier */:\n                    // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.\n                    if (node.parent.kind === 120 /* QualifiedName */ && node.parent.right === node) {\n                        node = node.parent;\n                    }\n                case 120 /* QualifiedName */:\n                    // At this point, node is either a qualified name or an identifier\n                    ts.Debug.assert(node.kind === 63 /* Identifier */ || node.kind === 120 /* QualifiedName */, \"'node' was expected to be a qualified name or identifier in 'isTypeNode'.\");\n                    var parent = node.parent;\n                    if (parent.kind === 135 /* TypeQuery */) {\n                        return false;\n                    }\n                    // Do not recursively call isTypeNode on the parent. In the example:\n                    //\n                    //     var a: A.B.C;\n                    //\n                    // Calling isTypeNode would consider the qualified name A.B a type node. Only C or\n                    // A.B.C is a type node.\n                    if (132 /* FirstTypeNode */ <= parent.kind && parent.kind <= 140 /* LastTypeNode */) {\n                        return true;\n                    }\n                    switch (parent.kind) {\n                        case 122 /* TypeParameter */:\n                            return node === parent.constraint;\n                        case 124 /* Property */:\n                        case 123 /* Parameter */:\n                        case 183 /* VariableDeclaration */:\n                            return node === parent.type;\n                        case 184 /* FunctionDeclaration */:\n                        case 150 /* FunctionExpression */:\n                        case 151 /* ArrowFunction */:\n                        case 126 /* Constructor */:\n                        case 125 /* Method */:\n                        case 127 /* GetAccessor */:\n                        case 128 /* SetAccessor */:\n                            return node === parent.type;\n                        case 129 /* CallSignature */:\n                        case 130 /* ConstructSignature */:\n                        case 131 /* IndexSignature */:\n                            return node === parent.type;\n                        case 148 /* TypeAssertionExpression */:\n                            return node === parent.type;\n                        case 145 /* CallExpression */:\n                        case 146 /* NewExpression */:\n                            return parent.typeArguments && ts.indexOf(parent.typeArguments, node) >= 0;\n                        case 147 /* TaggedTemplateExpression */:\n                            // TODO (drosen): TaggedTemplateExpressions may eventually support type arguments.\n                            return false;\n                    }\n            }\n            return false;\n        }\n        function isInRightSideOfImportOrExportAssignment(node) {\n            while (node.parent.kind === 120 /* QualifiedName */) {\n                node = node.parent;\n            }\n            if (node.parent.kind === 191 /* ImportDeclaration */) {\n                return node.parent.moduleReference === node;\n            }\n            if (node.parent.kind === 192 /* ExportAssignment */) {\n                return node.parent.exportName === node;\n            }\n            return false;\n        }\n        function isRightSideOfQualifiedNameOrPropertyAccess(node) {\n            return (node.parent.kind === 120 /* QualifiedName */ && node.parent.right === node) || (node.parent.kind === 143 /* PropertyAccessExpression */ && node.parent.name === node);\n        }\n        function getSymbolOfEntityNameOrPropertyAccessExpression(entityName) {\n            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(entityName)) {\n                return getSymbolOfNode(entityName.parent);\n            }\n            if (entityName.parent.kind === 192 /* ExportAssignment */) {\n                return resolveEntityName(entityName.parent.parent, entityName, 107455 /* Value */ | 3152352 /* Type */ | 1536 /* Namespace */ | 33554432 /* Import */);\n            }\n            if (entityName.kind !== 143 /* PropertyAccessExpression */) {\n                if (isInRightSideOfImportOrExportAssignment(entityName)) {\n                    // Since we already checked for ExportAssignment, this really could only be an Import\n                    return getSymbolOfPartOfRightHandSideOfImport(entityName);\n                }\n            }\n            if (isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {\n                entityName = entityName.parent;\n            }\n            if (ts.isExpression(entityName)) {\n                if (ts.getFullWidth(entityName) === 0) {\n                    // Missing entity name.\n                    return undefined;\n                }\n                if (entityName.kind === 63 /* Identifier */) {\n                    // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead\n                    // return the alias symbol.\n                    var meaning = 107455 /* Value */ | 33554432 /* Import */;\n                    return resolveEntityName(entityName, entityName, meaning);\n                }\n                else if (entityName.kind === 143 /* PropertyAccessExpression */) {\n                    var symbol = getNodeLinks(entityName).resolvedSymbol;\n                    if (!symbol) {\n                        checkPropertyAccessExpression(entityName);\n                    }\n                    return getNodeLinks(entityName).resolvedSymbol;\n                }\n                else if (entityName.kind === 120 /* QualifiedName */) {\n                    var symbol = getNodeLinks(entityName).resolvedSymbol;\n                    if (!symbol) {\n                        checkQualifiedName(entityName);\n                    }\n                    return getNodeLinks(entityName).resolvedSymbol;\n                }\n            }\n            else if (isTypeReferenceIdentifier(entityName)) {\n                var meaning = entityName.parent.kind === 132 /* TypeReference */ ? 3152352 /* Type */ : 1536 /* Namespace */;\n                // Include Import in the meaning, this ensures that we do not follow aliases to where they point and instead\n                // return the alias symbol.\n                meaning |= 33554432 /* Import */;\n                return resolveEntityName(entityName, entityName, meaning);\n            }\n            // Do we want to return undefined here?\n            return undefined;\n        }\n        function getSymbolInfo(node) {\n            if (isInsideWithStatementBody(node)) {\n                // We cannot answer semantic questions within a with block, do not proceed any further\n                return undefined;\n            }\n            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {\n                // This is a declaration, call getSymbolOfNode\n                return getSymbolOfNode(node.parent);\n            }\n            if (node.kind === 63 /* Identifier */ && isInRightSideOfImportOrExportAssignment(node)) {\n                return node.parent.kind === 192 /* ExportAssignment */ ? getSymbolOfEntityNameOrPropertyAccessExpression(node) : getSymbolOfPartOfRightHandSideOfImport(node);\n            }\n            switch (node.kind) {\n                case 63 /* Identifier */:\n                case 143 /* PropertyAccessExpression */:\n                case 120 /* QualifiedName */:\n                    return getSymbolOfEntityNameOrPropertyAccessExpression(node);\n                case 91 /* ThisKeyword */:\n                case 89 /* SuperKeyword */:\n                    var type = checkExpression(node);\n                    return type.symbol;\n                case 111 /* ConstructorKeyword */:\n                    // constructor keyword for an overload, should take us to the definition if it exist\n                    var constructorDeclaration = node.parent;\n                    if (constructorDeclaration && constructorDeclaration.kind === 126 /* Constructor */) {\n                        return constructorDeclaration.parent.symbol;\n                    }\n                    return undefined;\n                case 7 /* StringLiteral */:\n                    // External module name in an import declaration\n                    if (ts.isExternalModuleImportDeclaration(node.parent.parent) && ts.getExternalModuleImportDeclarationExpression(node.parent.parent) === node) {\n                        var importSymbol = getSymbolOfNode(node.parent.parent);\n                        var moduleType = getTypeOfSymbol(importSymbol);\n                        return moduleType ? moduleType.symbol : undefined;\n                    }\n                case 6 /* NumericLiteral */:\n                    // index access\n                    if (node.parent.kind == 144 /* ElementAccessExpression */ && node.parent.argumentExpression === node) {\n                        var objectType = checkExpression(node.parent.expression);\n                        if (objectType === unknownType)\n                            return undefined;\n                        var apparentType = getApparentType(objectType);\n                        if (apparentType === unknownType)\n                            return undefined;\n                        return getPropertyOfType(apparentType, node.text);\n                    }\n                    break;\n            }\n            return undefined;\n        }\n        function getShorthandAssignmentValueSymbol(location) {\n            // The function returns a value symbol of an identifier in the short-hand property assignment.\n            // This is necessary as an identifier in short-hand property assignment can contains two meaning:\n            // property name and property value.\n            if (location && location.kind === 199 /* ShorthandPropertyAssignment */) {\n                return resolveEntityName(location, location.name, 107455 /* Value */);\n            }\n            return undefined;\n        }\n        function getTypeOfNode(node) {\n            if (isInsideWithStatementBody(node)) {\n                // We cannot answer semantic questions within a with block, do not proceed any further\n                return unknownType;\n            }\n            if (ts.isExpression(node)) {\n                return getTypeOfExpression(node);\n            }\n            if (isTypeNode(node)) {\n                return getTypeFromTypeNode(node);\n            }\n            if (isTypeDeclaration(node)) {\n                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration\n                var symbol = getSymbolOfNode(node);\n                return getDeclaredTypeOfSymbol(symbol);\n            }\n            if (isTypeDeclarationName(node)) {\n                var symbol = getSymbolInfo(node);\n                return symbol && getDeclaredTypeOfSymbol(symbol);\n            }\n            if (ts.isDeclaration(node)) {\n                // In this case, we call getSymbolOfNode instead of getSymbolInfo because it is a declaration\n                var symbol = getSymbolOfNode(node);\n                return getTypeOfSymbol(symbol);\n            }\n            if (ts.isDeclarationOrFunctionExpressionOrCatchVariableName(node)) {\n                var symbol = getSymbolInfo(node);\n                return symbol && getTypeOfSymbol(symbol);\n            }\n            if (isInRightSideOfImportOrExportAssignment(node)) {\n                var symbol = getSymbolInfo(node);\n                var declaredType = symbol && getDeclaredTypeOfSymbol(symbol);\n                return declaredType !== unknownType ? declaredType : getTypeOfSymbol(symbol);\n            }\n            return unknownType;\n        }\n        function getTypeOfExpression(expr) {\n            if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {\n                expr = expr.parent;\n            }\n            return checkExpression(expr);\n        }\n        // Return the list of properties of the given type, augmented with properties from Function\n        // if the type has call or construct signatures\n        function getAugmentedPropertiesOfType(type) {\n            var type = getApparentType(type);\n            var propsByName = createSymbolTable(getPropertiesOfType(type));\n            if (getSignaturesOfType(type, 0 /* Call */).length || getSignaturesOfType(type, 1 /* Construct */).length) {\n                ts.forEach(getPropertiesOfType(globalFunctionType), function (p) {\n                    if (!ts.hasProperty(propsByName, p.name)) {\n                        propsByName[p.name] = p;\n                    }\n                });\n            }\n            return getNamedMembers(propsByName);\n        }\n        function getRootSymbols(symbol) {\n            if (symbol.flags & 1073741824 /* UnionProperty */) {\n                var symbols = [];\n                var name = symbol.name;\n                ts.forEach(getSymbolLinks(symbol).unionType.types, function (t) {\n                    symbols.push(getPropertyOfType(t, name));\n                });\n                return symbols;\n            }\n            else if (symbol.flags & 268435456 /* Transient */) {\n                var target = getSymbolLinks(symbol).target;\n                if (target) {\n                    return [target];\n                }\n            }\n            return [symbol];\n        }\n        // Emitter support\n        function isExternalModuleSymbol(symbol) {\n            return symbol.flags & 512 /* ValueModule */ && symbol.declarations.length === 1 && symbol.declarations[0].kind === 201 /* SourceFile */;\n        }\n        function isNodeDescendentOf(node, ancestor) {\n            while (node) {\n                if (node === ancestor)\n                    return true;\n                node = node.parent;\n            }\n            return false;\n        }\n        function isUniqueLocalName(name, container) {\n            for (var node = container; isNodeDescendentOf(node, container); node = node.nextContainer) {\n                if (node.locals && ts.hasProperty(node.locals, name)) {\n                    var symbolWithRelevantName = node.locals[name];\n                    if (symbolWithRelevantName.flags & (107455 /* Value */ | 4194304 /* ExportValue */)) {\n                        return false;\n                    }\n                    // An import can be emitted too, if it is referenced as a value.\n                    // Make sure the name in question does not collide with an import.\n                    if (symbolWithRelevantName.flags & 33554432 /* Import */) {\n                        var importDeclarationWithRelevantName = ts.getDeclarationOfKind(symbolWithRelevantName, 191 /* ImportDeclaration */);\n                        if (isReferencedImportDeclaration(importDeclarationWithRelevantName)) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n        function getLocalNameOfContainer(container) {\n            var links = getNodeLinks(container);\n            if (!links.localModuleName) {\n                var prefix = \"\";\n                var name = ts.unescapeIdentifier(container.name.text);\n                while (!isUniqueLocalName(ts.escapeIdentifier(prefix + name), container)) {\n                    prefix += \"_\";\n                }\n                links.localModuleName = prefix + ts.getTextOfNode(container.name);\n            }\n            return links.localModuleName;\n        }\n        function getLocalNameForSymbol(symbol, location) {\n            var node = location;\n            while (node) {\n                if ((node.kind === 189 /* ModuleDeclaration */ || node.kind === 188 /* EnumDeclaration */) && getSymbolOfNode(node) === symbol) {\n                    return getLocalNameOfContainer(node);\n                }\n                node = node.parent;\n            }\n            ts.Debug.fail(\"getLocalNameForSymbol failed\");\n        }\n        function getExpressionNamePrefix(node) {\n            var symbol = getNodeLinks(node).resolvedSymbol;\n            if (symbol) {\n                // In general, we need to prefix an identifier with its parent name if it references\n                // an exported entity from another module declaration. If we reference an exported\n                // entity within the same module declaration, then whether we prefix depends on the\n                // kind of entity. SymbolFlags.ExportHasLocal encompasses all the kinds that we\n                // do NOT prefix.\n                var exportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);\n                if (symbol !== exportSymbol && !(exportSymbol.flags & 944 /* ExportHasLocal */)) {\n                    symbol = exportSymbol;\n                }\n                if (symbol.parent) {\n                    return isExternalModuleSymbol(symbol.parent) ? \"exports\" : getLocalNameForSymbol(getParentOfSymbol(symbol), node.parent);\n                }\n            }\n        }\n        function getExportAssignmentName(node) {\n            var symbol = getExportAssignmentSymbol(getSymbolOfNode(node));\n            return symbol && symbolIsValue(symbol) && !isConstEnumSymbol(symbol) ? symbolToString(symbol) : undefined;\n        }\n        function isTopLevelValueImportWithEntityName(node) {\n            if (node.parent.kind !== 201 /* SourceFile */ || !ts.isInternalModuleImportDeclaration(node)) {\n                // parent is not source file or it is not reference to internal module\n                return false;\n            }\n            return isImportResolvedToValue(getSymbolOfNode(node));\n        }\n        function hasSemanticErrors(sourceFile) {\n            // Return true if there is any semantic error in a file or globally\n            return getDiagnostics(sourceFile).length > 0 || getGlobalDiagnostics().length > 0;\n        }\n        function isEmitBlocked(sourceFile) {\n            return program.getDiagnostics(sourceFile).length !== 0 || hasEarlyErrors(sourceFile) || (compilerOptions.noEmitOnError && getDiagnostics(sourceFile).length !== 0);\n        }\n        function hasEarlyErrors(sourceFile) {\n            return ts.forEach(getDiagnostics(sourceFile), function (d) { return d.isEarly; });\n        }\n        function isImportResolvedToValue(symbol) {\n            var target = resolveImport(symbol);\n            // const enums and modules that contain only const enums are not considered values from the emit perespective\n            return target !== unknownSymbol && target.flags & 107455 /* Value */ && !isConstEnumOrConstEnumOnlyModule(target);\n        }\n        function isConstEnumOrConstEnumOnlyModule(s) {\n            return isConstEnumSymbol(s) || s.constEnumOnlyModule;\n        }\n        function isReferencedImportDeclaration(node) {\n            var symbol = getSymbolOfNode(node);\n            if (getSymbolLinks(symbol).referenced) {\n                return true;\n            }\n            // logic below will answer 'true' for exported import declaration in a nested module that itself is not exported.\n            // As a consequence this might cause emitting extra.\n            if (node.flags & 1 /* Export */) {\n                return isImportResolvedToValue(symbol);\n            }\n            return false;\n        }\n        function isImplementationOfOverload(node) {\n            if (node.body) {\n                var symbol = getSymbolOfNode(node);\n                var signaturesOfSymbol = getSignaturesOfSymbol(symbol);\n                // If this function body corresponds to function with multiple signature, it is implementation of overload\n                // e.g.: function foo(a: string): string;\n                //       function foo(a: number): number;\n                //       function foo(a: any) { // This is implementation of the overloads\n                //           return a;\n                //       }\n                return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);\n            }\n            return false;\n        }\n        function getNodeCheckFlags(node) {\n            return getNodeLinks(node).flags;\n        }\n        function getEnumMemberValue(node) {\n            computeEnumMemberValues(node.parent);\n            return getNodeLinks(node).enumMemberValue;\n        }\n        function getConstantValue(node) {\n            var symbol = getNodeLinks(node).resolvedSymbol;\n            if (symbol && (symbol.flags & 8 /* EnumMember */)) {\n                var declaration = symbol.valueDeclaration;\n                var constantValue;\n                if (declaration.kind === 200 /* EnumMember */ && (constantValue = getNodeLinks(declaration).enumMemberValue) !== undefined) {\n                    return constantValue;\n                }\n            }\n            return undefined;\n        }\n        function writeTypeOfDeclaration(declaration, enclosingDeclaration, flags, writer) {\n            // Get type of the symbol if this is the valid symbol otherwise get type at location\n            var symbol = getSymbolOfNode(declaration);\n            var type = symbol && !(symbol.flags & (2048 /* TypeLiteral */ | 131072 /* CallSignature */ | 262144 /* ConstructSignature */)) ? getTypeOfSymbol(symbol) : unknownType;\n            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);\n        }\n        function writeReturnTypeOfSignatureDeclaration(signatureDeclaration, enclosingDeclaration, flags, writer) {\n            var signature = getSignatureFromDeclaration(signatureDeclaration);\n            getSymbolDisplayBuilder().buildTypeDisplay(getReturnTypeOfSignature(signature), writer, enclosingDeclaration, flags);\n        }\n        function createResolver() {\n            return {\n                getProgram: function () { return program; },\n                getLocalNameOfContainer: getLocalNameOfContainer,\n                getExpressionNamePrefix: getExpressionNamePrefix,\n                getExportAssignmentName: getExportAssignmentName,\n                isReferencedImportDeclaration: isReferencedImportDeclaration,\n                getNodeCheckFlags: getNodeCheckFlags,\n                getEnumMemberValue: getEnumMemberValue,\n                isTopLevelValueImportWithEntityName: isTopLevelValueImportWithEntityName,\n                hasSemanticErrors: hasSemanticErrors,\n                isEmitBlocked: isEmitBlocked,\n                isDeclarationVisible: isDeclarationVisible,\n                isImplementationOfOverload: isImplementationOfOverload,\n                writeTypeOfDeclaration: writeTypeOfDeclaration,\n                writeReturnTypeOfSignatureDeclaration: writeReturnTypeOfSignatureDeclaration,\n                isSymbolAccessible: isSymbolAccessible,\n                isEntityNameVisible: isEntityNameVisible,\n                getConstantValue: getConstantValue,\n            };\n        }\n        function invokeEmitter(targetSourceFile) {\n            var resolver = createResolver();\n            return ts.emitFiles(resolver, targetSourceFile);\n        }\n        function initializeTypeChecker() {\n            // Bind all source files and propagate errors\n            ts.forEach(program.getSourceFiles(), function (file) {\n                ts.bindSourceFile(file);\n                ts.forEach(file.semanticDiagnostics, addDiagnostic);\n            });\n            // Initialize global symbol table\n            ts.forEach(program.getSourceFiles(), function (file) {\n                if (!ts.isExternalModule(file)) {\n                    extendSymbolTable(globals, file.locals);\n                }\n            });\n            // Initialize special symbols\n            getSymbolLinks(undefinedSymbol).type = undefinedType;\n            getSymbolLinks(argumentsSymbol).type = getGlobalType(\"IArguments\");\n            getSymbolLinks(unknownSymbol).type = unknownType;\n            globals[undefinedSymbol.name] = undefinedSymbol;\n            // Initialize special types\n            globalArraySymbol = getGlobalSymbol(\"Array\");\n            globalArrayType = getTypeOfGlobalSymbol(globalArraySymbol, 1);\n            globalObjectType = getGlobalType(\"Object\");\n            globalFunctionType = getGlobalType(\"Function\");\n            globalStringType = getGlobalType(\"String\");\n            globalNumberType = getGlobalType(\"Number\");\n            globalBooleanType = getGlobalType(\"Boolean\");\n            globalRegExpType = getGlobalType(\"RegExp\");\n            // If we're in ES6 mode, load the TemplateStringsArray.\n            // Otherwise, default to 'unknown' for the purposes of type checking in LS scenarios.\n            globalTemplateStringsArrayType = compilerOptions.target >= 2 /* ES6 */ ? getGlobalType(\"TemplateStringsArray\") : unknownType;\n        }\n        initializeTypeChecker();\n        return checker;\n    }\n    ts.createTypeChecker = createTypeChecker;\n})(ts || (ts = {}));\n/// <reference path=\"sys.ts\"/>\n/// <reference path=\"types.ts\"/>\n/// <reference path=\"core.ts\"/>\n/// <reference path=\"scanner.ts\"/>\nvar ts;\n(function (ts) {\n    ts.optionDeclarations = [\n        {\n            name: \"charset\",\n            type: \"string\",\n        },\n        {\n            name: \"codepage\",\n            type: \"number\",\n        },\n        {\n            name: \"declaration\",\n            shortName: \"d\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Generates_corresponding_d_ts_file,\n        },\n        {\n            name: \"diagnostics\",\n            type: \"boolean\",\n        },\n        {\n            name: \"emitBOM\",\n            type: \"boolean\"\n        },\n        {\n            name: \"help\",\n            shortName: \"h\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Print_this_message,\n        },\n        {\n            name: \"locale\",\n            type: \"string\",\n        },\n        {\n            name: \"mapRoot\",\n            type: \"string\",\n            description: ts.Diagnostics.Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations,\n            paramType: ts.Diagnostics.LOCATION,\n        },\n        {\n            name: \"module\",\n            shortName: \"m\",\n            type: {\n                \"commonjs\": 1 /* CommonJS */,\n                \"amd\": 2 /* AMD */\n            },\n            description: ts.Diagnostics.Specify_module_code_generation_Colon_commonjs_or_amd,\n            paramType: ts.Diagnostics.KIND,\n            error: ts.Diagnostics.Argument_for_module_option_must_be_commonjs_or_amd\n        },\n        {\n            name: \"noEmitOnError\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Do_not_emit_outputs_if_any_type_checking_errors_were_reported,\n        },\n        {\n            name: \"noImplicitAny\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Warn_on_expressions_and_declarations_with_an_implied_any_type,\n        },\n        {\n            name: \"noLib\",\n            type: \"boolean\",\n        },\n        {\n            name: \"noLibCheck\",\n            type: \"boolean\",\n        },\n        {\n            name: \"noResolve\",\n            type: \"boolean\",\n        },\n        {\n            name: \"out\",\n            type: \"string\",\n            description: ts.Diagnostics.Concatenate_and_emit_output_to_single_file,\n            paramType: ts.Diagnostics.FILE,\n        },\n        {\n            name: \"outDir\",\n            type: \"string\",\n            description: ts.Diagnostics.Redirect_output_structure_to_the_directory,\n            paramType: ts.Diagnostics.DIRECTORY,\n        },\n        {\n            name: \"preserveConstEnums\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Do_not_erase_const_enum_declarations_in_generated_code\n        },\n        {\n            name: \"removeComments\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Do_not_emit_comments_to_output,\n        },\n        {\n            name: \"sourceMap\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Generates_corresponding_map_file,\n        },\n        {\n            name: \"sourceRoot\",\n            type: \"string\",\n            description: ts.Diagnostics.Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations,\n            paramType: ts.Diagnostics.LOCATION,\n        },\n        {\n            name: \"suppressImplicitAnyIndexErrors\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures,\n        },\n        {\n            name: \"target\",\n            shortName: \"t\",\n            type: { \"es3\": 0 /* ES3 */, \"es5\": 1 /* ES5 */, \"es6\": 2 /* ES6 */ },\n            description: ts.Diagnostics.Specify_ECMAScript_target_version_Colon_ES3_default_ES5_or_ES6_experimental,\n            paramType: ts.Diagnostics.VERSION,\n            error: ts.Diagnostics.Argument_for_target_option_must_be_es3_es5_or_es6\n        },\n        {\n            name: \"version\",\n            shortName: \"v\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Print_the_compiler_s_version,\n        },\n        {\n            name: \"watch\",\n            shortName: \"w\",\n            type: \"boolean\",\n            description: ts.Diagnostics.Watch_input_files,\n        }\n    ];\n    var shortOptionNames = {};\n    var optionNameMap = {};\n    ts.forEach(ts.optionDeclarations, function (option) {\n        optionNameMap[option.name.toLowerCase()] = option;\n        if (option.shortName) {\n            shortOptionNames[option.shortName] = option.name;\n        }\n    });\n    function parseCommandLine(commandLine) {\n        // Set default compiler option values\n        var options = {\n            target: 0 /* ES3 */,\n            module: 0 /* None */\n        };\n        var filenames = [];\n        var errors = [];\n        parseStrings(commandLine);\n        return {\n            options: options,\n            filenames: filenames,\n            errors: errors\n        };\n        function parseStrings(args) {\n            var i = 0;\n            while (i < args.length) {\n                var s = args[i++];\n                if (s.charCodeAt(0) === 64 /* at */) {\n                    parseResponseFile(s.slice(1));\n                }\n                else if (s.charCodeAt(0) === 45 /* minus */) {\n                    s = s.slice(s.charCodeAt(1) === 45 /* minus */ ? 2 : 1).toLowerCase();\n                    // Try to translate short option names to their full equivalents.\n                    if (ts.hasProperty(shortOptionNames, s)) {\n                        s = shortOptionNames[s];\n                    }\n                    if (ts.hasProperty(optionNameMap, s)) {\n                        var opt = optionNameMap[s];\n                        // Check to see if no argument was provided (e.g. \"--locale\" is the last command-line argument).\n                        if (!args[i] && opt.type !== \"boolean\") {\n                            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_expects_an_argument, opt.name));\n                        }\n                        switch (opt.type) {\n                            case \"number\":\n                                options[opt.name] = parseInt(args[i++]);\n                                break;\n                            case \"boolean\":\n                                options[opt.name] = true;\n                                break;\n                            case \"string\":\n                                options[opt.name] = args[i++] || \"\";\n                                break;\n                            default:\n                                var map = opt.type;\n                                var key = (args[i++] || \"\").toLowerCase();\n                                if (ts.hasProperty(map, key)) {\n                                    options[opt.name] = map[key];\n                                }\n                                else {\n                                    errors.push(ts.createCompilerDiagnostic(opt.error));\n                                }\n                        }\n                    }\n                    else {\n                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unknown_compiler_option_0, s));\n                    }\n                }\n                else {\n                    filenames.push(s);\n                }\n            }\n        }\n        function parseResponseFile(filename) {\n            var text = ts.sys.readFile(filename);\n            if (!text) {\n                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.File_0_not_found, filename));\n                return;\n            }\n            var args = [];\n            var pos = 0;\n            while (true) {\n                while (pos < text.length && text.charCodeAt(pos) <= 32 /* space */)\n                    pos++;\n                if (pos >= text.length)\n                    break;\n                var start = pos;\n                if (text.charCodeAt(start) === 34 /* doubleQuote */) {\n                    pos++;\n                    while (pos < text.length && text.charCodeAt(pos) !== 34 /* doubleQuote */)\n                        pos++;\n                    if (pos < text.length) {\n                        args.push(text.substring(start + 1, pos));\n                        pos++;\n                    }\n                    else {\n                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unterminated_quoted_string_in_response_file_0, filename));\n                    }\n                }\n                else {\n                    while (text.charCodeAt(pos) > 32 /* space */)\n                        pos++;\n                    args.push(text.substring(start, pos));\n                }\n            }\n            parseStrings(args);\n        }\n    }\n    ts.parseCommandLine = parseCommandLine;\n})(ts || (ts = {}));\n/// <reference path=\"typescript/src/compiler/core.ts\"/>\n/// <reference path=\"typescript/src/compiler/sys.ts\"/>\n/// <reference path=\"typescript/src/compiler/types.ts\"/>\n/// <reference path=\"typescript/src/compiler/scanner.ts\"/>\n/// <reference path=\"typescript/src/compiler/parser.ts\"/>\n/// <reference path=\"typescript/src/compiler/binder.ts\"/>\n/// <reference path=\"typescript/src/compiler/checker.ts\"/>\n/// <reference path=\"typescript/src/compiler/emitter.ts\"/>\n/// <reference path=\"typescript/src/compiler/commandLineParser.ts\"/>\n/// <reference path=\"types.ts\"/>\nvar path = require('path');\nvar fs = require('fs');\nvar tsc;\n(function (tsc) {\n    function shallowClone(obj) {\n        var clone = {};\n        for (var k in obj)\n            if (obj.hasOwnProperty(k)) {\n                clone[k] = obj[k];\n            }\n        return clone;\n    }\n    var CompositeCompilerHost = (function () {\n        function CompositeCompilerHost(options) {\n            this._sources = {};\n            this._outputs = {};\n            /**\n             * Whether to search for files if a string source isn't found or not\n             */\n            this.fallbackToFiles = false;\n            this.readsFrom = 0 /* File */;\n            this.writesTo = 0 /* File */;\n            // Implementing CompilerHost interface\n            this.getNewLine = function () { return ts.sys.newLine; };\n            this.readsFrom = 0 /* File */;\n            this.getSourceFile = this._readFromFile;\n            this.writesTo = 0 /* File */;\n            this.writeFile = this._writeToFile;\n            this.options = options || {};\n            this.options.defaultLibFilename = this.options.defaultLibFilename || '';\n        }\n        Object.defineProperty(CompositeCompilerHost.prototype, \"sources\", {\n            get: function () {\n                return shallowClone(this._sources);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(CompositeCompilerHost.prototype, \"outputs\", {\n            get: function () {\n                return shallowClone(this._outputs);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Implementing CompilerHost interface\n        CompositeCompilerHost.prototype.useCaseSensitiveFileNames = function () {\n            return ts.sys.useCaseSensitiveFileNames;\n        };\n        // Implementing CompilerHost interface\n        CompositeCompilerHost.prototype.getCurrentDirectory = function () {\n            if (this.getSourceFile === this._readFromStrings)\n                return '';\n            return this._currentDirectory || (this._currentDirectory = ts.sys.getCurrentDirectory());\n        };\n        // Implementing CompilerHost interface\n        CompositeCompilerHost.prototype.getDefaultLibFilename = function () {\n            return this.options.defaultLibFilename || path.join(__dirname, \"lib\", \"lib.d.ts\");\n        };\n        // Implementing CompilerHost interface\n        CompositeCompilerHost.prototype.getCanonicalFileName = function (fileName) {\n            // if underlying system can distinguish between two files whose names differs only in cases then file name already in canonical form.\n            // otherwise use toLowerCase as a canonical form.\n            return ts.sys.useCaseSensitiveFileNames ? fileName : fileName.toLowerCase();\n        };\n        CompositeCompilerHost.prototype.readFromStrings = function (fallbackToFiles) {\n            if (fallbackToFiles === void 0) { fallbackToFiles = false; }\n            this.fallbackToFiles = fallbackToFiles;\n            this.readsFrom = 1 /* String */;\n            this.getSourceFile = this._readFromStrings;\n            return this;\n        };\n        CompositeCompilerHost.prototype.readFromFiles = function () {\n            this.readsFrom = 0 /* File */;\n            this.getSourceFile = this._readFromFile;\n            return this;\n        };\n        CompositeCompilerHost.prototype.addSource = function (nameOrContents, contents) {\n            var source;\n            if (typeof contents == 'undefined')\n                source = new tsc.StringSource(nameOrContents);\n            else\n                source = new tsc.StringSource(contents, nameOrContents);\n            this._sources[source.filename] = source.contents;\n            return this;\n        };\n        CompositeCompilerHost.prototype.getSourcesFilenames = function () {\n            var keys = [];\n            for (var k in this.sources)\n                if (this.sources.hasOwnProperty(k))\n                    keys.push(k);\n            return keys;\n        };\n        CompositeCompilerHost.prototype.writeToString = function () {\n            this.writesTo = 1 /* String */;\n            this.writeFile = this._writeToString;\n            return this;\n        };\n        CompositeCompilerHost.prototype.writeToFiles = function () {\n            this.writesTo = 0 /* File */;\n            this.writeFile = this._writeToFile;\n            return this;\n        };\n        CompositeCompilerHost.prototype.redirectOutput = function (writer) {\n            if (typeof writer == 'function')\n                this._writer = writer;\n            else\n                this._writer = null;\n            return this;\n        };\n        //////////////////////////////\n        // private methods\n        //////////////////////////////\n        CompositeCompilerHost.prototype._readFromStrings = function (filename, languageVersion, onError) {\n            if (path.normalize(filename) === this.getDefaultLibFilename())\n                return this._readFromFile(filename, languageVersion, onError);\n            if (this._sources[filename])\n                return ts.createSourceFile(filename, this._sources[filename], languageVersion, \"0\");\n            if (this.fallbackToFiles)\n                return this._readFromFile(filename, languageVersion, onError);\n            return undefined;\n        };\n        CompositeCompilerHost.prototype._writeToString = function (filename, data, writeByteOrderMark, onError) {\n            this._outputs[filename] = data;\n            if (this._writer)\n                this._writer(filename, data, writeByteOrderMark, onError);\n        };\n        CompositeCompilerHost.prototype._readFromFile = function (filename, languageVersion, onError) {\n            try {\n                var text = ts.sys.readFile(path.normalize(filename));\n            }\n            catch (e) {\n                if (onError) {\n                    onError(e.message);\n                }\n                text = \"\";\n            }\n            return text !== undefined ? ts.createSourceFile(filename, text, languageVersion, \"0\") : undefined;\n        };\n        CompositeCompilerHost.prototype._writeToFile = function (fileName, data, writeByteOrderMark, onError) {\n            var existingDirectories = {};\n            function directoryExists(directoryPath) {\n                if (ts.hasProperty(existingDirectories, directoryPath)) {\n                    return true;\n                }\n                if (ts.sys.directoryExists(directoryPath)) {\n                    existingDirectories[directoryPath] = true;\n                    return true;\n                }\n                return false;\n            }\n            function ensureDirectoriesExist(directoryPath) {\n                if (directoryPath.length > ts.getRootLength(directoryPath) && !directoryExists(directoryPath)) {\n                    var parentDirectory = ts.getDirectoryPath(directoryPath);\n                    ensureDirectoriesExist(parentDirectory);\n                    ts.sys.createDirectory(directoryPath);\n                }\n            }\n            try {\n                if (this._writer) {\n                    this._writer(fileName, data, writeByteOrderMark, onError);\n                }\n                else {\n                    ensureDirectoriesExist(ts.getDirectoryPath(ts.normalizePath(fileName)));\n                    ts.sys.writeFile(fileName, data, writeByteOrderMark);\n                }\n                this._outputs[fileName] = (writeByteOrderMark ? '\\uFEFF' : '') + data;\n            }\n            catch (e) {\n                if (onError)\n                    onError(e.message);\n            }\n        };\n        return CompositeCompilerHost;\n    })();\n    tsc.CompositeCompilerHost = CompositeCompilerHost;\n})(tsc || (tsc = {}));\n/// <reference path=\"types.ts\"/>\n/// <reference path=\"typescript/src/compiler/core.ts\"/>\n/// <reference path=\"typescript/src/compiler/sys.ts\"/>\n/// <reference path=\"typescript/src/compiler/types.ts\"/>\n/// <reference path=\"typescript/src/compiler/scanner.ts\"/>\n/// <reference path=\"typescript/src/compiler/parser.ts\"/>\n/// <reference path=\"typescript/src/compiler/binder.ts\"/>\n/// <reference path=\"typescript/src/compiler/checker.ts\"/>\n/// <reference path=\"typescript/src/compiler/emitter.ts\"/>\n/// <reference path=\"typescript/src/compiler/commandLineParser.ts\"/>\n/// <reference path=\"compositeCompilerHost.ts\"/>\nvar tsc;\n(function (tsc) {\n    function formatError(diagnostic) {\n        var output = \"\";\n        if (diagnostic.file) {\n            var loc = diagnostic.file.getLineAndCharacterFromPosition(diagnostic.start);\n            output += diagnostic.file.filename + \"(\" + loc.line + \",\" + loc.character + \"): \";\n        }\n        var category = ts.DiagnosticCategory[diagnostic.category].toLowerCase();\n        output += category + \" TS\" + diagnostic.code + \": \" + diagnostic.messageText + ts.sys.newLine;\n        return output;\n    }\n    function forwardErrors(errors, onError) {\n        if (typeof onError == 'function') {\n            errors.forEach(function (e) {\n                e.formattedMessage = formatError(e);\n                onError(e);\n            });\n        }\n    }\n    function _compile(host, sources, tscArgs, options, onError) {\n        if (typeof tscArgs == \"string\")\n            tscArgs = tscArgs.split(' ');\n        else\n            tscArgs = tscArgs || [];\n        var commandLine = ts.parseCommandLine(tscArgs);\n        var files;\n        if (host.readsFrom == 1 /* String */) {\n            sources.forEach(function (s) { return host.addSource(s.filename, s.contents); });\n            files = host.getSourcesFilenames();\n        }\n        else {\n            files = ts.map(sources, function (s) { return s.filename; }).concat(commandLine.filenames);\n        }\n        var program = ts.createProgram(files, commandLine.options, host);\n        // Query for early errors\n        var errors = program.getDiagnostics();\n        // todo: make async\n        forwardErrors(errors, onError);\n        // Do not generate code in the presence of early errors\n        if (!errors.length) {\n            // Type check and get semanic errors\n            var checker = program.getTypeChecker(true);\n            var semanticErrors = checker.getDiagnostics();\n            // todo: make async\n            forwardErrors(semanticErrors, onError);\n            // Generate output\n            var emitResult = checker.emitFiles();\n            // todo: make async\n            forwardErrors(emitResult.diagnostics, onError);\n            errors = ts.concatenate(semanticErrors, emitResult.diagnostics);\n        }\n        return {\n            sources: host.outputs,\n            sourceMaps: emitResult && emitResult.sourceMaps ? emitResult.sourceMaps : [],\n            errors: ts.map(errors, function (e) {\n                return formatError(e);\n            })\n        };\n    }\n    function compileWithHost(host, sources, tscArgs, options, onError) {\n        return _compile(host, sources, tscArgs, options, onError);\n    }\n    tsc.compileWithHost = compileWithHost;\n    function compile(files, tscArgs, options, onError) {\n        if (typeof files == 'string')\n            files = [files];\n        return _compile(new tsc.CompositeCompilerHost(options), ts.map(files, function (f) { return new tsc.FileSource(f); }), tscArgs, options, onError);\n    }\n    tsc.compile = compile;\n    function compileStrings(input, tscArgs, options, onError) {\n        var host = new tsc.CompositeCompilerHost(options).readFromStrings().writeToString();\n        var sources = [];\n        if (Array.isArray(input) && input.length) {\n            // string[]\n            if (typeof input[0] == 'string') {\n                sources = ts.map(input, function (s) { return new tsc.StringSource(s); });\n            }\n            else if (input[0] instanceof tsc.StringSource) {\n                sources.concat(input);\n            }\n            else\n                throw new Error('Invalid value for input argument');\n        }\n        else if (typeof input == 'object') {\n            for (var k in input)\n                if (input.hasOwnProperty(k))\n                    sources.push(new tsc.StringSource(input[k], k));\n        }\n        else\n            throw new Error('Invalid value for input argument');\n        return _compile(host, sources, tscArgs, options, onError);\n    }\n    tsc.compileStrings = compileStrings;\n    function compileString(input, tscArgs, options, onError) {\n        if (typeof input != \"string\" && !(input instanceof tsc.StringSource))\n            throw new Error(\"typescript-compiler#compileString: input parameter should be either a string or a StringSource object\");\n        if (input == '')\n            return '';\n        var result = '';\n        var host = new tsc.CompositeCompilerHost(options).readFromStrings().writeToString().redirectOutput(function (filename, data) { return result += data; });\n        _compile(host, [input instanceof tsc.StringSource ? input : new tsc.StringSource(input, 'string.ts')], tscArgs, options, onError);\n        return result;\n    }\n    tsc.compileString = compileString;\n})(tsc || (tsc = {}));\nmodule.exports = tsc;\n","/home/travis/build/npmtest/node-npmtest-typescript-compiler/node_modules/typescript-compiler/watch.js":"var tsc = require('./index');\n\nvar r = tsc.compile('test/compiler.ts', '-w -m commonjs');\n\nconsole.log(tsc.executeCommandLine);\n"}